'' MisoYume - Souper NES emulator
'' [alpha version]
CON

#include "config.spin2"

  _CLKFREQ = 343636320 ' debug only

  UPPER_LOAD = $5_0000

  OUTBUFFER_WIDTH = 512

  TIME_RENDER = false
  TIME_COMPOSITE = false
  TIME_CMATH = false

  'DEBUG_TIMESTAMP = TRUE

DAT
              org
              coginit #0,##UPPER_LOAD
              orgh $14
_clkf         long 0
_clkm         long 0
_rk_init_ptr            long @rk_hub_init ' < $1C
_vdp_outbuffer_ptr      long @scanout_buffer ' < $20
_ppr_load_ptr           long @ppr_entry
_ppc_init_ptr           long @ppc_init
_ppm_load_ptr           long @ppm_entry      ' < $2C
_palette_ptr            long @palette_current ' < $30
_vram_ptr               long @vram            ' < $34
_oam_ptr                long @oam
_spc_init_ptr           long @sp_init         ' < $3C


              orgh
ppu_fixedcolor  long $A0_00_00_00 ' Fixed color as 32bpp
ppu_mathconfig  ' alias  
ppu_cgwsel      byte $20
ppu_cgadsub     byte $6F
ppu_inidisp     byte $0F
ppu_m7sel       byte $00 ' Stuff M7SEL here
ppu_mode        ' alias
ppu_bgmode      byte $00
ppu_setini      byte $00
ppu_mosaic      byte $00
ppu_mosaicreset byte 0 ' set to reset vertical mosaic state in PPR
ppu_winpos      ' alias
ppu_wh0         byte $40
ppu_wh1         byte $50
ppu_wh2         byte $41
ppu_wh3         byte $42
ppu_winsel      ' alias
ppu_w12sel      byte $08
ppu_w34sel      byte $00
ppu_wobjsel     byte $20
                byte 0 ' unused byte
ppu_winlog      ' alias
ppu_wbglog      byte $00
ppu_wobjlog     byte $00
                byte 0 ' unused byte
                byte 0 ' unused byte
ppu_through     ' alias
ppu_tm          byte $11
ppu_tmw         byte $00
ppu_ts          byte $00
ppu_tsw         byte $00
ppu_namebase    'alias
ppu_bg1sc       byte $00
ppu_bg2sc       byte $00
ppu_bg3sc       byte $00
ppu_bg4sc       byte $00
ppu_tilebase    'alias
ppu_bg12nba     byte $11
ppu_bg34nba     byte $11
                byte 0 ' unused byte
                byte 0 ' unused byte
ppu_bg1_scroll  'alias
ppu_bg1hofs     word $0000
ppu_bg1vofs     word $0000
ppu_bg2_scroll  'alias
ppu_bg2hofs     word $FFF4
ppu_bg2vofs     word $FFF4
ppu_bg3_scroll  'alias
ppu_bg3hofs     word $FFE8
ppu_bg3vofs     word $FFE8
ppu_bg4_scroll  'alias
ppu_bg4hofs     word $FFDC
ppu_bg4vofs     word $FFDC

ppu_spriteconf
ppu_oamadd      word $0000 ' OAM address (in bytes?)
ppu_oamrot      byte $80 ' has OAM rotation flag
ppu_objsel      byte $00 ' OBJSEL is also here

ppu_mode7hv
ppu_m7hofs      word 0
ppu_m7vofs      word 0
ppu_mode7ab
ppu_m7a         word 0
ppu_m7b         word 0
ppu_mode7cd
ppu_m7c         word 0
ppu_m7d         word 0
ppu_mode7xy
ppu_m7x         word 0
ppu_m7y         word 0


ppu_bgofs_latch byte 0,0 ' second is for HOFS special sauce latch only
ppu_mode7_latch byte 0,0 ' second is unused but clobbed
'ppu_vram_addr   word 0
                word 0
ppu_vram_latch  word 0

ppu_cgaddr      word 0
ppu_cglatch     byte 0
                byte 0 ' unused but clobbed

ppu_oamlatch    byte 0

                byte 0,0,0 ' unused


bbus_wmaddr     long $000000

elapsed_cycles  long 0

              orgh $D8
emupad_data     long 0[8]

              orgh $F8
video_line_ctr          long 0
video_frame_ctr         long 0

              orgh $100
              '' DMA registers live here, for all 8 channels
              '' byte A1TnL, A1TnH, A2AnL, A2AnH
              '' byte DASnL, DASnH, DASBn, NLTRn
              '' byte DMAPn, BBADn, UNUSEDn, A1Bn (all registers that do not change)
rk_dmaregs    byte 0[8*12]

fakeapuhack   word $1AA

DAT ' B-Bus jump tables
              
              orgh $200
'' TODO: fill out which registers read/write PPU open bus
bbus_read_tbl
wordfit rk_read_openbus    ' 00: INIDISP
wordfit rk_read_openbus    ' 01: OBJSEL
wordfit rk_read_openbus    ' 02: OAMADDL
wordfit rk_read_openbus    ' 03: OAMADDH
wordfit bbus_read_ppu1open ' 04: OAMDATA
wordfit bbus_read_ppu1open ' 05: BGMODE
wordfit bbus_read_ppu1open ' 06: MOSAIC
wordfit rk_read_openbus    ' 07: BG1SC
wordfit bbus_read_ppu1open ' 08: BG2SC
wordfit bbus_read_ppu1open ' 09: BG3SC
wordfit bbus_read_ppu1open ' 0A: BG4SC
wordfit rk_read_openbus    ' 0B: BG12NBA
wordfit rk_read_openbus    ' 0C: BG34NBA
wordfit rk_read_openbus    ' 0D: BG1HOFS / M7HOFS
wordfit rk_read_openbus    ' 0E: BG1VOFS / M7VOFS
wordfit rk_read_openbus    ' 0F: BG2HOFS
wordfit rk_read_openbus    ' 10: BG2VOFS
wordfit rk_read_openbus    ' 11: BG3HOFS
wordfit rk_read_openbus    ' 12: BG3VOFS
wordfit rk_read_openbus    ' 13: BG4HOFS
wordfit bbus_read_ppu1open ' 14: BG4VOFS
wordfit bbus_read_ppu1open ' 15: VMAIN
wordfit bbus_read_ppu1open ' 16: VMADDL
wordfit rk_read_openbus    ' 17: VMADDH
wordfit bbus_read_ppu1open ' 18: VMDATAL
wordfit bbus_read_ppu1open ' 19: VMDATAH
wordfit bbus_read_ppu1open ' 1A: M7SEL
wordfit rk_read_openbus    ' 1B: M7A
wordfit rk_read_openbus    ' 1C: M7B
wordfit rk_read_openbus    ' 1D: M7C
wordfit rk_read_openbus    ' 1E: M7D
wordfit rk_read_openbus    ' 1F: M7X
wordfit rk_read_openbus    ' 20: M7Y
wordfit rk_read_openbus    ' 21: CGADD
wordfit rk_read_openbus    ' 22: CGDATA
wordfit rk_read_openbus    ' 23: W12SEL
wordfit bbus_read_ppu1open ' 24: W34SEL
wordfit bbus_read_ppu1open ' 25: WOBJSEL
wordfit bbus_read_ppu1open ' 26: WH0
wordfit rk_read_openbus    ' 27: WH1
wordfit bbus_read_ppu1open ' 28: WH2
wordfit bbus_read_ppu1open ' 29: WH3
wordfit bbus_read_ppu1open ' 2A: WBGLOG
wordfit rk_read_openbus    ' 2B: WOBJLOG
wordfit rk_read_openbus    ' 2C: TM
wordfit rk_read_openbus    ' 2D: TS
wordfit rk_read_openbus    ' 2E: TMW
wordfit rk_read_openbus    ' 2F: TSW
wordfit rk_read_openbus    ' 30: CGWSEL
wordfit rk_read_openbus    ' 31: CGADSUB
wordfit rk_read_openbus    ' 32: COLDATA
wordfit rk_read_openbus    ' 33: SETINI
wordfit ppu_read_mpyl      ' 34: MPYL
wordfit ppu_read_mpym      ' 35: MPYM
wordfit ppu_read_mpyh      ' 36: MPYH
wordfit rk_read_openbus    ' 37: SLHV (TODO)
wordfit rk_read_openbus    ' 38: OAMDATAREAD (TODO)
wordfit ppu_read_vmdatal   ' 39: VMDATALREAD
wordfit ppu_read_vmdatah   ' 3A: VMDATAHREAD
wordfit ppu_read_cgdata    ' 3B: CGDATAREAD
wordfit rk_read_openbus    ' 3C: OPHCT (TODO)
wordfit rk_read_openbus    ' 3D: OPVCT (TODO)
wordfit rk_read_openbus    ' 3E: STAT77 (TODO)
wordfit rk_read_openbus    ' 3F: STAT78 (TODO)
wordfit apu_readio0        ' 40: APUIO0 (TODO)
wordfit apu_readio1        ' 41: APUIO1 (TODO)
wordfit apu_readio2        ' 42: APUIO2 (TODO)
wordfit apu_readio3        ' 43: APUIO3 (TODO)
wordfit apu_readio0        ' 44: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 45: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 46: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 47: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 48: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 49: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 4A: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 4B: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 4C: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 4D: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 4E: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 4F: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 50: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 51: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 52: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 53: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 54: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 55: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 56: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 57: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 58: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 59: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 5A: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 5B: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 5C: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 5D: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 5E: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 5F: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 60: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 61: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 62: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 63: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 64: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 65: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 66: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 67: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 68: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 69: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 6A: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 6B: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 6C: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 6D: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 6E: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 6F: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 70: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 71: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 72: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 73: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 74: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 75: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 76: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 77: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 78: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 79: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 7A: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 7B: APUIO3 mirror (TODO)
wordfit apu_readio0        ' 7C: APUIO0 mirror (TODO)
wordfit apu_readio1        ' 7D: APUIO1 mirror (TODO)
wordfit apu_readio2        ' 7E: APUIO2 mirror (TODO)
wordfit apu_readio3        ' 7F: APUIO3 mirror (TODO)
wordfit bbus_read_wmdata   ' 80: WMDATA
wordfit rk_read_openbus    ' 81: WMADDL (write-only)
wordfit rk_read_openbus    ' 82: WMADDM (write-only)
wordfit rk_read_openbus    ' 83: WMADDH (write-only)
wordfit rk_read_openbus[$FF - $83]

                  orgh $400
bbus_write_tbl
wordfit ppu_write_inidisp  ' 00: INIDISP
wordfit ppu_write_objsel   ' 01: OBJSEL
wordfit ppu_write_oamaddl  ' 02: OAMADDL
wordfit ppu_write_oamaddh  ' 03: OAMADDH
wordfit ppu_write_oamdata  ' 04: OAMDATA
wordfit ppu_write_bgmode   ' 05: BGMODE
wordfit ppu_write_mosaic   ' 06: MOSAIC
wordfit ppu_write_bg1sc    ' 07: BG1SC
wordfit ppu_write_bg2sc    ' 08: BG2SC
wordfit ppu_write_bg3sc    ' 09: BG3SC
wordfit ppu_write_bg4sc    ' 0A: BG4SC
wordfit ppu_write_bg12nba  ' 0B: BG12NBA
wordfit ppu_write_bg34nba  ' 0C: BG34NBA
wordfit ppu_write_bg1hofs  ' 0D: BG1HOFS / M7HOFS
wordfit ppu_write_bg1vofs  ' 0E: BG1VOFS / M7VOFS
wordfit ppu_write_bg2hofs  ' 0F: BG2HOFS
wordfit ppu_write_bg2vofs  ' 10: BG2VOFS
wordfit ppu_write_bg3hofs  ' 11: BG3HOFS
wordfit ppu_write_bg3vofs  ' 12: BG3VOFS
wordfit ppu_write_bg4hofs  ' 13: BG4HOFS
wordfit ppu_write_bg4vofs  ' 14: BG4VOFS
wordfit ppu_write_vmain    ' 15: VMAIN
wordfit ppu_write_vmaddl   ' 16: VMADDL 
wordfit ppu_write_vmaddh   ' 17: VMADDH
wordfit rk_write_openbus   ' 18: VMDATAL (implementation selected at runtime)
wordfit rk_write_openbus   ' 19: VMDATAH (implementation selected at runtime)
wordfit ppu_write_m7sel    ' 1A: M7SEL
wordfit ppu_write_m7a      ' 1B: M7A
wordfit ppu_write_m7b      ' 1C: M7B
wordfit ppu_write_m7c      ' 1D: M7C
wordfit ppu_write_m7d      ' 1E: M7D
wordfit ppu_write_m7x      ' 1F: M7X
wordfit ppu_write_m7y      ' 20: M7Y
wordfit ppu_write_cgadd    ' 21: CGADD
wordfit ppu_write_cgdata   ' 22: CGDATA
wordfit ppu_write_w12sel   ' 23: W12SEL
wordfit ppu_write_w34sel   ' 24: W34SEL
wordfit ppu_write_wobjsel  ' 25: WOBJSEL
wordfit ppu_write_wh0      ' 26: WH0
wordfit ppu_write_wh1      ' 27: WH1
wordfit ppu_write_wh2      ' 28: WH2
wordfit ppu_write_wh3      ' 29: WH3
wordfit ppu_write_wbglog   ' 2A: WBGLOG
wordfit ppu_write_wobjlog  ' 2B: WOBJLOG
wordfit ppu_write_tm       ' 2C: TM
wordfit ppu_write_ts       ' 2D: TS
wordfit ppu_write_tmw      ' 2E: TMW
wordfit ppu_write_tsw      ' 2F: TSW
wordfit ppu_write_cgwsel   ' 30: CGWSEL
wordfit ppu_write_cgadsub  ' 31: CGADSUB
wordfit ppu_write_coldata  ' 32: COLDATA
wordfit ppu_write_setini   ' 33: SETINI
wordfit rk_write_openbus   ' 34: MPYL
wordfit rk_write_openbus   ' 35: MPYM
wordfit rk_write_openbus   ' 36: MPYH
wordfit rk_write_openbus   ' 37: SLHV
wordfit rk_write_openbus   ' 38: OAMDATAREAD
wordfit rk_write_openbus   ' 39: VMDATALREAD
wordfit rk_write_openbus   ' 3A: VMDATAHREAD
wordfit rk_write_openbus   ' 3B: CGDATAREAD
wordfit rk_write_openbus   ' 3C: OPHCT (TODO)
wordfit rk_write_openbus   ' 3D: OPVCT (TODO)
wordfit rk_write_openbus   ' 3E: STAT77 (TODO)
wordfit rk_write_openbus   ' 3F: STAT78 (TODO)
wordfit apu_writeio0       ' 40: APUIO0 (TODO)
wordfit apu_writeio1       ' 41: APUIO1 (TODO)
wordfit apu_writeio2       ' 42: APUIO2 (TODO)
wordfit apu_writeio3       ' 43: APUIO3 (TODO)
wordfit apu_writeio0       ' 44: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 45: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 46: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 47: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 48: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 49: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 4A: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 4B: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 4C: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 4D: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 4E: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 4F: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 50: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 51: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 52: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 53: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 54: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 55: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 56: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 57: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 58: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 59: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 5A: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 5B: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 5C: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 5D: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 5E: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 5F: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 60: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 61: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 62: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 63: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 64: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 65: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 66: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 67: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 68: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 69: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 6A: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 6B: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 6C: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 6D: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 6E: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 6F: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 70: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 71: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 72: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 73: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 74: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 75: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 76: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 77: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 78: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 79: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 7A: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 7B: APUIO3 mirror (TODO)
wordfit apu_writeio0       ' 7C: APUIO0 mirror (TODO)
wordfit apu_writeio1       ' 7D: APUIO1 mirror (TODO)
wordfit apu_writeio2       ' 7E: APUIO2 mirror (TODO)
wordfit apu_writeio3       ' 7F: APUIO3 mirror (TODO)
wordfit bbus_write_wmdata  ' 80: WMDATA
wordfit bbus_write_wmaddl  ' 81: WMADDL
wordfit bbus_write_wmaddm  ' 82: WMADDM
wordfit bbus_write_wmaddh  ' 83: WMADDH
wordfit rk_write_openbus[$FF - $83]

DAT ' 5A22 MMIO jump table
              orgh $600
rk_io_rw_tbl
' Write-only registers
wordfit rk_write_nmitimen   ' 00: NMITIMEN
wordfit rk_write_openbus   ' 01: WRIO
wordfit rk_write_wrmpya   ' 02: WRMPYA
wordfit rk_write_wrmpyb   ' 03: WRMPYB
wordfit rk_write_wrdivl   ' 04: WRDIVL
wordfit rk_write_wrdivh   ' 05: WRDIVH
wordfit rk_write_wrdivb   ' 06: WRDIVB
wordfit rk_write_htimel   ' 07: HTIMEL
wordfit rk_write_htimeh   ' 08: HTIMEH
wordfit rk_write_vtimel   ' 09: VTIMEL
wordfit rk_write_vtimeh   ' 0A: VTIMEH
wordfit rk_write_mdmaen    ' 0B: MDMAEN
wordfit rk_write_openbus   ' 0C: HDMAEN
wordfit rk_write_memsel    ' 0D: MEMSEL
wordfit rk_write_openbus   ' 0E: unused?
wordfit rk_write_openbus   ' 0F: unused?
' Read-only registers
wordfit rk_read_rdnmi    ' 10: RDNMI
wordfit rk_read_timeup    ' 11: TIMEUP
wordfit rk_read_hvbjoy    ' 12: HVBJOY
wordfit rk_read_openbus    ' 13: RDIO
wordfit rk_read_rddivl    ' 14: RDDIVL
wordfit rk_read_rddivh    ' 15: RDDIVH
wordfit rk_read_rdmpyl    ' 16: RDMPYL
wordfit rk_read_rdmpyh    ' 17: RDMPYH
wordfit rk_read_joy1l    ' 18: JOY1L
wordfit rk_read_joy1h    ' 19: JOY1H
wordfit rk_read_joy2l    ' 1A: JOY2L
wordfit rk_read_joy2h    ' 1B: JOY2H
wordfit rk_read_joy3l    ' 1C: JOY3L
wordfit rk_read_joy3h    ' 1D: JOY3H
wordfit rk_read_joy4l    ' 1E: JOY4L
wordfit rk_read_joy4h    ' 1F: JOY4H



DAT ' B-Bus Miscellany
              orgh
bbus_read_wmdata
              loc pa,#work_ram
              rdlong rk_memtmp1,#bbus_wmaddr
              add pa,rk_memtmp1
              incmod rk_memtmp1,##$01FFFF
              wrlong rk_memtmp1,#bbus_wmaddr
              rdbyte rk_memv,pa
              setbyte rk_openbus,rk_memv,#0
              ret wcz

bbus_write_wmaddl
              wrbyte rk_memv,#bbus_wmaddr+0
              ret wcz
bbus_write_wmaddm
              wrbyte rk_memv,#bbus_wmaddr+1
              ret wcz
bbus_write_wmaddh
              and rk_memv,#$01
              wrbyte rk_memv,#bbus_wmaddr+2
              ret wcz

bbus_write_wmdata
              loc pa,#work_ram
              rdlong rk_memtmp1,#bbus_wmaddr
              add pa,rk_memtmp1
              incmod rk_memtmp1,##$01FFFF
              wrlong rk_memtmp1,#bbus_wmaddr
              wrbyte rk_memv,pa
              ret wcz

bbus_read_ppu1open
              getbyte rk_memv,rk_openbus,#1
              ret wcz
{
bbus_read_ppu2open
              getbyte rk_memv,rk_openbus,#2
              ret wcz
}



CON ' Memory constants

#ifdef USE_PSRAM16
PSRAM_PAGESIZE = 0 addbits 11
PSRAM_ASHIFT = 2
PSRAM_ALIGNMASK = 3
#endif

#ifdef USE_PSRAM8
PSRAM_PAGESIZE = 0 addbits 10
PSRAM_ASHIFT = 1
PSRAM_ALIGNMASK = 1
#endif

#ifdef USE_PSRAM4
PSRAM_PAGESIZE = 0 addbits 9
PSRAM_ASHIFT = 0
PSRAM_ALIGNMASK = 0
#define PSRAM_UNALIGNED
#endif

#ifdef USE_PSRAM_SLOW
PSRAM_CLKDIV = 3
PSRAM_CYSHL = 0
#else
PSRAM_CLKDIV = 2
PSRAM_CYSHL = 1
#endif


CON ' RiKore 65816 constants

RK_AMOP = 1<<10
RK_AMODE_DP     = RK_AMOP|( 0<<28)
RK_AMODE_DPX    = RK_AMOP|( 1<<28)
RK_AMODE_DPY    = RK_AMOP|( 2<<28)
RK_AMODE_DPI    = RK_AMOP|( 3<<28)
RK_AMODE_DPXI   = RK_AMOP|( 4<<28)
RK_AMODE_DPIY   = RK_AMOP|( 5<<28)
RK_AMODE_DPJ    = RK_AMOP|( 6<<28)
RK_AMODE_DPJY   = RK_AMOP|( 7<<28)
RK_AMODE_SP     = RK_AMOP|( 8<<28)
RK_AMODE_SPIY   = RK_AMOP|( 9<<28)
RK_AMODE_ABS    = RK_AMOP|(10<<28)
RK_AMODE_ABSX   = RK_AMOP|(11<<28)
RK_AMODE_ABSY   = RK_AMOP|(12<<28)
RK_AMODE_ABL    = RK_AMOP|(13<<28)
RK_AMODE_ABLX   = RK_AMOP|(14<<28)


RK_CARRY_BIT = 0
RK_ZERO_BIT  = 1
RK_IRQ_BIT   = 2
RK_DEC_BIT   = 3
RK_XW_BIT    = 4 ' Also break bit
RK_MW_BIT    = 5
RK_OVER_BIT  = 6
RK_NEG_BIT   = 7

DAT ' RiKore Ricoh 5A22 (65816+DMA) cog resident code
              org 0
rk_cogcode


'rk_ohno
              'debug(" OH SNAP! ",uhex_byte_array(#@work_ram+$0B,#1))
              'debug("PC: ",uhex_long_(rk_pc), " PSW: ",ubin_byte_(rk_flags), " E: ",udec_(rk_emumode))
              'debug("SP: ",uhex_word_(rk_sp)," DP: ",uhex_word_(rk_dp)," DB: ",uhex_long_(rk_dbank))
              'debug("A: ",uhex_word_(rk_accu)," X: ",uhex_word_(rk_x)," Y: ",uhex_word_(rk_y))
              'jmp #.yesdebug
 
              ' Do one-shot dma

rk_start_mdma
              jmp #rk_hub_mdma_start ' trampoline to hubexec

rk_rasterirq
              '' TODO handle masking correctly
              'debug("RASTER IRQ ",ubin_byte(rk_flags),ubin_long(rk_interrupt_flags))
              mov rk_until_irq,rk_10000
              bith rk_interrupt_flags,#16
              mov rk_optmp1,#$FE
              testb rk_flags,#RK_IRQ_BIT wc
        if_nc jmp #rk_doirq
              jmp #rk_nextop

rk_time  long 0
rk_eol
              'getct pa
              'subr rk_time,pa
              'rdlong pb,#video_line_ctr wc
              'debug("scanline end ",udec(rk_curline,pa,rk_time))
              'incmod rk_curline,#261
.wait         rdlong pa,#video_line_ctr wc
        if_c add pa,#262
              cmp rk_curline,pa wz
        'if_nz jmp #rk_eol ' BUGGGY SYNC
        'if_nz jmp #.wait
        if_z  jmp #.wait
              incmod rk_curline,#261
              add rk_until_eol,##1364 - 000 - 40 '' TODO: account for DRAM refresh?
              mov rk_until_hdma,##1112 - 40

              'debug(udec(rk_curline))
              'getct rk_time
              'debug("scanline start ",udec(rk_curline,rk_eoltime))

              '' TODO more detailed NMI logic
              '' shouldn't fire if we are in middle of DMA etc
              '' should refire if the NMI is unmasked while not ack'd, etc
              cmp rk_curline,#0 wz
        if_z  bitl rk_interrupt_flags,#8
              cmp rk_curline,#225 wz
        if_z  bith rk_interrupt_flags,#8
              tjs rk_mdmaen,#rk_start_mdma
              testb rk_interrupt_flags,#7 andz
        if_z  mov rk_optmp1,#$FA
        if_z  jmp #rk_doirq

              'debug(udec(rk_curline,rk_vtime),ubin_byte(rk_flags),uhex_long(rk_pc))
              mov rk_until_irq,rk_10000
              test rk_interrupt_flags,#$30 wz
        if_z  jmp #.irqoff
              cmp rk_curline,rk_vtime wz
              testbn rk_interrupt_flags,#5 orz
              testb rk_interrupt_flags,#4 wc
       if_11   mov rk_until_irq,rk_htime
       if_01   mov rk_until_irq,#0
.irqoff

rk_nextop
              'debug(udec(rk_cycles))
              'call #rk_validate
              push #rk_nextop
              add rk_elapsed,rk_cycles
              wrlong rk_elapsed,#elapsed_cycles
              sub rk_until_eol,rk_cycles
              sub rk_until_irq,rk_cycles
              mov rk_cycles, #0

              tjs rk_until_eol,#rk_eol
              tjnz rk_mdmaen,#rk_start_mdma
              tjs rk_until_irq,#rk_rasterirq

              '' TODO
              'cmp rk_pc,##$0000_A33A wz
         'if_z jmp #.yesdebug
              'cmp rk_pc,##$0000_8B49 wz
         'if_z jmp #.yesdebug
              'cmp rk_sp,##$2000 wcz
         'if_ae jmp #.yesdebug
              'cmp rk_sp,#$100 wcz
         'if_b jmp #.yesdebug
              'cmp rk_sp,#0 wcz
         'if_z jmp #.yesdebug
              'cmp rk_pc,##$0000_8E8E wcz
         'f_nz jmp #.nodebug
              'cmpr rk_pc,##$00_8E49 wc
        'if_b cmp rk_pc,##$00_8E9C wc
        'if_ae jmp #.nodebug
.yesdebug
              'debug("PC: ",uhex_long_(rk_pc), " PSW: ",ubin_byte_(rk_flags), " E: ",udec_(rk_emumode),uhex_long(rk_debugpc),uhex_word_array(#work_ram+$0440,#1))
              'debug("SP: ",uhex_word_(rk_sp)," DP: ",uhex_word_(rk_dp)," DB: ",uhex_long_(rk_dbank))
              'debug("A: ",uhex_word_(rk_accu)," X: ",uhex_word_(rk_x)," Y: ",uhex_word_(rk_y))
              'long 0[3]
.nodebug              
              'mov rk_debugpc,rk_pc
              call rk_readcode_f
              'debug("Instruction: ",uhex_byte_(rk_memv),uhex_long(rk_writeM_f))
              'mul rk_memv,#16
              'add rk_memv,rk_optbase
              'rdlong rk_opimpl,rk_memv
              rdlut rk_opimpl,rk_memv
              bitl  rk_opimpl,#10 wcz
        if_nc execf rk_opimpl
              getnib pa,rk_opimpl,#7
              altd pa,#rk_amode_tbl
              skipf 0-0
              setnib rk_opimpl,#0,#7
              ' Handle all common addressing modes here
              call rk_readcode_f
              call #\rk_readcode16                      
              call #\rk_readcode24
              mov rk_ea,rk_memv

              add rk_ea,rk_x
              add rk_ea,rk_y

              andn rk_ea,rk_emumode ' DP wraparound in emulation mode

              add rk_ea,rk_dp
              add rk_ea,rk_sp
              zerox rk_ea,#15 ' all reads based on DP and SP wrap in bank 0

              add rk_cycles,#6 ' internal cycle
              add rk_cycles,rk_dp_penalty ' DP unaligned penalty
              add rk_cycles,rk_xy_penalty ' wide index register penalty (remember to stores always have this - should also be on page crossing but w/e)

              call #\rk_read16
              call #\rk_read24

              mov rk_ea,rk_memv
              add rk_ea,rk_y
              add rk_ea,rk_dbank ' Can't use SETBYTE because indexing wraps across banks

              execf rk_opimpl

rk_amode_tbl
              '' MEGA TODO REVISIT TOMORROW
              '' CHECK PENALTY CYCLES!!!

              'long %0_111_11_111_11_1110_0 ' #8 (memv)
              'long %0_111_11_111_11_1101_0 ' #16 (memv)
              long %0_111_11_011_010_1_11_0110_0 ' d
              long %0_111_11_100_010_0_10_0110_0 ' d,x
              long %0_111_11_100_010_0_01_0110_0 ' d,y
              long %0_010_10_101_010_1_11_0110_0 ' (d)
              long %0_010_10_110_010_0_10_0110_0 ' (d,x)
              long %0_000_10_111_010_1_11_0110_0 ' (d),y
              long %0_110_01_111_010_1_11_0110_0 ' [d]
              long %0_100_01_111_010_1_11_0110_0 ' [d],y
              long %0_111_11_111_001_1_11_0110_0 ' d,s
              long %0_100_10_111_001_1_11_0110_0 ' (d,s),y
              long %0_011_11_111_111_1_11_0101_0 ' a
              long %0_011_11_111_111_1_10_0101_0 ' a,x
              long %0_011_11_111_111_1_01_0101_0 ' a,y
              long %0_111_11_111_111_1_11_0011_0 ' al
              long %0_111_11_111_111_1_10_0011_0 ' al,x
              'long 0 ' unused slot

rk_readcode8
              jmp rk_readcode_f ' trampoline!

rk_readcode16
              call rk_readcode_f
              rolbyte rk_rwtmp,rk_memv,#0
              call rk_readcode_f
        _ret_ rolbyte rk_memv,rk_rwtmp,#0

rk_readcode24
              call rk_readcode_f
              rolbyte rk_rwtmp,rk_memv,#0
              call #rk_readcode16
        _ret_ rolbyte rk_memv,rk_rwtmp,#1

rk_rmwrite16
              rolbyte rk_rwtmp,rk_memv,#0
              getbyte rk_memv,rk_memv,#1
              call #rk_write8
              sub rk_ea,#1
              getbyte rk_memv,rk_rwtmp,#0
              jmp #rk_write8

rk_write16
              rolbyte rk_rwtmp,rk_memv,#1
              getbyte rk_memv,rk_memv,#0
              call #rk_write8
              add rk_ea,#1
              getbyte rk_memv,rk_rwtmp,#0
              ' fall through
rk_write8     
              setbyte rk_openbus,rk_memv,#0
              test rk_ea,rk_romselmask wz
        if_nz jmp #rk_write_romsel
              getbyte pa, rk_ea, #1
              cmp pa,#$20 wcz
        if_c  jmp #rk_write_wram_low ' needs NZ!!!
              cmp pa,#$60 wc
        if_nc jmp #rk_write_expansion
              add rk_cycles,#6 ' everything else is 6-cycle (except $4000..$41FF)
              cmp pa,#$21 wz
        if_z  jmp #rk_write_bbus

              cmp pa,#$43 wz
        if_z  jmp #rk_write_dma
              cmp pa,#$42 wz
        if_z  jmp #rk_write_io

              cmp pa,#$40 wz
        if_nz cmp pa,#$41 wz
        if_z  jmp #rk_write_joyshift
              

              ret wcz
              {
              add rk_cycles,#8
              loc pa,#work_ram
              mov rk_memtmp1,rk_ea
              zerox rk_memtmp1,#16
              add rk_memtmp1,pa
              wrbyte rk_memv,rk_memtmp1
              ret wcz
              }

{
rk_push24
              rolword rk_rwtmp,rk_memv,#0
              getbyte rk_memv,rk_memv,#2
              call #rk_push8
              getword rk_memv,rk_rwtmp,#0
              ' fall through
}
rk_push16
              rolbyte rk_rwtmp,rk_memv,#0
              getbyte rk_memv,rk_memv,#1
              call #rk_push8
              getbyte rk_memv,rk_rwtmp,#0
              ' fall through
rk_push8
              mov rk_ea,rk_sp
              call #rk_write8
              decmod rk_sp,rk_ffff
        _ret_ tjnz rk_emumode,#$+1
        _ret_ setbyte rk_sp,#1,#1

rk_pull8
              incmod rk_sp,rk_ffff
              tjz rk_emumode,#$+2
              setbyte rk_sp,#1,#1 ' TODO: Could use SMC to save 2 cycles
              mov rk_ea,rk_sp
              jmp #rk_read8

rk_readcode_ram ' Also when executing from registers because yes
              mov rk_ea,rk_pc
              add rk_pc,#1
              test rk_pc,rk_ffff wz
        if_z  sub rk_pc,rk_10000
rk_read8
              test rk_ea,rk_romselmask wz
        if_nz jmp #rk_read_romsel
              getbyte pa, rk_ea, #1
              cmp pa,#$20 wcz
        if_c  jmp #rk_read_wram_low ' needs NZ!!!
              cmp pa,#$60 wc
        if_nc jmp #rk_read_expansion
              add rk_cycles,#6 ' everything else is 6-cycle (except $4000..$41FF)
              cmp pa,#$21 wz
        if_z  jmp #rk_read_bbus

              cmp pa,#$43 wz
        if_z  jmp #rk_read_dma
              cmp pa,#$42 wz
        if_z  jmp #rk_read_io

              cmp pa,#$40 wz
        if_nz cmp pa,#$41 wz
        if_z  jmp #rk_read_joyshift

rk_read_openbus
              getbyte rk_memv,rk_openbus,#0
rk_write_openbus
              ret wcz


              {
              add rk_cycles,#8
              loc pa,#work_ram
              mov rk_memtmp1,rk_ea
              zerox rk_memtmp1,#16
              add rk_memtmp1,pa
              rdbyte rk_memv,rk_memtmp1
              setbyte rk_openbus,rk_memv,#0
              ret wcz
              }

rk_read_bbus
              mov pa,#bbus_read_tbl>>9
              jmp #$+2
rk_write_bbus
              mov pa,#bbus_write_tbl>>9
              rolbyte pa,rk_ea,#0
rk_tbljmp     shl pa,#1
              rdword pa,pa
              jmp pa

rk_write_io
              test rk_ea,#$F0 wz
        if_nz ret wcz
              jmp #$+4
rK_read_io
              test rk_ea,#$E0 wz
              testb rk_ea,#4 wc
  if_nc_or_nz jmp #rk_read_openbus

              loc pa,#rk_io_rw_tbl>>1
              setq #%11111
              muxq pa,rk_ea
              jmp #rk_tbljmp

rk_read_expansion
              '' TODO
              add rk_cycles,#8
              getbyte rk_memv,rk_openbus,#0
              ret wcz

rk_write_expansion
              add rk_cycles,#8
              ret wcz


rk_read16
              call #rk_read8
              rolbyte rk_rwtmp,rk_memv,#0
              add rk_ea,#1
              call #rk_read8
        _ret_ rolbyte rk_memv,rk_rwtmp,#0

rk_read24
              call #rk_read8
              rolbyte rk_rwtmp,rk_memv,#0
              add rk_ea,#1
              call #rk_read16
        _ret_ rolbyte rk_memv,rk_rwtmp,#1

rk_pull16
              call #rk_pull8
              rolbyte rk_rwtmp,rk_memv,#0
              call #rk_pull8
        _ret_ rolbyte rk_memv,rk_rwtmp,#0
{
rk_pull24
              call #rk_pull8
              rolbyte rk_rwtmp,rk_memv,#0
              call #rk_pull16
        _ret_ rolbyte rk_memv,rk_rwtmp,#1
}

rk_cmp        mov rk_optmp1,rk_accu
              and rk_optmp1,rk_maskM
rk_cpx        mov rk_optmp1,rk_x
rk_cpy        mov rk_optmp1,rk_y
              
              call rk_readM_f
              call rk_readcodeM_f
              call rk_readX_f
              call rk_readcodeX_f

              sub rk_optmp1,rk_memv wcz

              bitz rk_flags,#RK_ZERO_BIT
              bitnc rk_flags,#RK_CARRY_BIT ' carry is inverted!

              testb rk_optmp1,rk_msbM wc
              testb rk_optmp1,rk_msbX wc
        _ret_ bitc rk_flags,#RK_NEG_BIT

rk_bitop      ' TRB / TSB
              call rk_readM_f

              test rk_memv,rk_accu wz ' TRB/TSB
              andn rk_memv,rk_accu ' TRB
              or rk_memv,rk_accu ' TSB

              bitz rk_flags,#RK_ZERO_BIT
              and rk_memv,rk_maskM
              jmp rk_rmwriteM_f

rk_rmwop_accu
              
              mov rk_memv,rk_accu
              and rk_memv,rk_maskM
              add rk_cycles,#6
rk_rmwop      ' INC/DEC/shifts
              call rk_readM_f

              incmod rk_memv,rk_maskM wz ' INC
              decmod rk_memv,rk_maskM wz ' DEC

              testb rk_flags,#RK_CARRY_BIT wz ' ROR/ROL
              'signx rk_memv,rk_msbM ' ASR (DOESN'T ACTUALLY EXIST???)
              shr rk_memv,#1 wc
              bitz rk_memv,rk_msbM ' ROR
              testb rk_memv,rk_msbM wc ' ASL/ROL
              shl rk_memv,#1
              bitz rk_memv,#0 ' ROL

              bitc rk_flags,#RK_CARRY_BIT ' shifts
              and rk_memv,rk_maskM wz ' shifts

              bitz rk_flags,#RK_ZERO_BIT
              testb rk_memv,rk_msbM wc
              bitc rk_flags,#RK_NEG_BIT

              setq rk_maskM     ' for accu ops
        _ret_ muxq rk_accu,rk_memv

              jmp rk_rmwriteM_f


rk_aluop      ' ADC/SBC/AND/ORA/EOR/BIT
              call rk_readM_f
rk_aluop_imm  call rk_readcodeM_f


              alts rk_msbM,#511 ' BIT non-immediate
              testb rk_memv,#31 wz  ' ADC (clear Z) / BIT non-immediate
              bitz rk_flags,#RK_OVER_BIT ' BIT non-immediate
              modz _set wz ' SBC

              mov rk_optmp1,rk_accu

              testb rk_flags,#RK_CARRY_BIT wc ' ADC/SBC
              xor rk_memv,rk_maskM ' SBC
              call rk_addsub_f ' ADC/SBC

              and rk_optmp1,rk_memv ' AND/BIT
              or rk_optmp1,rk_memv ' ORA
              xor rk_optmp1,rk_memv ' EOR

              setq rk_maskM
              muxq rk_accu,rk_optmp1

              test rk_optmp1, rk_maskM wz
              testb rk_optmp1, rk_msbM wc

              testb rk_memv,rk_msbM wc ' BIT non-immediate

              bitc rk_flags,#RK_NEG_BIT ' skip for immediate BIT
        _ret_ bitz rk_flags,#RK_ZERO_BIT

              ' For all addsub functions:
              ' Z=1 indicates sub mode
              ' C is set to input carry

rk_addsub_bin8
              zerox rk_optmp1,#7 ' mask upper byte
              mov pa,rk_optmp1
              addx rk_optmp1,rk_memv
              xor pa,rk_memv
              xor pa,rk_optmp1
              bitl rk_optmp1,#8 wcz
              bitc rk_flags,#RK_CARRY_BIT
              test pa,#$180 wc
        _ret_ bitc rk_flags,#RK_OVER_BIT


rk_addsub_bin16
              mov pa,rk_optmp1
              addx rk_optmp1,rk_memv
              xor pa,rk_memv
              xor pa,rk_optmp1
              bitl rk_optmp1,#16 wcz
              bitc rk_flags,#RK_CARRY_BIT
              test pa,rk_18000 wc
        _ret_ bitc rk_flags,#RK_OVER_BIT ' todo: faster computation of overflow?

rk_18000      long $18000

rk_addsub_dec8
              getnib rk_optmp2,rk_optmp1,#0
              getnib rk_optmp3,rk_memv,#0
              addx rk_optmp2,rk_optmp3
        if_nz cmpr rk_optmp2,#$09 wc
        if_z  cmpr rk_optmp2,#$0F wc
    if_c_ne_z sumz rk_optmp2,#$06
              setnib rk_optmp1,rk_optmp2,#0

              getnib rk_optmp2,rk_optmp1,#1
              getnib rk_optmp3,rk_memv,#1
              mov pa,rk_optmp2
              addx rk_optmp2,rk_optmp3
              xor pa,rk_optmp2
              xor pa,rk_optmp3
              test pa,#$18 wc
              bitc rk_flags,#RK_OVER_BIT
        if_nz cmpr rk_optmp2,#$09 wc
        if_z  cmpr rk_optmp2,#$0F wc
    if_c_ne_z sumz rk_optmp2,#$06
              setnib rk_optmp1,rk_optmp2,#1

        _ret_ bitc rk_flags,#RK_CARRY_BIT

rk_addsub_dec16
              getnib rk_optmp2,rk_optmp1,#0
              getnib rk_optmp3,rk_memv,#0
              addx rk_optmp2,rk_optmp3
        if_nz cmpr rk_optmp2,#$09 wc
        if_z  cmpr rk_optmp2,#$0F wc
    if_c_ne_z sumz rk_optmp2,#$06
              setnib rk_optmp1,rk_optmp2,#0

              getnib rk_optmp2,rk_optmp1,#1
              getnib rk_optmp3,rk_memv,#1
              addx rk_optmp2,rk_optmp3
        if_nz cmpr rk_optmp2,#$09 wc
        if_z  cmpr rk_optmp2,#$0F wc
    if_c_ne_z sumz rk_optmp2,#$06
              setnib rk_optmp1,rk_optmp2,#1

              getnib rk_optmp2,rk_optmp1,#2
              getnib rk_optmp3,rk_memv,#2
              addx rk_optmp2,rk_optmp3
        if_nz cmpr rk_optmp2,#$09 wc
        if_z  cmpr rk_optmp2,#$0F wc
    if_c_ne_z sumz rk_optmp2,#$06
              setnib rk_optmp1,rk_optmp2,#2

              getnib rk_optmp2,rk_optmp1,#3
              getnib rk_optmp3,rk_memv,#3
              mov pa,rk_optmp2
              addx rk_optmp2,rk_optmp3
              xor pa,rk_optmp2
              xor pa,rk_optmp3
              test pa,#$18 wc
              bitc rk_flags,#RK_OVER_BIT
        if_nz cmpr rk_optmp2,#$09 wc
        if_z  cmpr rk_optmp2,#$0F wc
    if_c_ne_z sumz rk_optmp2,#$06
              setnib rk_optmp1,rk_optmp2,#3

        _ret_ bitc rk_flags,#RK_CARRY_BIT
              


rk_sta
              mov rk_memv,rk_accu
              and rk_memv,rk_maskM

rk_stx        mov rk_memv,rk_x
rk_sty        mov rk_memv,rk_y
rk_stz        
              mov rk_memv,#0

              cmp rk_xy_penalty,#0 wz ' for abs,x/y
        if_z  add rk_cycles,#6        ' for abs,x/y

              jmp rk_writeM_f
              jmp rk_writeX_f



rk_lda_imm    call rk_readcodeM_f
rk_ldxy_imm   call rk_readcodeX_f
rk_lda        call rk_readM_f
rk_ldxy       call rk_readX_f

              setq rk_maskM
              muxq rk_accu,rk_memv
              test rk_memv,rk_maskM wz
              testb rk_memv,rk_msbM wc

              mov rk_x,rk_memv wz
              mov rk_y,rk_memv wz
              testb rk_memv,rk_msbX wc
rk_xba
              movbyts rk_accu,#%%3201 ' XBA
              test rk_accu,#255 wz ' XBA
              testb rk_accu,#7 wc ' XBA
              add rk_cycles,#12 ' XBA 2 internal cycles

              bitz rk_flags,#RK_ZERO_BIT
        _ret_ bitc rk_flags,#RK_NEG_BIT
              

rk_pld
              add rk_cycles,#12 ' pulls have 2 internal cycles
              call #\rk_pull16
              mov rk_dp,rk_memv wz
rk_tcd
              add rk_cycles,#6 ' internal cycle
              mov rk_dp, rk_accu wz

              testb rk_dp,#15 wc
              bitz rk_flags,#RK_ZERO_BIT
              bitc rk_flags,#RK_NEG_BIT

              test rk_dp, #255 wz
              wrnz rk_dp_penalty
        _ret_ mul rk_dp_penalty,#6


rk_pull
              add rk_cycles,#12 ' pulls have 2 internal cycles
              testb rk_flags,#RK_MW_BIT wc ' PLA
              testb rk_flags,#RK_XW_BIT wc ' PLX/PLY
              call #\rk_pull8 ' PLB
        if_c  call #\rk_pull8 ' PLA/PLY/PLX
        if_nc call #\rk_pull16 ' PLA/PLY/PLX


              mov rk_dbank,rk_memv wz
              shl rk_dbank,#16

              setq rk_maskM
              muxq rk_accu,rk_memv
              test rk_accu,rk_maskM wz

              mov rk_x,rk_memv wz
              mov rk_y,rk_memv wz

              bitz rk_flags,#RK_ZERO_BIT

              testb rk_memv,#7 wc  ' PLB
              testb rk_memv,rk_msbM wc ' PLA
              testb rk_memv,rk_msbX wc ' PLX/PLY
        _ret_ bitc rk_flags,#RK_NEG_BIT


rk_softint    ' BRK/COP
              call rk_readcode_f ' read dummy byte
              cmp rk_emumode,#0 wz ' BRK
        if_nz mov rk_optmp1,#$FE ' BRK (emu mode)
        if_z  mov rk_optmp1,#$F6 ' BRK (native mode)
              mov rk_optmp1,#$F4 ' COP

rk_doirq      ' rk_optmp1 should have vector low byte
              add rk_cycles,#12 ' 2 internal cycles for IRQ/NMI

              cmp rk_emumode,#0 wz
              getbyte rk_memv,rk_pc,#2
        if_z  call #\rk_push8
        if_nz bitl rk_flags,#RK_XW_BIT ' skip for BRK
        if_z  andn rk_optmp1,#$10 ' move to native vectors
              ' can stop SKIP patterns here
              getword rk_memv,rk_pc,#0
              call #\rk_push16
              'debug("interrupt at ",uhex_long(rk_pc),uhex_word(rk_optmp1,rk_sp))

              mov rk_memv,rk_flags
              call #\rk_push8

              bitl rk_flags,#RK_DEC_BIT
              bith rk_flags,#RK_IRQ_BIT
              call #rk_flagsloaded


              mov rk_ea,#$FF
              rolbyte rk_ea,rk_optmp1,#0
              call #\rk_read16
              'debug("interrupt vector ",uhex_long(rk_memv,rk_ea))
              mov rk_pc,rk_memv
              jmp #\rk_dojump

rk_rti
              call #\rk_plp
rk_rts
              add rk_cycles,#12 ' already in PLP
              call #\rk_pull16
              add rk_memv,#1 ' RTS/RTL only
              setword rk_pc,rk_memv,#0

              tjnz rk_emumode,#.emu ' RTI only
              call #\rk_pull8 ' RTI/RTL
              setbyte rk_pc,rk_memv,#2 ' RTI/RTL
.emu          jmp #\rk_dojump

              ' We also do WDM here because lol
rk_branch     call rk_readcode_f
              signx rk_memv,#7
rk_brl        call #\rk_readcode16 ' BRL
              ' don't need to extend BRL because of wraping

              testb rk_flags,#RK_CARRY_BIT wc
              testb rk_flags,#RK_ZERO_BIT wc
              testb rk_flags,#RK_OVER_BIT wc
              testb rk_flags,#RK_NEG_BIT wc

        if_c  ret
        if_nc ret

              add rk_cycles,#6 ' internal cycle when branch is taken
              
rk_dobranch   ' rk_memv has branch offset
              ' TODO: ROM logic
              getbyte rk_optmp1,rk_pc,#2
              add rk_pc,rk_memv
              setbyte rk_pc,rk_optmp1,#2
        '      cmp rk_memv,##-2 wz
        'if_z  jmp #rk_ohno

rk_dojump     ' rk_pc has new PC
              mov rk_readcode_f,#rk_readcode_ram
              'cmp rk_pc,##$8097 wz
        'if_nz  jmp #.nodebug
              'cmp rk_pc,##$8000 wc
        'if_ae  jmp #.nodebug
              'debug(uhex_long(rk_debugpc,rk_pc))
.nodebug
              ret



rk_ffff       long $FFFF
rk_3ff        long $3FF
rk_10000      long $10000
rk_bit31      long 1<<31
rk_romselmask long %01000000_10000000_00000000

rk_dcacheloc  long @romdata_cache

rk_varstart

#ifdef USE_PSRAM16
rk_psram_pinfield long PSRAM_BASE addpins 15
rk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + ($8<<16) + 8
rk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD
#endif
#ifdef USE_PSRAM8
rk_psram_pinfield long PSRAM_BASE addpins 7
rk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + ($8<<16) + 8
rk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE
#endif
#ifdef USE_PSRAM4
rk_psram_pinfield long PSRAM_BASE addpins 3
rk_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_4DAC1 + 8
rk_psram_read_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_4P_4DAC1_WFBYTE
#endif
#ifdef USE_HYPER
rk_hyper_addr_cmd1 long (HYPER_BASE<<17)|X_PINS_ON | X_IMM_4X8_1DAC8 + 4
rk_hyper_addr_cmd2 long (HYPER_BASE<<17)|X_PINS_ON | X_IMM_4X8_1DAC8 + 2
rk_hyper_read_cmd  long (HYPER_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE
#endif

rk_nco_fast   long $8000_0000
#ifdef USE_PSRAM_EITHER
#ifdef USE_PSRAM_SLOW
rk_nco_slow   long $2AAA_AAAB
#else
rk_nco_slow   long $4000_0000
#endif
#else
rk_nco_slow   long $4000_0000
#endif


rk_romcache_start long -1
rk_romcache_end long -1

rk_rom_speed  res 1
rk_muldiv_args res 1
rk_muldiv_result res 1
rk_mdmaen         res 1

 ' bottom 8 bits are NMITIMEN
 ' bit 8 is NMI pending flag
 ' bit 16 is IRQ pending flag?
rk_interrupt_flags   res 1

rk_cycles     res 1
rk_elapsed    res 1
' Hiroari shot a strange bird and it fell on the RESTORE key
rk_until_eol  res 1
rk_until_hdma  res 1
rk_until_irq  res 1

rk_curline    res 1

rk_vtime      res 1
rk_htime      res 1

rk_accu       res 1
rk_x          res 1
rk_y          res 1
rk_sp         res 1
rk_dp         res 1
rk_dbank      res 1
rk_optbase    res 1
rk_flags      res 1
rk_emumode    res 1
rk_pc         res 1

rk_memv       res 1
rk_ea         res 1
rk_dmach      ' alias
rk_opimpl     res 1
rk_optmp1     res 1
rk_optmp2     res 1
rk_optmp3     res 1
rk_memtmp1    res 1
rk_memtmp2    res 1
rk_memtmp3    res 1

rk_romio_length res 1

rk_openbus    res 1

rk_readcode_f res 1

rk_readM_f    res 1
rk_writeM_f   res 1
rk_rmwriteM_f res 1
rk_readcodeM_f res 1
rk_readX_f    res 1
rk_writeX_f   res 1
rk_readcodeX_f res 1
rk_maskM      res 1
rk_maskX      res 1
rk_msbM       res 1
rk_msbX       res 1
rk_addsub_f   res 1

rk_dp_penalty res 1
rk_xy_penalty res 1

rk_dmainc     ' alias
rk_rwtmp      res 1

rk_dma_bbptr  res 2
rk_dma_suboff res 1


rk_ppu_vmain_vmadd  res 1 ' PPU registers stored here for speed
rk_ppu_oamadd_oamlatch res 1 ' OAMADD still needs to be mirrored to hub

'rk_debugpc    res 1

              fit 502

DAT ' RiKore 65816 LUT resident code
              org 512
rk_lutcode

long rk_softint+%01001_1_10000<<10                                              ' 00: BRK
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DPXI                   ' 01: ORA (d,x)
long rk_softint+%00000_1_01110<<10                                              ' 02: COP
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_SP                     ' 03: ORA d,s
long rk_bitop+%000_010_0<<10+RK_AMODE_DP                                        ' 04: TSB d
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DP                     ' 05: ORA d
long rk_rmwop+%0_11_000_00_100111_11_0<<10+RK_AMODE_DP                          ' 06: ASL d
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DPI                    ' 07: ORA [d]
long rk_push+%0_111110111_0<<10                                                 ' 08: PHP
long rk_aluop_imm+%00_1_00_00_101_111_0_1111_0<<10                              ' 09: ORA #
long rk_rmwop_accu+%00_000_00_100111_11_1_000<<10                               ' 0A: ASL A
long rk_push+%01_111101111_0<<10                                                ' 0B: PHD
long rk_bitop+%000_010_0<<10+RK_AMODE_ABS                                       ' 0C: TSB a
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_ABS                    ' 0D: ORA a
long rk_rmwop+%0_11_000_00_100111_11_0<<10+RK_AMODE_ABS                         ' 0E: ASL a
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_ABL                    ' 0F: ORA al

long rk_branch+%0_10_0111_100<<10                                               ' 10: BPL
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DPIY                   ' 11: ORA (d),y
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DPI                    ' 12: ORA (d)
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_SPIY                   ' 13: ORA (s),y
long rk_bitop+%000_100_0<<10+RK_AMODE_DP                                        ' 14: TRB d
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DPX                    ' 15: ORA d,x
long rk_rmwop+%0_11_000_00_100111_11_0<<10+RK_AMODE_DPX                         ' 16: ASL d,x
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_DPJY                   ' 17: ORA [d],y
long rk_clc+%010<<10                                                            ' 18: CLC
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_ABSY                   ' 19: ORA a,y
long rk_rmwop_accu+%00_000_11_111111_10_1_000<<10                               ' 1A: INC A
long rk_setsp+%00_100<<10                                                       ' 1B: TCS
long rk_bitop+%000_100_0<<10+RK_AMODE_ABS                                       ' 1C: TRB a
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_ABSX                   ' 1D: ORA a,x
long rk_rmwop+%0_11_000_00_100111_11_0<<10+RK_AMODE_ABSX                        ' 1E: ASL a,x
long rk_aluop+%00_1_00_00_101_111_0_1111_10<<10+RK_AMODE_ABLX                   ' 1F: ORA al,x
                                                                                
long rk_jump+%00_000_11_0_11_00_111011_0<<10                                    ' 20: JSR a
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DPXI                   ' 21: AND (d,x)
long rk_jump+%00_000_00_0_00_00_111011_0<<10                                    ' 22: JSL al
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_SP                     ' 23: AND d,s
long rk_aluop+%00_0_10_11_110_111_0_1000_10<<10+RK_AMODE_DP                     ' 24: BIT d
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DP                     ' 25: AND d
long rk_rmwop+%0_11_000_00_000110_11_0<<10+RK_AMODE_DP                          ' 26: ROL d
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DPJ                    ' 27: AND [d]
long rk_plp                                                                     ' 28: PLP
long rk_aluop_imm+%00_1_00_00_110_111_0_1111_0<<10                              ' 29: AND #
long rk_rmwop_accu+%00_000_00_000110_11_1_000<<10                               ' 2A: ROL A
long rk_pld+%000_000_11_000<<10                                                 ' 2B: PLD
long rk_aluop+%00_0_10_11_110_111_0_1000_10<<10+RK_AMODE_ABS                    ' 2C: BIT a
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_ABS                    ' 2D: AND a
long rk_rmwop+%0_11_000_00_000110_11_0<<10+RK_AMODE_ABS                         ' 2E: ROL a
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_ABL                    ' 2F: AND al

long rk_branch+%0_01_0111_100<<10                                                ' 30: BMI
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DPIY                   ' 31: AND (d),y
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DPI                    ' 32: AND (d)
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_SPIY                   ' 33: AND (d,s),y
long rk_aluop+%00_0_10_11_110_111_0_1000_10<<10+RK_AMODE_DPX                    ' 34: BIT d,x
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DPX                    ' 35: AND d,x
long rk_rmwop+%0_11_000_00_000110_11_0<<10+RK_AMODE_DPX                         ' 36: ROL d,x
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_DPJY                   ' 37: AND [d],y
long rk_sec+%00<<10                                                             ' 38: SEC
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_ABSY                   ' 39: AND a,y
long rk_rmwop_accu+%00_000_11_111111_01_1_000<<10                               ' 3A: DEC A
long rk_tsc+%00_00_11_11_11_0_111_1111_1_1_0<<10                                ' 3B: TSC
long rk_aluop+%00_0_10_11_110_111_0_1000_10<<10+RK_AMODE_ABSX                   ' 3C: BIT a,x
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_ABSX                   ' 3D: AND a,x
long rk_rmwop+%0_11_000_00_000110_11_0<<10+RK_AMODE_ABSX                        ' 3E: ROL a,x
long rk_aluop+%00_1_00_00_110_111_0_1111_10<<10+RK_AMODE_ABLX                   ' 3F: AND al,x

long rk_rti+%0000_0101_0<<10                                                    ' 40: RTI
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DPXI                   ' 41: EOR (d,x)
long rk_branch+%00_1111_100<<10                                                  ' 42: WDM
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_SP                     ' 43: EOR d,s
long rk_blockmove+%0000_0011_0_00000000<<10                                     ' 44: MVP
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DP                     ' 45: EOR d
long rk_rmwop+%0_11_000_00_111101_11_0<<10+RK_AMODE_DP                          ' 46: LSR d
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DPJ                    ' 47: EOR [d]
long rk_push+%0001011_101111111_0<<10                                           ' 48: PHA
long rk_aluop_imm+%00_1_00_00_011_111_0_1111_0<<10                              ' 49: EOR #
long rk_rmwop_accu+%00_000_00_111101_11_1_000<<10                               ' 4A: LSR A
long rk_push+%0_111111101_0<<10                                                 ' 4B: PHK
long rk_jump+%00_111_11_1_11_00_111011_0<<10                                    ' 4C: JMP a
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_ABS                    ' 4D: EOR a
long rk_rmwop+%0_11_000_00_111101_11_0<<10+RK_AMODE_ABS                         ' 4E: LSR a
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_ABL                    ' 4F: EOR al

long rk_branch+%0_10_1011_100<<10                                                ' 50: BVC
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DPIY                   ' 51: EOR (d),y
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DPI                    ' 52: EOR (d)
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_SPIY                   ' 53: EOR (d,s),y
long rk_blockmove+%0000_1100_0_00000000<<10                                     ' 54: MVN
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DPX                    ' 55: EOR d,x
long rk_rmwop+%0_11_000_00_111101_11_0<<10+RK_AMODE_DPX                         ' 56: LSR d,x
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_DPJY                   ' 57: EOR [d],y
long rk_cli_sei+%1110_101_1_0<<10                                               ' 58: CLI
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_ABSY                   ' 59: EOR a,y
long rk_push+%0000111_110111111_0<<10                                           ' 5A: PHY
long rk_tcd+%000_000_00<<10                                                     ' 5B: TCD
long rk_jump+%00_111_00_1_11_10_111111_0<<10                                    ' 5C: JML al
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_ABSX                   ' 5D: EOR a,x
long rk_rmwop+%0_11_000_00_111101_11_0<<10+RK_AMODE_ABSX                        ' 5E: LSR a,x
long rk_aluop+%00_1_00_00_011_111_0_1111_10<<10+RK_AMODE_ABLX                   ' 5F: EOR al,x

long rk_rts+%0111_0000<<10                                                      ' 60: RTS
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DPXI                   ' 61: ADC (d,x)
long rk_pushea+%01_011111110<<10+RK_AMODE_ABS                                   ' 62: PER
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_SP                     ' 63: ADC d,s
long rk_stz+%0_11_0<<10+RK_AMODE_DP                                             ' 64: STZ d
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DP                     ' 65: ADC d
long rk_rmwop+%0_11_000_00_111000_11_0<<10+RK_AMODE_DP                          ' 66: ROR d
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DPJ                    ' 67: ADC [d]
long rk_pull+%0101_0_11_000_11_001100<<10                                       ' 68: PLA
long rk_aluop_imm+%00_1_00_00_111_010_0_1101_0<<10                              ' 69: ADC #
long rk_rmwop_accu+%00_000_00_111000_11_1_000<<10                               ' 6A: ROR A
long rk_rts+%0001_0000<<10                                                      ' 6B: RTL
long rk_jump+%00_111_11_1_11_00_101010_0<<10                                    ' 6C: JMP (a)
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_ABS                    ' 6D: ADC a
long rk_rmwop+%0_11_000_00_111000_11_0<<10+RK_AMODE_ABS                         ' 6E: ROR a
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_ABL                    ' 6F: ADC al

long rk_branch+%0_01_1011_100<<10                                                ' 70: BVS
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DPIY                   ' 71: ADC (d),y
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DPI                    ' 72: ADC (d)
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_SPIY                   ' 73: ADC (d,s),y
long rk_stz+%0_11_0<<10+RK_AMODE_DPX                                            ' 74: STZ d,x
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DPX                    ' 75: ADC d,x
long rk_rmwop+%0_11_000_00_111000_11_0<<10+RK_AMODE_DPX                         ' 76: ROR d,x
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_DPJY                   ' 77: ADC [d],y
long rk_cli_sei+%1110_011_1_0<<10                                               ' 78: SEI
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_ABSY                   ' 79: ADC a,y
long rk_pull+%0011_0_01_111_11_001010<<10                                       ' 7A: PLY
long rk_tdc+%00_00_11_11_11_0_111_1111_1_1_1_0<<10                              ' 7B: TDC
long rk_jump+%00_111_11_0_11_00_100000_0<<10                                    ' 7C: JMP (a,x)
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_ABSX                   ' 7D: ADC a,x
long rk_rmwop+%0_11_000_00_111000_11_0<<10+RK_AMODE_ABSX                        ' 7E: ROR a,x
long rk_aluop+%00_1_00_00_111_010_0_1101_10<<10+RK_AMODE_ABLX                   ' 7F: ADC al,x

long rk_branch+%0_11_1111_100<<10                                                ' 80: BRA
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DPXI                                     ' 81: STA (d,x)
long rk_brl+%0_11_1111_0<<10                                                    ' 82: BRL
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_SP                                       ' 83: STA d,s
long rk_sty+%01_11_1_0<<10+RK_AMODE_DP                                           ' 84: STY d
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DP                                       ' 85: STA d
long rk_stx+%01_11_1_10<<10+RK_AMODE_DP                                          ' 86: STX d
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DPJ                                      ' 87: STA [d]
long rk_dey+%000_01_1111_0<<10                                                  ' 88: DEY
long rk_aluop_imm+%01_1_10_11_110_111_0_1111_0<<10                              ' 89: BIT #
long rk_regtranM+%00_11_00_11_11_0_100<<10                                      ' 8A: TXA
long rk_push+%0_111111011_0<<10                                                 ' 8B: PHB
long rk_sty+%01_11_1_0<<10+RK_AMODE_ABS                                          ' 8C: STY a
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_ABS                                      ' 8D: STA a
long rk_stx+%01_11_1_10<<10+RK_AMODE_ABS                                         ' 8E: STX a
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_ABL                                      ' 8F: STA al

long rk_branch+%0_10_1110_100<<10                                                ' 90: BCC
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DPIY                                     ' 91: STA (d),y
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DPI                                      ' 92: STA (d)
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_SPIY                                     ' 93: STA (d,s),y
long rk_sty+%01_11_1_0<<10+RK_AMODE_DPX                                          ' 94: STY d,x
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DPX                                      ' 95: STA d,x
long rk_stx+%01_11_1_10<<10+RK_AMODE_DPY                                         ' 96: STX d,y
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_DPJY                                     ' 97: STA [d],y
long rk_regtranM+%00_11_00_11_11_0_010<<10                                      ' 98: TYA
long rk_sta+%0_00_1_11_00<<10+RK_AMODE_ABSY                                     ' 99: STA a,y
long rk_setsp+%00_010<<10                                                       ' 9A: TXS
long rk_txy+%00_11_11_00_11_0_111_1111_1_0<<10                                  ' 9B: TXY
long rk_stz+%0_11_0<<10+RK_AMODE_ABS                                            ' 9C: STZ a
long rk_sta+%0_00_1_11_00<<10+RK_AMODE_ABSX                                     ' 9D: STA a,x
long rk_stz+%0_00_0<<10+RK_AMODE_ABSX                                           ' 9E: STZ a,x
long rk_sta+%0_11_1_11_00<<10+RK_AMODE_ABLX                                     ' 9F: STA al,x

long rk_ldxy_imm+%00_1111_001_1111_110<<10                                      ' A0: LDY #
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DPXI                              ' A1: LDA (d,x)
long rk_ldxy_imm+%00_1111_010_1111_110<<10                                      ' A2: LDX #
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_SP                                ' A3: LDA d,s
long rk_ldxy+%00_1111_001_1111_0<<10+RK_AMODE_DP                                ' A4: LDY d
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DP                                ' A5: LDA d
long rk_ldxy+%00_1111_010_1111_0<<10+RK_AMODE_DP                                ' A6: LDX d
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DPJ                               ' A7: LDA [d]
long rk_regtranX+%00_11_11_00_11_0_111_1010<<10                                 ' A8: TAY
long rk_lda_imm+%00_1111_111_0000_1110<<10                                      ' A9: LDA #
long rk_regtranX+%00_11_11_11_00_0_111_1100<<10                                 ' AA: TAX
long rk_pull+%0110_0_11_111_00_110110<<10                                       ' AB: PLB
long rk_ldxy+%00_1111_001_1111_0<<10+RK_AMODE_ABS                               ' AC: LDY a
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_ABS                               ' AD: LDA a
long rk_ldxy+%00_1111_010_1111_0<<10+RK_AMODE_ABS                               ' AE: LDX a
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_ABL                               ' AF: LDA al

long rk_branch+%0_01_1110_100<<10                                                ' B0: BCS
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DPIY                              ' B1: LDA (d),y
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DPI                               ' B2: LDA (d)
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_SPIY                              ' B3: LDA (d,s),y
long rk_ldxy+%00_1111_001_1111_0<<10+RK_AMODE_DPX                               ' B4: LDY d,x
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DPX                               ' B5: LDA d,x
long rk_ldxy+%00_1111_010_1111_0<<10+RK_AMODE_DPY                               ' B6: LDX d,y
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_DPJY                              ' B7: LDA [d],y
long rk_clv+%0110<<10                                                           ' B8: CLV
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_ABSY                              ' B9: LDA a,y
long rk_regtranX+%00_11_11_11_00_0_111_0110<<10                                 ' BA: TSX
long rk_tyx+%00_11_11_11_00_0_111_1111_0<<10                                    ' BB: TYX
long rk_ldxy+%00_1111_001_1111_0<<10+RK_AMODE_ABSX                              ' BC: LDY a,x
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_ABSX                              ' BD: LDA a,x
long rk_ldxy+%00_1111_010_1111_0<<10+RK_AMODE_ABSY                              ' BE: LDX a,y
long rk_lda+%00_1111_111_0000_10<<10+RK_AMODE_ABLX                              ' BF: LDA al,x

long rk_cpy+%001_00_0_0111_0<<10                                                ' C0: CPY #
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DPXI                               ' C1: CMP (d,x)
long rk_rep_sep+%1111_100<<10                                                   ' C2: REP
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_SP                                 ' C3: CMP d,s
long rk_cpy+%001_00_0_1011_0<<10+RK_AMODE_DP                                    ' C4: CPY d
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DP                                 ' C5: CMP d
long rk_rmwop+%0_11_000_11_111111_01_0<<10+RK_AMODE_DP                          ' C6: DEC d
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DPJ                                ' C7: CMP [d]
long rk_iny+%000_01_1111_110<<10                                                ' C8: INY
long rk_cmp+%010_00_0_1101_1100<<10                                             ' C9: CMP #
long rk_dex+%000_10_1111_10<<10                                                 ' CA: DEX
long rk_nop {MEGA TODO}                                                         ' CB: WAI
long rk_cpy+%001_00_0_1011_0<<10+RK_AMODE_ABS                                   ' CC: CPY a
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_ABS                                ' CD: CMP a
long rk_rmwop+%0_11_000_11_111111_01_0<<10+RK_AMODE_ABS                         ' CE: DEC a
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_ABL                                ' CF: CMP al

long rk_branch+%0_10_1101_100<<10                                                ' D0: BNE
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DPIY                               ' D1: CMP (d),y
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DPI                                ' D2: CMP (d)
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_SPIY                               ' D3: CMP (d,s),y
long rk_pushea+%01_111111110<<10+RK_AMODE_DPI                                   ' D4: PEI
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DPX                                ' D5: CMP d,x
long rk_rmwop+%0_11_000_11_111111_01_0<<10+RK_AMODE_DPX                         ' D6: DEC d,x
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_DPJY                               ' D7: CMP [d],y
long rk_cld_sed+%1111_101_0<<10                                                 ' D8: CLD
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_ABSY                               ' D9: CMP a,y
long rk_push+%0000111_111011111_0<<10                                           ' DA: PHX
long rk_nop {MEGA TODO}                                                         ' DB: STP
long rk_jump+%00_111_11_1_11_10_011110_0<<10                                    ' DC: JML [a]
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_ABSX                               ' DD: CMP a,x
long rk_rmwop+%0_11_000_11_111111_01_0<<10+RK_AMODE_ABSX                        ' DE: DEC a,x
long rk_cmp+%010_00_0_1110_1100<<10+RK_AMODE_ABLX                               ' DF: CMP al,x

long rk_cpx+%001_00_0_0111_10<<10                                               ' E0: CPX #
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DPXI                   ' E1: SBC (d,x)
long rk_rep_sep+%1111_010<<10                                                   ' E2: SEP
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_SP                     ' E3: SBC d,s
long rk_cpx+%001_00_0_1011_10<<10+RK_AMODE_DP                                   ' E4: CPX d
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DP                     ' E5: SBC d
long rk_rmwop+%0_11_000_11_111111_10_0<<10+RK_AMODE_DP                          ' E6: INC d
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DPJ                    ' E7: SBC [d]
long rk_inx+%000_10_1111_1110<<10                                               ' E8: INX
long rk_aluop_imm+%00_1_00_00_111_000_0_0111_0<<10                              ' E9: SBC #
long rk_nop                                                                     ' EA: NOP
long rk_xba+%00_0000<<10                                                        ' EB: XBA
long rk_cpx+%001_00_0_1011_10<<10+RK_AMODE_ABS                                  ' EC: CPX a
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_ABS                    ' ED: SBC a
long rk_rmwop+%0_11_000_11_111111_10_0<<10+RK_AMODE_ABS                         ' EE: INC a
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_ABL                    ' EF: SBC al
                                                                                
long rk_branch+%0_01_1101_100<<10                                                ' F0: BEQ
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DPIY                   ' F1: SBC (d),y
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DPI                    ' F2: SBC (d)
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_SPIY                   ' F3: SBC (d,s),y
long rk_pushea+%01_111111110<<10+RK_AMODE_ABS                                   ' F4: PEA
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DPX                    ' F5: SBC d,x
long rk_rmwop+%0_11_000_11_111111_10_0<<10+RK_AMODE_DPX                         ' F6: INC d,x
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_DPJY                   ' F7: SBC [d],y
long rk_cld_sed+%1111_011_0<<10                                                 ' F8: SED
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_ABSY                   ' F9: SBC a,y
long rk_pull+%0011_0_10_111_11_001010<<10                                       ' FA: PLX
long rk_xce+%1111_111_1_1_000000<<10                                              ' FB: XCE
long rk_jump+%00_000_11_0_11_00_100000_0<<10                                    ' FC: JSR (a,x)
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_ABSX                   ' FD: SBC a,x
long rk_rmwop+%0_11_000_11_111111_10_0<<10+RK_AMODE_ABSX                        ' FE: INC a,x
long rk_aluop+%00_1_00_00_111_000_0_0111_10<<10+RK_AMODE_ABLX                   ' FF: SBC al,x


              ' PSRAM helper table. Must be at $300
#ifdef USE_PSRAM16
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF
#elseifdef USE_PSRAM8
              long $00
              long $11
              long $22
              long $33
              long $44
              long $55
              long $66
              long $77
              long $88
              long $99
              long $AA
              long $BB
              long $CC
              long $DD
              long $EE
              long $FF
#else
              long 0[16]
#endif

{
              mov rk_romio_length,#1
              rczr pa wcz
              mov rk_romio_target,rk_romio_area_ptr
        if_c  sub rk_romio_target,#2
        if_z  sub rk_romio_target,#1

#ifdef USE_PSRAM_EITHER
rk_readrom
              zerox pa,rk_romio_zerox ' Limit to ROM size
        '      locktry #ROM_LOCK wc
        'if_nc jmp #$-1
              wrfast  rk_bit31,rk_romio_target
              mov rk_romio_tmp2,pa
              add rk_romio_tmp2,rk_romio_length
              mov rk_romio_tmp1,pa
              bith rk_romio_tmp1,#PSRAM_PAGESIZE
              add rk_romio_tmp1,#1 ' rk_romio_tmp1 has start of next page
              cmpsub rk_romio_tmp2,rk_romio_tmp1 wcz ' IF C, rk_romio_tmp2 now has longs that cross over boundary
        if_c  sub rk_romio_length,rk_romio_tmp2
              call #rk_psram_readburst
   'if_nc_or_z lockrel #ROM_LOCK
   'if_nc_or_z ret wcz
              mov pa,rk_romio_tmp1
              mov rk_romio_length,rk_romio_tmp2
              call #rk_psram_readburst
              'lockrel #ROM_LOCK
              ret wcz
}

rk_write_wram
              cmp rk_memtmp1,#$7F wz
rk_write_wram_low
              mov pa,rk_ea
        if_z  setword pa,#@work_ram>>16+1,#1
        if_nz setword pa,#@work_ram>>16,#1
              add rk_cycles,#8
              wrbyte rk_memv,pa
              cmp pa,##@work_ram+$0522 wz
        if_nz cmp pa,##@work_ram+$0524 wz
        if_nz cmp pa,##@work_ram+$0440 wz
        if_nz ret wcz
              'debug("MAGIC MEMORY WRITE ",uhex_long(rk_ea,rk_pc),uhex_byte(rk_memv),uhex_word(rk_accu,rk_y))
              ret wcz

rk_read_wram
              cmp rk_memtmp1,#$7F wz
rk_read_wram_low
              mov pa,rk_ea
        if_z  setword pa,#@work_ram>>16+1,#1
        if_nz setword pa,#@work_ram>>16,#1
              add rk_cycles,#8
              rdbyte rk_memv,pa
              setbyte rk_openbus,rk_memv,#0
              ret wcz
              

rk_write_romsel
              getbyte rk_memtmp1,rk_ea,#2
              cmp rk_memtmp1,#$7E wz
        if_nz cmp rk_memtmp1,#$7F wz
        if_z  jmp #rk_write_wram

              testb rk_ea,#23 wz
        if_z  add rk_cycles,rk_rom_speed
        if_nz add rk_cycles,#8

              ret wcz

rk_read_romsel
              getbyte rk_memtmp1,rk_ea,#2
              cmp rk_memtmp1,#$7E wz
        if_nz cmp rk_memtmp1,#$7F wz
        if_z  jmp #rk_read_wram

              testb rk_ea,#23 wz
        if_z  add rk_cycles,rk_rom_speed
        if_nz add rk_cycles,#8

              '' TODO: Overlay loader
              '' For now we hardcode LoROM full map
              mov rk_memtmp2,rk_ea
              shl rk_memtmp2,#1
              setword rk_memtmp2,rk_memtmp1,#1
              shr rk_memtmp2,#1
              zerox rk_memtmp2,#19+2 ' TODO: real ROM size here! 19 -> 1 MB

              cmp rk_memtmp2,rk_romcache_end wc
        if_c  cmpsub rk_memtmp2,rk_romcache_start wc
        if_c  jmp #.cached
              'debug("rk_read_romsel ",uhex_long(rk_memtmp2))
              wrfast #0,rk_dcacheloc
              mov pa,rk_memtmp2
              shr pa,#PSRAM_ASHIFT
              neg rk_memtmp1,pa
              zerox rk_memtmp1,#12 wz ' TODO correct value for page size
              mov rk_romio_length,#6 >> PSRAM_ASHIFT ' TODO
        if_nz fle rk_romio_length,rk_memtmp1
              mov rk_romcache_start,pa
              mov rk_romcache_end,rk_romcache_start
              add rk_romcache_end,rk_romio_length
              shl rk_romcache_start,#PSRAM_ASHIFT
              shl rk_romcache_end,#PSRAM_ASHIFT
              call #rk_psram_readburst
              sub rk_memtmp2,rk_romcache_start
.cached
              add rk_memtmp2,rk_dcacheloc
              rdbyte rk_memv,rk_memtmp2
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_psram_test_owie
              wrfast #0,##@romdata_cache
#ifdef USE_PSRAM_EITHER
rk_psram_readburst
              'debug("rk_psram_readburst ",uhex_long(pa,rk_romio_length))
              mov rk_memtmp1,#(8+PSRAM_WAIT)<<PSRAM_CYSHL
              shl rk_romio_length,#1+PSRAM_CYSHL
              add rk_memtmp1,rk_romio_length
{
#ifndef USE_PSRAM16
              shl pa,#PSRAM_ASHIFT ' convert long address to native address (becomes no-op with USE_PSRAM16)
#endif
}
              setbyte pa,#$EB,#3
              ' Reverse nibble order
              splitb  pa
              rev     pa
              movbyts pa, #%%0123
              mergeb  pa
#ifdef USE_PSRAM_SLOW
              drvl  #PSRAM_CLK ' must be 2 ops before xinit
#endif
              drvh  #PSRAM_SELECT
              drvl  rk_psram_pinfield
              xinit rk_psram_addr_cmd,pa
              wypin rk_memtmp1,#PSRAM_CLK
              setq rk_nco_fast
              xcont #PSRAM_WAIT*PSRAM_CLKDIV+PSRAM_DELAY,#0
#ifndef USE_PSRAM_SLOW
              shr rk_romio_length,#PSRAM_CYSHL ' Becomes no-op with USE_PSRAM_SLOW
#endif
              setword rk_psram_read_cmd,rk_romio_length,#0
              waitxmt
              fltl rk_psram_pinfield
              setq rk_nco_slow
              xcont rk_psram_read_cmd,#0
              waitxfi
#ifdef USE_PSRAM_SLOW
              drvl #PSRAM_SELECT
        _ret_ fltl #PSRAM_CLK
#else
        _ret_ drvl #PSRAM_SELECT
#endif
#endif


rk_push
              add rk_cycles,#6 ' pushes have 1 internal cycle (except PEA and PEI)
rk_pushea
              mov rk_memv,rk_ea ' PEA/PEI/PER
              getbyte rk_memv, rk_pc, #2 ' PHK
              getbyte rk_memv, rk_dbank, #2 ' PHB
              mov rk_memv, rk_flags ' PHP
              mov rk_memv, rk_dp ' PHD
              mov rk_memv, rk_x ' PHX
              mov rk_memv, rk_y ' PHY
              mov rk_memv, rk_accu ' PHA
              add rk_memv,rk_pc ' PER
              ' note: 16 bit push doesn't need masked memv, 8 bit may
              jmp #\rk_push8 ' PHK/PHB/PHP
              jmp #\rk_push16 ' PEA/PEI/PER/PHD
              testb rk_flags,#RK_MW_BIT wc ' PHA
              testb rk_flags,#RK_XW_BIT wc ' PHX/PHY
        if_nc jmp #\rk_push16 ' PHA/PHY/PHX
              and rk_memv,#255
              jmp #\rk_push8 ' PHA/PHY/PHX

rk_tdc
              mov rk_accu,rk_dp
rk_tsc
              mov rk_accu,rk_sp
rk_txy
              mov rk_y,rk_x
rk_tyx
              mov rk_x,rk_y
rk_regtranX
              setq rk_maskX     
              muxq rk_x,rk_accu ' TAX
              muxq rk_y,rk_accu ' TAY
              muxq rk_x,rk_sp   ' TSX
rk_regtranM
              setq rk_maskM     ' T*A
              muxq rk_accu,rk_x ' TXA
              muxq rk_accu,rk_y ' TYA

              add rk_cycles,#6 ' all of these have an internal cycle

              test rk_x,rk_maskX wz ' T*X
              testb rk_x,rk_msbX wc ' T*X

              test rk_y,rk_maskX wz ' T*Y
              testb rk_y,rk_msbX wc ' T*Y

              test rk_accu,rk_maskM wz ' T*A
              testb rk_accu,rk_msbM wc ' T*A

              test rk_accu,rk_ffff wz ' T*C
              testb rk_accu,#15 wc ' T*C

              bitz rk_flags,#RK_ZERO_BIT
        _ret_ bitc rk_flags,#RK_NEG_BIT

rk_setsp      ' TCS/TXS
              add rk_cycles,#6 ' internal cycle
              mov rk_sp, rk_accu
              mov rk_sp, rk_x
              ' transfer into S never sets flags
        _ret_ tjnz rk_emumode,#$+1
        _ret_ setbyte rk_sp,#1,#1

rk_jump
              call #\rk_readcode16
              ' note: JSR (a,x) has a cursed bus pattern, but let's just ignore that
              mov rk_ea,rk_memv
              add rk_ea,rk_x ' indirect indexed
              getbyte rk_optmp2,rk_pc,#2 ' JSR/JMP
              setbyte rk_ea,rk_optmp2,#2 ' indirect indexed reads from program bank, normal indirect reads from bank 0 (?????)
              call #\rk_read16 ' indirect 16 bit
              call #\rk_read24 ' indirect 24 bit
              
              mov rk_optmp1,rk_memv 
              setbyte rk_optmp1,rk_optmp2,#2 ' JMP/JSR

              getbyte rk_memv,rk_pc,#2 ' JSL
              call #\rk_push8 ' JSL

              add rk_cycles,#6 ' internal cycle for JSR/JSL/JMP(a,x) - isn't in right place for latter

              call rk_readcode_f ' JML/JSL
              setbyte rk_optmp1,rk_memv,#2 ' JML/JSL

              mov rk_memv,rk_pc
              sub rk_memv,#1
              call #\rk_push16 ' JSR/JSL

              mov rk_pc,rk_optmp1
              jmp #\rk_dojump

rk_blockmove
              call #\rk_readcode16
              setbyte rk_dbank,rk_memv,#2
              getbyte rk_ea,rk_memv,#1
              rolword rk_ea,rk_x,#0
              call #\rk_read8
              mov rk_ea,rk_y
              add rk_ea,rk_dbank
              call #\rk_write8

              add rk_cycles,#12 ' 2 internal cycles

rk_inx        incmod rk_x,rk_maskX wz
rk_iny        incmod rk_y,rk_maskX wz
rk_dex        decmod rk_x,rk_maskX wz
rk_dey        decmod rk_y,rk_maskX wz

              decmod rk_accu,rk_ffff wc
        if_c  ret
              neg rk_memv,#3
              jmp #\rk_dobranch

              testb rk_x,rk_msbX wc
              testb rk_y,rk_msbX wc

              add rk_cycles,#6 ' 1 internal cylce
              bitz rk_flags,#RK_ZERO_BIT
        _ret_ bitc rk_flags,#RK_NEG_BIT


rk_clv        bitl rk_flags,#RK_OVER_BIT
rk_clc        bitl rk_flags,#RK_CARRY_BIT
rk_sec        bith rk_flags,#RK_CARRY_BIT
rk_nop  _ret_ add rk_cycles,#6 ' internal cycle


rk_xce
              testb rk_flags,#RK_CARRY_BIT wc
              cmp rk_emumode,#0 wz
              mov rk_emumode,#0
        if_c  setbyte rk_emumode,#$FF,#1
        if_c  setbyte rk_sp,#1,#1
              bitnz rk_flags,#RK_CARRY_BIT
rk_cli_sei
              decod rk_memv,#RK_IRQ_BIT          
rk_cld_sed
              decod rk_memv,#RK_DEC_BIT
rk_rep_sep
              call rk_readcode_f
              andn rk_flags,rk_memv
              or rk_flags,rk_memv
rk_plp ' can also jump here without a SKIP pattern!
              add rk_cycles,#6 ' 1st internal cycle
              add rk_cycles,#6 ' 2nd internal cycle
              call #\rk_pull8
              mov rk_flags, rk_memv
rk_flagsloaded '... or here!
              ' todo: handle I flag
              cmp rk_emumode,#0 wz
        if_nz or rk_flags,#(1<<RK_MW_BIT)|(1<<RK_XW_BIT)
              testb rk_flags, #RK_DEC_BIT wz
              testb rk_flags, #RK_MW_BIT wc
        if_c  call #.m8
        if_nc call #.m16
              bmask rk_maskM,rk_msbM
              testb rk_flags, #RK_XW_BIT wc
        if_c  call #.x8
        if_nc call #.x16
        _ret_ bmask rk_maskX,rk_msbX

.m8
        if_z  mov rk_addsub_f,#rk_addsub_dec8
        if_nz mov rk_addsub_f,#rk_addsub_bin8
              mov rk_writeM_f, #rk_write8
              mov rk_rmwriteM_f, #rk_write8
              mov rk_readM_f, #rk_read8
              mov rk_readcodeM_f, #rk_readcode8
        _ret_ mov rk_msbM, #7
.m16
        if_z  mov rk_addsub_f,#rk_addsub_dec16
        if_nz mov rk_addsub_f,#rk_addsub_bin16
              mov rk_writeM_f, #rk_write16
              mov rk_rmwriteM_f, #rk_rmwrite16
              mov rk_readM_f, #rk_read16
              mov rk_readcodeM_f, #rk_readcode16
        _ret_ mov rk_msbM, #15
.x8
              and rk_x, #255 ' truncate current X
              and rk_y, #255 ' truncate current Y
              mov rk_writeX_f, #rk_write8
              mov rk_readX_f, #rk_read8
              mov rk_readcodeX_f, #rk_readcode8
              mov rk_xy_penalty,#0
        _ret_ mov rk_msbX, #7
.x16
              mov rk_writeX_f, #rk_write16
              mov rk_readX_f, #rk_read16
              mov rk_readcodeX_f, #rk_readcode16
              mov rk_xy_penalty,#6
        _ret_ mov rk_msbX, #15


rk_dmagadget
              call #rk_read8
              'debug(uhex_long(rk_ea),uhex_byte(rk_memv),uhex_word(rk_optmp2))
              add rk_ea,rk_dmainc
        _ret_ setword rk_optmp1,rk_ea,#0
              


              fit 1024

DAT ' RiKore 65816+DMA hub code
              orgh


rk_hub_mdma_start
              tjs rk_mdmaen,#.continue      
              add rk_cycles,#8 ' startup overhead
.chloop
              add rk_cycles,#8 ' channel overhead
              getbyte rk_dmach,rk_mdmaen,#0
              rev rk_dmach
              encod rk_dmach
              subr rk_dmach,#31
              mov pa,rk_dmach
              mul pa,#12
              add pa,#@rk_dmaregs
              setq #2
              rdlong rk_optmp1,pa ' read all DMA registers

              debug("MDMA start ",udec(rk_dmach),uhex_long(rk_optmp1,rk_optmp2,rk_optmp3))

              testb rk_optmp3,#3 wz
              testb rk_optmp3,#4 wc
              wrnz rk_dmainc
              negc rk_dmainc

              mov rk_dma_suboff,#0
.continue
              testb rk_optmp3,#7 wc ' read/write

        if_nc mov pa,#bbus_write_tbl>>9
        if_c  mov pa,#bbus_read_tbl>>9
              rolbyte pa,rk_optmp3,#1
              shl pa,#1
              setq #1
              rdlong rk_dma_bbptr,pa

              testb rk_optmp3,#0 wc
              testb rk_optmp3,#1 wz
        if_nz test rk_optmp3,#%111 wz
        if_11 getword rk_dma_bbptr+1,rk_dma_bbptr+0,#1
        if_x1 movbyts rk_dma_bbptr+0,#%%1010
        if_x1 movbyts rk_dma_bbptr+1,#%%1010
    if_c_ne_z mov rk_dma_bbptr+1,rk_dma_bbptr+0

              debug("MDMA B-bus pointers ",uhex_reg_array(#rk_dma_bbptr,#2))

              testb rk_optmp3,#7 wc ' read/write
              getword pa,rk_optmp2,#0
        if_c  jmp #.rdloop

              jmp #.wrstart

.wrloop
              add rk_ea,rk_dmainc
              setword rk_optmp1,rk_ea,#0

              add rk_cycles,#2
              andn rk_cycles,#7

              getword pa,rk_optmp2,#0
              getct pb
              subr rk_time,pb
              debug("DMA byte ",udec(rk_time))
              djz pa,#.wrstop

.wrstart
              getct rk_time
              setword rk_optmp2,pa,#0

              add rk_elapsed,rk_cycles
              sub rk_until_eol,rk_cycles
              sub rk_until_irq,rk_cycles
              mov rk_cycles,#0
              wrlong rk_elapsed,#elapsed_cycles
              tjs rk_until_eol,#.eol

              getbyte rk_ea,rk_optmp3,#3
              rolword rk_ea,rk_optmp1,#0

              push ##.wrloop
              altgw rk_dma_suboff,#rk_dma_bbptr
              getword pa
              incmod rk_dma_suboff,#3
              push pa
              jmp #rk_read8

.wrstop
              setword rk_optmp2,pa,#0

              mov pa,rk_dmach
              mul pa,#12
              add pa,#@rk_dmaregs
              setq #2
              wrlong rk_optmp1,rk_dmach
              bitl rk_mdmaen,rk_dmach
              bitl rk_mdmaen,#31
              tjnz rk_mdmaen,#.chloop
              jmp #rk_nextop

.rdloop
              setword rk_optmp2,pa,#0

              add rk_elapsed,rk_cycles
              wrlong rk_elapsed,#elapsed_cycles
              sub rk_until_eol,rk_cycles
              mov rk_cycles,#0
              tjs rk_until_eol,#.eol

              altgw rk_dma_suboff,#rk_dma_bbptr
              getword pa
              incmod rk_dma_suboff,#3
              call pa

              getbyte rk_ea,rk_optmp3,#3
              rolword rk_ea,rk_optmp1,#0
              call #rk_write8
              add rk_ea,rk_dmainc
              setword rk_optmp1,rk_ea,#0

              add rk_cycles,#2
              andn rk_cycles,#7

              getword pa,rk_optmp2,#0
              djnz pa,#.wrloop

              setword rk_optmp2,pa,#0

              mov pa,rk_dmach
              mul pa,#12
              add pa,#@rk_dmaregs
              setq #2
              wrlong rk_optmp1,rk_dmach
              bitl rk_mdmaen,rk_dmach
              bitl rk_mdmaen,#31
              tjnz rk_mdmaen,#.chloop
              jmp #rk_nextop

.eol
              bith rk_mdmaen,#31 ' in-progress flag
              'mov pa,rk_dmach
              'mul pa,#12
              'add pa,#@rk_dmaregs
              'setq #2
              'wrlong rk_optmp1,rk_dmach
              jmp #rk_eol




rk_read_joyshift
              '' TODO
              add rk_cycles,#6 ' on top of the first 6 - extra slow
              getbyte rk_memv,rk_openbus,#0
              ret wcz

rk_write_joyshift
              '' TODO
              add rk_cycles,#6 ' on top of the first 6 - extra slow
              ret wcz

rk_read_joy1l
              '' MEGA TODO
              rdlong rk_memv,#emupad_data+4*0
              getnib pa,rk_memv,#7
              cmp pa,#0 wz
        if_z  mov rk_memv,#0
              'testb rk_memv,#32-4 wc
        'if_nc neg rk_memv,#1
              rev rk_memv
              getbyte rk_memv,rk_memv,#2
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_read_joy1h
              '' MEGA TODO
              rdlong rk_memv,#emupad_data+4*0
              getnib pa,rk_memv,#7
              cmp pa,#0 wz
        if_z  mov rk_memv,#0
              'testb rk_memv,#32-4 wc
        'if_nc neg rk_memv,#1
              rev rk_memv
              getbyte rk_memv,rk_memv,#3
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_read_joy3l
              '' MEGA TODO
              rdlong rk_memv,#emupad_data+4*1
              getnib pa,rk_memv,#7
              cmp pa,#0 wz
        if_z  mov rk_memv,#0
              'testb rk_memv,#32-4 wc
        'if_nc neg rk_memv,#1
              rev rk_memv
              getbyte rk_memv,rk_memv,#2
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_read_joy3h
              '' MEGA TODO
              rdlong rk_memv,#emupad_data+4*1
              getnib pa,rk_memv,#7
              cmp pa,#0 wz
        if_z  mov rk_memv,#0
              'testb rk_memv,#32-4 wc
        'if_nc neg rk_memv,#1
              rev rk_memv
              getbyte rk_memv,rk_memv,#3
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_read_joy2l
rk_read_joy2h
rk_read_joy4l
rk_read_joy4h
              mov rk_memv,#0
              setbyte rk_openbus,rk_memv,#0
              ret wcz


rk_read_dma
              getnib pa,rk_ea,#0
              mov rk_memtmp1,##$654B_1098
              mov rk_memtmp2,##$AFFF_A732
              altgn pa,#rk_memtmp1
              getnib rk_memtmp1
              getnib pa,rk_ea,#1

              getbyte rk_memv,rk_openbus,#0
              cmp rk_memtmp1,#12 wc
        if_c  cmp pa,#8 wc
              mul pa,#12
              add pa,#@rk_dmaregs
              add pa,rk_memtmp1
        if_c  rdbyte rk_memv, pa
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_write_dma
              'debug("DMA register write ",uhex_byte(rk_memv),uhex_long(rk_pc,rk_ea))
              getnib pa,rk_ea,#0
              mov rk_memtmp1,##$654B_1098
              mov rk_memtmp2,##$AFFF_A732
              altgn pa,#rk_memtmp1
              getnib rk_memtmp1
              getnib pa,rk_ea,#1

              cmp rk_memtmp1,#12 wc
        if_c  cmp pa,#8 wc
              mul pa,#12
              add pa,#@rk_dmaregs
              add pa,rk_memtmp1
        if_c  wrbyte rk_memv, pa
              ret wcz

rk_write_nmitimen
              'debug("NMITIMEN write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              '' MEGA TODO
              'testb rk_memv,#7 wc
              'bitc rk_nmi_flag,#1
              setbyte rk_interrupt_flags,rk_memv,#0
              ret wcz

rk_read_rdnmi
              bitl rk_interrupt_flags,#8 wcz
              bitc rk_openbus,#7
              setnib rk_openbus,#1,#0 '' TODO: What is the real CPU version???
              getbyte rk_memv,rk_openbus,#0
              'debug("RDNMI read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz

rk_read_timeup
              bitl rk_interrupt_flags,#16 wcz
              bitc rk_openbus,#7
              getbyte rk_memv,rk_openbus,#0
              'debug("TIMEUP read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz

rk_read_hvbjoy
              bitl rk_openbus,#0 ' TODO: joypad read flag
              cmp rk_until_eol,#300 wc ' TODO: confirm real hblank timing
              bitc rk_openbus,#6
              cmp rk_curline,#$F0 wc ' TODO: use actual vblank flag
              bitnc rk_openbus,#7
              getbyte rk_memv,rk_openbus,#0
              'debug("HVBJOY read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz

rk_write_memsel
              'debug("MEMSEL write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              testb rk_memv,#0 wc
        if_nc mov rk_rom_speed,#8
        if_c  mov rk_rom_speed,#6
              ret wcz
              

rk_write_mdmaen
              'debug("MDMAEN write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              or rk_mdmaen,rk_memv
              ret wcz

rk_write_wrmpya
              'debug("WRMPYA write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              setbyte rk_muldiv_args,rk_memv,#2
              ret wcz

rk_write_wrmpyb
              'debug("WRMPYB write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getbyte rk_memtmp1,rk_muldiv_args,#2
              mul rk_memtmp1,rk_memv
              setword rk_muldiv_result,rk_memtmp1,#1
              setword rk_muldiv_result,rk_memv,#0 ' corrupt div result
              ret wcz

rk_write_wrdivl
              'debug("WRDIVL write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              setbyte rk_muldiv_args,rk_memv,#0
              ret wcz

rk_write_wrdivh
              'debug("WRDIVH write",uhex_byte(rk_memv),uhex_long(rk_pc))
              setbyte rk_muldiv_args,rk_memv,#1
              ret wcz

rk_write_wrdivb
              'debug("WRDIVB write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword rk_memtmp1,rk_muldiv_args,#0
              ' P2 QDIV already has the correct x/0 behaviour, no test needed
              qdiv rk_memtmp1, rk_memv
              getqx rk_muldiv_result ' result
              getqy rk_memtmp1       ' remainder
              setword rk_muldiv_result,rk_memtmp1,#1
              ret wcz
              
           
rk_read_rddivl
              getbyte rk_memv,rk_muldiv_result,#0
              setbyte rk_openbus,rk_memv,#0
              ret wcz
rk_read_rddivh
              getbyte rk_memv,rk_muldiv_result,#1
              setbyte rk_openbus,rk_memv,#0
              ret wcz
rk_read_rdmpyl
              getbyte rk_memv,rk_muldiv_result,#2
              setbyte rk_openbus,rk_memv,#0
              ret wcz
rk_read_rdmpyh
              getbyte rk_memv,rk_muldiv_result,#3
              setbyte rk_openbus,rk_memv,#0
              ret wcz

rk_write_htimel
              'debug("HTIMEL write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              shl rk_memv,#2
              setq ##$FF<<2
              muxq rk_htime,rk_memv
              ret wcz
rk_write_htimeh
              'debug("HTIMEH write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              testb rk_memv,#0 wc
              bitc rk_htime,#8+2
              ret wcz
rk_write_vtimel
              'debug("VTIMEL write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              setbyte rk_vtime,rk_memv,#0
              ret wcz
rk_write_vtimeh
              'debug("VTIMEH write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              testb rk_memv,#0 wc
              bitc rk_vtime,#8
              ret wcz



              orgh
rk_hub_init
              setq #495
              rdlong 0,##@rk_cogcode
              setq2 #511
              rdlong 0,##@rk_lutcode

'.lol          debug(sdec_long_array_(#video_line_ctr,#1))
'              jmp #.lol

              ' PSRAM INIT
#ifdef USE_PSRAM_EITHER
              fltl #PSRAM_CLK
#ifdef USE_PSRAM_SLOW
              wrpin ##P_PULSE|P_OE|(PSRAM_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #PSRAM_CLK
              wxpin ##3 + (2<<16), #PSRAM_CLK
#else
              wrpin ##P_TRANSITION|P_OE|(PSRAM_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #PSRAM_CLK
              wxpin #1, #PSRAM_CLK
              drvl #PSRAM_CLK
#endif

              wrpin ##P_INVERT_OUTPUT,#PSRAM_SELECT
              drvl #PSRAM_SELECT

              wrpin ##(PSRAM_SYNC_DATA ? P_SYNC_IO : P_ASYNC_IO),rk_psram_pinfield

              setxfrq rk_nco_slow
              waitx #200
#endif
#ifdef USE_HYPER
              fltl #HYPER_CLK
              wrpin ##P_TRANSITION|P_OE|(HYPER_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #HYPER_CLK
              wxpin #2, #HYPER_CLK

              wrpin ##P_INVERT_OUTPUT,#HYPER_SELECT
              drvl #HYPER_SELECT

              wrpin ##(HYPER_SYNC_DATA ? P_SYNC_IO : P_ASYNC_IO),#HYPER_BASE addpins 7

              modc HYPER_RESET < 0 ? _clr : _set wc
        if_c  drvh #HYPER_RESET&511

              setxfrq rk_nco_slow
              waitx #200
#endif
              {
              'wrfast #0,##@romdata_cache
              mov rk_romio_length,#32>>PSRAM_ASHIFT
              mov pa,##$7FC0>>PSRAM_ASHIFT
              call #rk_psram_test_owie
              debug("scuffalicious",lstr(#@romdata_cache,#21))

              setq #7
              wrlong #0,##@romdata_cache

              mov rk_ea,##$00FFC0
              mov rk_optmp1,#22
              mov rk_optmp2,##@vram
.loop
              call #rk_read8
              debug(udec(rk_memv,rk_optmp1), uhex_long(rk_ea,rk_romcache_start,rk_romcache_end))
              add rk_ea,#1
              wrword rk_memv,rk_optmp2
              add rk_optmp2,#2
              djnz rk_optmp1,#.loop

              jmp #$
              }

              ' Set up timing
              neg rk_until_eol,#1 ' I think this is the correct init value?
              mov rk_cycles,#0
              mov rk_curline,#0
              rdlong rk_elapsed,#elapsed_cycles

              mov rk_memv,#0
              call #ppu_write_vmain

              rdword pa,#video_line_ctr wz
        if_nz jmp #$-4

              ' set up registers for powerup/reset
              debug("65816 RESET")
              mov rk_emumode,##$FF00
              and rk_accu,rk_ffff
              and rk_flags,#255
              mov rk_dbank,#0
              mov rk_dp,#0
              mov rk_sp,#$100
              push #rk_nextop
              mov rk_optmp1,#$FC

              mov rk_rom_speed,#8
              mov rk_mdmaen,#0
              mov rk_interrupt_flags,#0
              mov rk_htime,##511<<2
              mov rk_vtime,#511

              jmp #\rk_doirq
            

              'call #\rk_flagsloaded
              'mov rk_pc,##$400
              'jmp #\rk_dojump


              jmp #$

rk_validate
              loc ptra,#@rk_cogcode
              mov pa,#0
              mov pb,#rk_varstart
.loop
              rdlong rk_memtmp1,ptra++
              alti pa,#%000_000_111
              cmp rk_memtmp1,pa wz
        if_z  djnz pb,#.loop
        if_z  ret wcz
              sub pa,#1
              sub ptra,#4
              debug("INTEGRITY VIOLATION ",uhex_long(ptra, pa,rk_memtmp1),uhex_reg_array(pa,#1),udec(pb))
              jmp #$


DAT ' APU register handlers
              orgh
apu_readio0
              rdbyte rk_memv,##apu_outport+0
              setbyte rk_openbus,rk_memv,#0
              'debug("APUIO0 read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz
apu_readio1
              rdbyte rk_memv,##apu_outport+1
              setbyte rk_openbus,rk_memv,#0
              'debug("APUIO1 read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz
apu_readio2
              rdbyte rk_memv,##apu_outport+2
              setbyte rk_openbus,rk_memv,#0
              'debug("APUIO2 read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz
apu_readio3
              rdbyte rk_memv,##apu_outport+3
              setbyte rk_openbus,rk_memv,#0
              'debug("APUIO3 read ",uhex_byte(rk_memv),uhex_long(rk_pc))
              ret wcz

apu_writeio0
              'debug("APUIO0 write ",uhex_byte(rk_memv),uhex_long(rk_pc))
        '      rdbyte pa,##fakeapuhack+1 wz  
        'if_nz cmp rk_memv,#$CC wz
        'if_z  wrword rk_memv,##fakeapuhack
              wrbyte rk_memv,##apu_inport+0
              ret wcz
apu_writeio1
              'debug("APUIO1 write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,##apu_inport+1
              ret wcz
apu_writeio2
              'debug("APUIO2 write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,##apu_inport+2
              ret wcz
apu_writeio3
              'debug("APUIO3 write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,##apu_inport+3
              ret wcz


DAT ' PPU register handlers
              orgh

ppu_write_inidisp
              'debug("INIDISP write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,#ppu_inidisp
              ret wcz

ppu_write_objsel
              wrbyte rk_memv,#ppu_objsel
              ret wcz





ppu_write_oamaddl
              shr rk_ppu_oamadd_oamlatch,#1
              setbyte rk_ppu_oamadd_oamlatch,rk_memv,#0
              shl rk_ppu_oamadd_oamlatch,#1
              wrword rk_ppu_oamadd_oamlatch,#ppu_oamadd
              ret wcz
ppu_write_oamaddh              
              testb rk_memv,#0 wc
              bitc rk_ppu_oamadd_oamlatch,#9
              bitl rk_ppu_oamadd_oamlatch,#0 ' clear low bit???
              rdlong rk_memtmp1,#ppu_oamadd
              setword rk_memtmp1,rk_ppu_oamadd_oamlatch,#0
              testb rk_memv,#7 wc
              bitc rk_memtmp1,#23
              wrlong rk_memtmp1,#ppu_oamadd
              ret wcz

ppu_write_oamdata
              testb rk_ppu_oamadd_oamlatch,#0 wc
      if_nc   setbyte rk_ppu_oamadd_oamlatch,rk_memv,#2
              testb rk_ppu_oamadd_oamlatch,#9 wz
              getword ptra,rk_ppu_oamadd_oamlatch,#0
              
              add rk_ppu_oamadd_oamlatch,#1
              bitl rk_ppu_oamadd_oamlatch,#10 addbits 5
              
              wrword rk_ppu_oamadd_oamlatch,#ppu_oamadd
      if_z    jmp #.hi
      if_nc   ret wcz
              rolbyte rk_memv,rk_ppu_oamadd_oamlatch,#2
              shr ptra,#2 wc
              mul ptra,#6
      if_nc   add ptra,#2
              wrword rk_memv,ptra[##@oam + 2]
              ret wcz

.hi
              and ptra,#31
              mul ptra,#6*4
              add ptra,##@oam

              rczr rk_memv wcz
              wrz rk_memtmp1
              bitc rk_memtmp1,#1
              wrword rk_memtmp1,ptra[0]

              rczr rk_memv wcz
              wrz rk_memtmp1
              bitc rk_memtmp1,#1
              wrword rk_memtmp1,ptra[3]

              rczr rk_memv wcz
              wrz rk_memtmp1
              bitc rk_memtmp1,#1
              wrword rk_memtmp1,ptra[6]

              rczr rk_memv wcz
              wrz rk_memtmp1
              bitc rk_memtmp1,#1
              wrword rk_memtmp1,ptra[9]

              ret wcz


ppu_write_vmain
              setbyte rk_ppu_vmain_vmadd,rk_memv,#0
              testb rk_ppu_vmain_vmadd,#0 wz
              testb rk_ppu_vmain_vmadd,#1 wc
        if_00 setbyte rk_ppu_vmain_vmadd,#1,#1
        if_01 setbyte rk_ppu_vmain_vmadd,#32,#1
        if_1x setbyte rk_ppu_vmain_vmadd,#128,#1
              ' Select optimized write routine
              testb rk_ppu_vmain_vmadd,#3 wc
              testb rk_ppu_vmain_vmadd,#2 wz
        if_00 mov pa,##ppu_write_vmdatal_remap0 + ppu_write_vmdatah_remap0<<16
        if_01 mov pa,##ppu_write_vmdatal_remap1 + ppu_write_vmdatah_remap1<<16
        if_10 mov pa,##ppu_write_vmdatal_remap2 + ppu_write_vmdatah_remap2<<16
        if_11 mov pa,##ppu_write_vmdatal_remap3 + ppu_write_vmdatah_remap3<<16
              wrlong pa,##bbus_write_tbl+2*$18

              ret wcz


              {
              testb rk_ppu_vmain_vmadd,#3 wc
              testb rk_ppu_vmain_vmadd,#2 wz
              mov rk_memtmp2,rk_memtmp1
    if_not_00 shl rk_memtmp2,#3
              mov rk_memtmp3,rk_memtmp1
        if_01 shr rk_memtmp3,#5
        if_10 shr rk_memtmp3,#6
        if_11 shr rk_memtmp3,#7
        if_01 setq #$FF
        if_10 setq #$1FF
        if_11 setq rk_3ff
    if_not_00 muxq rk_memtmp1,rk_memtmp2
              setq #$07
              muxq rk_memtmp1,rk_memtmp3
              }


ppu_write_vmaddl
              'debug("VMADDL write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              'wrbyte rk_memv,#ppu_vram_addr+0
              'rdword rk_memtmp1,#ppu_vram_addr
              setbyte rk_ppu_vmain_vmadd,rk_memv,#2
              getword rk_memtmp1,rk_ppu_vmain_vmadd,#1

              ' VRAM remap
              testb rk_ppu_vmain_vmadd,#3 wc
              testb rk_ppu_vmain_vmadd,#2 wz
              mov rk_memtmp2,rk_memtmp1
    if_not_00 shl rk_memtmp2,#3
              mov rk_memtmp3,rk_memtmp1
        if_01 shr rk_memtmp3,#5
        if_10 shr rk_memtmp3,#6
        if_11 shr rk_memtmp3,#7
        if_01 setq #$FF
        if_10 setq #$1FF
        if_11 setq rk_3ff
    if_not_00 muxq rk_memtmp1,rk_memtmp2
              setq #$07
              muxq rk_memtmp1,rk_memtmp3
              shl rk_memtmp1,#1
              setword rk_memtmp1,#@vram>>16,#1

              rdword rk_memtmp1,rk_memtmp1
              wrword rk_memtmp1,#ppu_vram_latch
              ret wcz

ppu_write_vmaddh
              'debug("VMADDH write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              'wrbyte rk_memv,#ppu_vram_addr+1
              'rdword rk_memtmp1,#ppu_vram_addr
              setbyte rk_ppu_vmain_vmadd,rk_memv,#3
              getword rk_memtmp1,rk_ppu_vmain_vmadd,#1

              ' VRAM remap
              testb rk_ppu_vmain_vmadd,#3 wc
              testb rk_ppu_vmain_vmadd,#2 wz
              mov rk_memtmp2,rk_memtmp1
    if_not_00 shl rk_memtmp2,#3
              mov rk_memtmp3,rk_memtmp1
        if_01 shr rk_memtmp3,#5
        if_10 shr rk_memtmp3,#6
        if_11 shr rk_memtmp3,#7
        if_01 setq #$FF
        if_10 setq #$1FF
        if_11 setq rk_3ff
    if_not_00 muxq rk_memtmp1,rk_memtmp2
              setq #$07
              muxq rk_memtmp1,rk_memtmp3
              shl rk_memtmp1,#1
              setword rk_memtmp1,#@vram>>16,#1

              rdword rk_memtmp1,rk_memtmp1
              wrword rk_memtmp1,#ppu_vram_latch
              ret wcz

ppu_write_vmdatal_remap0
              'debug("VMDATAL write (no remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa

              testb rk_ppu_vmain_vmadd,#7 wc
        if_nc setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              waitx #14 ' timing compensation
              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[0]
              ret wcz
ppu_write_vmdatah_remap0
              'debug("VMDATAH write (no remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa
              testb rk_ppu_vmain_vmadd,#7 wc
        if_c  setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              waitx #14 ' timing compensation
              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[1]
              ret wcz

ppu_write_vmdatal_remap1
              'debug("VMDATAL write (2bpp remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa

              testb rk_ppu_vmain_vmadd,#7 wc
        if_nc setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              mov rk_memtmp2,ptra
              shl rk_memtmp2,#3
              mov rk_memtmp3,ptra
              shr rk_memtmp3,#5
              setq #$FF
              muxq ptra,rk_memtmp2
              setq #$07
              muxq ptra,rk_memtmp3

              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[0]
              ret wcz
ppu_write_vmdatah_remap1
              'debug("VMDATAH write (2bpp remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa
              testb rk_ppu_vmain_vmadd,#7 wc
        if_c  setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              mov rk_memtmp2,ptra
              shl rk_memtmp2,#3
              mov rk_memtmp3,ptra
              shr rk_memtmp3,#5
              setq #$FF
              muxq ptra,rk_memtmp2
              setq #$07
              muxq ptra,rk_memtmp3

              

              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[1]
              ret wcz


ppu_write_vmdatal_remap2
              'debug("VMDATAL write (4bpp remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa

              testb rk_ppu_vmain_vmadd,#7 wc
        if_nc setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              mov rk_memtmp2,ptra
              shl rk_memtmp2,#3
              mov rk_memtmp3,ptra
              shr rk_memtmp3,#6
              setq #$1FF
              muxq ptra,rk_memtmp2
              setq #$07
              muxq ptra,rk_memtmp3

              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[0]
              ret wcz
ppu_write_vmdatah_remap2
              'debug("VMDATAH write (4bpp remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa
              testb rk_ppu_vmain_vmadd,#7 wc
        if_c  setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              mov rk_memtmp2,ptra
              shl rk_memtmp2,#3
              mov rk_memtmp3,ptra
              shr rk_memtmp3,#6
              setq #$1FF
              muxq ptra,rk_memtmp2
              setq #$07
              muxq ptra,rk_memtmp3



              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[1]
              ret wcz


ppu_write_vmdatal_remap3
              'debug("VMDATAL write (8bpp remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa

              testb rk_ppu_vmain_vmadd,#7 wc
        if_nc setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              mov rk_memtmp2,ptra
              shl rk_memtmp2,#3
              mov rk_memtmp3,ptra
              shr rk_memtmp3,#7
              setq rk_3ff
              muxq ptra,rk_memtmp2
              setq #$07
              muxq ptra,rk_memtmp3

              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[0]
              ret wcz
ppu_write_vmdatah_remap3
              'debug("VMDATAH write (8bpp remap) ",uhex_byte(rk_memv),uhex_long(rk_pc))
              getword ptra,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,ptra
              ' VRAM increment (after write)
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa
              testb rk_ppu_vmain_vmadd,#7 wc
        if_c  setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              mov rk_memtmp2,ptra
              shl rk_memtmp2,#3
              mov rk_memtmp3,ptra
              shr rk_memtmp3,#7
              setq rk_3ff
              muxq ptra,rk_memtmp2
              setq #$07
              muxq ptra,rk_memtmp3

              shl ptra,#1
              setword ptra,#@vram>>16,#1

              'debug("VRAM byte write @",uhex_long_(ptra))
              wrbyte rk_memv,ptra[1]
              ret wcz


ppu_read_vmdatal
              rdbyte rk_memv,#ppu_vram_latch+0
              ' set both PPU1 and general openbus
              setbyte rk_openbus,rk_memv,#1
              setbyte rk_openbus,rk_memv,#0

              testb rk_ppu_vmain_vmadd,#7 wc
        if_c  ret wcz ' TODO: double-check VMAIN[7] meaning

              'rdlong rk_memtmp1,#ppu_vram_addr
              getword rk_memtmp1,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,rk_memtmp1

              ' VRAM increment (after read)
        '      testb rk_ppu_vmain_vmadd,#0 wz
        '      testb rk_ppu_vmain_vmadd,#1 wc
        'if_00 add rk_memtmp2,#1
        'if_01 add rk_memtmp2,#32
        'if_1x add rk_memtmp2,#128
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa
              'wrlong rk_memtmp2,#ppu_vram_addr
              setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              
              testb rk_ppu_vmain_vmadd,#3 wc
              testb rk_ppu_vmain_vmadd,#2 wz
              mov rk_memtmp2,rk_memtmp1
    if_not_00 shl rk_memtmp2,#3
              mov rk_memtmp3,rk_memtmp1
        if_01 shr rk_memtmp3,#5
        if_10 shr rk_memtmp3,#6
        if_11 shr rk_memtmp3,#7
        if_01 setq #$FF
        if_10 setq #$1FF
        if_11 setq rk_3ff
    if_not_00 muxq rk_memtmp1,rk_memtmp2
              setq #$07
              muxq rk_memtmp1,rk_memtmp3
              
              shl rk_memtmp1,#1
              setword rk_memtmp1,#@vram>>16,#1

              rdword rk_memtmp1,rk_memtmp1
              wrword rk_memtmp1,#ppu_vram_latch
              ret wcz
ppu_read_vmdatah
              rdbyte rk_memv,#ppu_vram_latch+1
              ' set both PPU1 and general openbus
              setbyte rk_openbus,rk_memv,#1
              setbyte rk_openbus,rk_memv,#0

              testb rk_ppu_vmain_vmadd,#7 wc
        if_nc ret wcz ' TODO: double-check VMAIN[7] meaning

              'rdlong rk_memtmp1,#ppu_vram_addr
              getword rk_memtmp1,rk_ppu_vmain_vmadd,#1
              mov rk_memtmp2,rk_memtmp1

              ' VRAM increment (after read)
        '      testb rk_ppu_vmain_vmadd,#0 wz
        '      testb rk_ppu_vmain_vmadd,#1 wc
        'if_00 add rk_memtmp2,#1
        'if_01 add rk_memtmp2,#32
        'if_1x add rk_memtmp2,#128
              getbyte pa,rk_ppu_vmain_vmadd,#1
              add rk_memtmp2,pa
              'wrlong rk_memtmp2,#ppu_vram_addr
              setword rk_ppu_vmain_vmadd,rk_memtmp2,#1

              ' VRAM remap
              testb rk_ppu_vmain_vmadd,#3 wc
              testb rk_ppu_vmain_vmadd,#2 wz
              mov rk_memtmp2,rk_memtmp1
    if_not_00 shl rk_memtmp2,#3
              mov rk_memtmp3,rk_memtmp1
        if_01 shr rk_memtmp3,#5
        if_10 shr rk_memtmp3,#6
        if_11 shr rk_memtmp3,#7
        if_01 setq #$FF
        if_10 setq #$1FF
        if_11 setq rk_3ff
    if_not_00 muxq rk_memtmp1,rk_memtmp2
              setq #$07
              muxq rk_memtmp1,rk_memtmp3
              shl rk_memtmp1,#1
              setword rk_memtmp1,#@vram>>16,#1

              rdword rk_memtmp1,rk_memtmp1
              wrword rk_memtmp1,#ppu_vram_latch
              ret wcz


ppu_write_cgadd
              'debug("CGADD write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              shl rk_memv,#1
              wrword rk_memv,#ppu_cgaddr
              ret wcz

ppu_write_cgdata
              rdlong ptra,#ppu_cgaddr ' also get latch
              'debug("CGDATA write ",uhex_byte(rk_memv),uhex_long(rk_pc,rk_memtmp1))
              testb ptra,#0 wc
        if_nc setbyte ptra,rk_memv,#2
        
              mov rk_memtmp2,ptra
              add rk_memtmp2,#1
              bitl rk_memtmp2,#9 addbits 6

              wrlong rk_memtmp2,#ppu_cgaddr
        if_nc ret wcz

              rolbyte rk_memv,ptra,#2
              shl rk_memv,#1
              mov rk_memtmp2,rk_memv ' blue in place
              shl rk_memv,#2
              setbyte rk_memtmp2,rk_memv,#3 ' red in place
              shr rk_memv,#5
              setbyte rk_memtmp2,rk_memv,#2 ' green
              and rk_memtmp2,##$F8F8F800
              getword ptra,ptra,#0
              shl ptra,#1
              'debug("palette set ",uhex_long(rk_memtmp2,ptra))
              wrlong rk_memtmp2,ptra[##@palette_current - 2] ' minus 2 to compensate for set LSB

              ret wcz

ppu_read_cgdata
              rdword rk_memtmp1,#ppu_cgaddr
              mov rk_memtmp2,rk_memtmp1
              incmod rk_memtmp2,#511
              wrword rk_memtmp2,#ppu_cgaddr

              shl rk_memtmp1,#1
              add rk_memtmp1,##@palette_current
              rdword rk_memtmp2,rk_memtmp1

              getbyte rk_memv,rk_memtmp2,#1 ' get blue
              shr rk_memv,#3
              rolbyte rk_memv,rk_memtmp2,#2 ' get green
              shr rk_memv,#3
              rolbyte rk_memv,rk_memtmp2,#3 ' get red
              shr rk_memv,#3

              testb rk_openbus,#16+7 wz
              bitz rk_memv,#15

              testb rk_memtmp1,#0 wc
        if_c  getbyte rk_memv,rk_memv,#1
        if_nc getbyte rk_memv,rk_memv,#0

              setbyte rk_openbus,rk_memv,#0
              setbyte rk_openbus,rk_memv,#2
              ret wcz



ppu_write_bgmode
              'debug("BGMODE write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,#ppu_bgmode
              ret wcz

ppu_write_mosaic
              ' Need to write reset flag if going from "no layers enabled" to "some layers enabled"
              rdbyte rk_memtmp1,#ppu_mosaic
              test rk_memtmp1,#%11110000 wz
              modc _z wc
              test rk_memv,#%11110000 wz
              bith rk_memv,#8
        if_10 wrword rk_memv,#ppu_mosaic
    if_not_10 wrbyte rk_memv,#ppu_mosaic
              ret wcz

ppu_write_bg1sc
              'debug("BG1SC write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,#ppu_bg1sc
              ret wcz
ppu_write_bg2sc
              wrbyte rk_memv,#ppu_bg2sc
              ret wcz
ppu_write_bg3sc
              wrbyte rk_memv,#ppu_bg3sc
              ret wcz
ppu_write_bg4sc
              wrbyte rk_memv,#ppu_bg4sc
              ret wcz
ppu_write_bg12nba
              'debug("BG12NBA write ",uhex_byte(rk_memv),uhex_long(rk_pc))
              wrbyte rk_memv,#ppu_bg12nba
              ret wcz
ppu_write_bg34nba
              wrbyte rk_memv,#ppu_bg34nba
              ret wcz

ppu_write_bg1hofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              getbyte rk_memtmp2,rk_memtmp1,#1
              setq #7
              muxq rk_memtmp1,rk_memtmp2
              getbyte rk_memtmp2,rk_memtmp1,#2 ' get m7 latch
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg1hofs

              setbyte rk_memtmp2,rk_memv,#1
              wrword rk_memtmp2,#ppu_m7hofs

              movbyts rk_memv,#%%0000
              wrlong rk_memv,#ppu_bgofs_latch ' write ALL latches
              ret wcz
ppu_write_bg1vofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              getbyte rk_memtmp2,rk_memtmp1,#2 ' get m7 latch
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg1vofs

              setbyte rk_memtmp2,rk_memv,#1
              wrword rk_memtmp2,#ppu_m7vofs

              wrbyte rk_memv,#ppu_bgofs_latch
              wrbyte rk_memv,#ppu_mode7_latch
              ret wcz

ppu_write_bg2hofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              getbyte rk_memtmp2,rk_memtmp1,#1
              setq #7
              muxq rk_memtmp1,rk_memtmp2
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg2hofs

              movbyts rk_memv,#%%0000
              wrword rk_memv,#ppu_bgofs_latch ' write normal and HOFS latches
              ret wcz
ppu_write_bg2vofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg2vofs

              wrbyte rk_memv,#ppu_bgofs_latch
              ret wcz

ppu_write_bg3hofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              getbyte rk_memtmp2,rk_memtmp1,#1
              setq #7
              muxq rk_memtmp1,rk_memtmp2
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg3hofs

              movbyts rk_memv,#%%0000
              wrword rk_memv,#ppu_bgofs_latch ' write normal and HOFS latches
              ret wcz
ppu_write_bg3vofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg3vofs

              wrbyte rk_memv,#ppu_bgofs_latch
              ret wcz

ppu_write_bg4hofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              getbyte rk_memtmp2,rk_memtmp1,#1
              setq #7
              muxq rk_memtmp1,rk_memtmp2
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg4hofs

              movbyts rk_memv,#%%0000
              wrword rk_memv,#ppu_bgofs_latch ' write normal and HOFS latches
              ret wcz
ppu_write_bg4vofs
              rdlong rk_memtmp1,#ppu_bgofs_latch
              setbyte rk_memtmp1,rk_memv,#1
              zerox rk_memtmp1,#9
              wrword rk_memtmp1,#ppu_bg4vofs

              wrbyte rk_memv,#ppu_bgofs_latch
              ret wcz


ppu_write_m7sel
              wrbyte rk_memv,#ppu_m7sel
              ret wcz
ppu_write_m7a
              rdbyte rk_memtmp1,#ppu_mode7_latch
              wrbyte rk_memv,#ppu_mode7_latch
              setbyte rk_memtmp1,rk_memv,#1
              wrword rk_memtmp1,#ppu_m7a
              ret wcz
ppu_write_m7b
              rdbyte rk_memtmp1,#ppu_mode7_latch
              wrbyte rk_memv,#ppu_mode7_latch
              setbyte rk_memtmp1,rk_memv,#1
              wrword rk_memtmp1,#ppu_m7b
              ret wcz
ppu_write_m7c
              rdbyte rk_memtmp1,#ppu_mode7_latch
              wrbyte rk_memv,#ppu_mode7_latch
              setbyte rk_memtmp1,rk_memv,#1
              wrword rk_memtmp1,#ppu_m7c
              ret wcz
ppu_write_m7d
              rdbyte rk_memtmp1,#ppu_mode7_latch
              wrbyte rk_memv,#ppu_mode7_latch
              setbyte rk_memtmp1,rk_memv,#1
              wrword rk_memtmp1,#ppu_m7d
              ret wcz
ppu_write_m7x
              rdbyte rk_memtmp1,#ppu_mode7_latch
              wrbyte rk_memv,#ppu_mode7_latch
              setbyte rk_memtmp1,rk_memv,#1
              wrword rk_memtmp1,#ppu_m7x
              ret wcz
ppu_write_m7y
              rdbyte rk_memtmp1,#ppu_mode7_latch
              wrbyte rk_memv,#ppu_mode7_latch
              setbyte rk_memtmp1,rk_memv,#1
              wrword rk_memtmp1,#ppu_m7y
              ret wcz

ppu_read_mpyl
              rdlong rk_memv,#ppu_m7a
              mov rk_memtmp1,rk_memv
              sar rk_memtmp1,#24
              muls rk_memv,rk_memtmp1
              getbyte rk_memv,rk_memv,#0
              setbyte rk_openbus,rk_memv,#1
              setbyte rk_openbus,rk_memv,#0
              ret wcz
ppu_read_mpym
              rdlong rk_memv,#ppu_m7a
              mov rk_memtmp1,rk_memv
              sar rk_memtmp1,#24
              muls rk_memv,rk_memtmp1
              getbyte rk_memv,rk_memv,#1
              setbyte rk_openbus,rk_memv,#1
              setbyte rk_openbus,rk_memv,#0
              ret wcz
ppu_read_mpyh
              rdlong rk_memv,#ppu_m7a
              mov rk_memtmp1,rk_memv
              sar rk_memtmp1,#24
              muls rk_memv,rk_memtmp1
              getbyte rk_memv,rk_memv,#2
              setbyte rk_openbus,rk_memv,#1
              setbyte rk_openbus,rk_memv,#0
              ret wcz

ppu_write_wh0
              wrbyte rk_memv,#ppu_wh0
              ret wcz
ppu_write_wh1
              wrbyte rk_memv,#ppu_wh1
              ret wcz
ppu_write_wh2
              wrbyte rk_memv,#ppu_wh2
              ret wcz
ppu_write_wh3
              wrbyte rk_memv,#ppu_wh3
              ret wcz

ppu_write_w12sel
              wrbyte rk_memv,#ppu_w12sel
              ret wcz
ppu_write_w34sel
              wrbyte rk_memv,#ppu_w34sel
              ret wcz
ppu_write_wobjsel
              wrbyte rk_memv,#ppu_wobjsel
              ret wcz

ppu_write_wbglog
              wrbyte rk_memv,#ppu_wbglog
              ret wcz
ppu_write_wobjlog
              wrbyte rk_memv,#ppu_wobjlog
              ret wcz

ppu_write_tm
              wrbyte rk_memv,#ppu_tm
              ret wcz
ppu_write_ts
              wrbyte rk_memv,#ppu_ts
              ret wcz
ppu_write_tmw
              wrbyte rk_memv,#ppu_tmw
              ret wcz
ppu_write_tsw
              wrbyte rk_memv,#ppu_tsw
              ret wcz

ppu_write_cgwsel
              wrbyte rk_memv,#ppu_cgwsel
              ret wcz
ppu_write_cgadsub
              wrbyte rk_memv,#ppu_cgadsub
              ret wcz

ppu_write_coldata
              rdlong rk_memtmp1,#ppu_fixedcolor
              mov rk_memtmp2,rk_memv
              shl rk_memtmp2,#3
              testb rk_memv,#7 wc
        if_c  setbyte rk_memtmp1,rk_memtmp2,#1 ' blue
              testb rk_memv,#6 wc
        if_c  setbyte rk_memtmp1,rk_memtmp2,#2 ' green
              testb rk_memv,#5 wc
        if_c  setbyte rk_memtmp1,rk_memtmp2,#3 ' red
              wrlong rk_memtmp1,#ppu_fixedcolor
              ret wcz

ppu_write_setini
              wrbyte rk_memv,#ppu_setini
              ret wcz
              

DAT ' PPU Layer rendering

              org
ppr_entry

              org
ppr_entry

              setq2 #511
              rdlong 0,##@ppr_lutcode
              jmp #ppr_lineloop
              
ppr_tileconv_2bpp
              ' assume we have tile attrs in ppr_tile at this point
              ' and tile id in ppr_tileid (gets clobbered)
              ' and flip/mirror in CZ (must preserve)

              'testb ppr_tile,#15 wc ' flip bit
              zerox ppr_tileid,#9
              rolnib ppr_tileid,ppr_tileline_offset,#0 ' tile is 16 bytes, so take free SHL #4
        if_c  xor ppr_tileid,#7<<1
              add ppr_tileid,ppr_tilebase
              setword ppr_tileid,#1,#1 ' set VRAM pointer

              'rdword ppr_tilebuffer+0, ppr_tileid ' first two bitplanes
              rdfast ppr_bit31, ppr_tileid

              setq ppr_attrmask2 ' set for later
              ' Prepare attributes (2bpp pain)
              mov ppr_tmp1, ppr_tile
              signx ppr_tmp1,#13
              shr ppr_tmp1,#10-2
              andn ppr_tmp1,#$60
              add ppr_tmp1,ppr_4cbase
              movbyts ppr_tmp1, #%%0000

              rfword ppr_tilebuffer+0

              'testb ppr_tile,#14 wz ' mirror bit
        if_nz rev ppr_tilebuffer+0
        if_nz movbyts ppr_tilebuffer+0,#%%0123

              ' Convert to 7bpp + priority
              mergeb ppr_tilebuffer+0
              movbyts ppr_tilebuffer+0, #%%3120
              mergew ppr_tilebuffer+0
              movbyts ppr_tilebuffer+0, #%%3120
              splitw ppr_tilebuffer+0
              mov ppr_tilebuffer+1,ppr_tilebuffer+0
              shr ppr_tilebuffer+1,#4
              altr ppr_pptr,ppr_pbuf_write
              muxq ppr_tilebuffer+0,ppr_tmp1
              altr ppr_pptr,ppr_pbuf_write
        _ret_ muxq ppr_tilebuffer+1,ppr_tmp1

ppr_tileconv_4bpp
              zerox ppr_tileid,#9
              shl ppr_tileid,#5 ' tile is 32 bytes
              add ppr_tileid,ppr_tileline_offset
        if_c  xor ppr_tileid,#7<<1
              add ppr_tileid,ppr_tilebase
              setword ppr_tileid,#1,#1 ' set VRAM pointer

              setq #4
              rdlong ppr_tilebuffer+0, ppr_tileid
              setword ppr_tilebuffer+0,ppr_tilebuffer+4,#1 ' combine bitplanes

              'testb ppr_tile,#14 wz ' mirror bit
        if_nz rev ppr_tilebuffer+0
        if_nz movbyts ppr_tilebuffer+0,#%%0123

              ' Prepare attributes
              mov ppr_tmp1, ppr_tile
              shr ppr_tmp1,#10-4
              movbyts ppr_tmp1, #%%0000

              ' Convert to 7bpp + priority
              mergeb ppr_tilebuffer+0
              movbyts ppr_tilebuffer+0, #%%3120
              mergew ppr_tilebuffer+0
              movbyts ppr_tilebuffer+0, #%%3120
              splitw ppr_tilebuffer+0
              mov ppr_tilebuffer+1,ppr_tilebuffer+0
              shr ppr_tilebuffer+1,#4
              setq ppr_attrmask4
              muxq ppr_tilebuffer+0,ppr_tmp1
              muxq ppr_tilebuffer+1,ppr_tmp1

              wflong ppr_tilebuffer+0
        _ret_ wflong ppr_tilebuffer+1

ppr_tileconv_8bpp
              zerox ppr_tileid,#9
              shl ppr_tileid,#6 ' tile is 64 bytes
              add ppr_tileid,ppr_tileline_offset
        if_c  xor ppr_tileid,#7<<1
              add ppr_tileid,ppr_tilebase
              setword ppr_tileid,#1,#1 ' set VRAM pointer

              ' attributes to secondary buffer
              mov ppr_tmp1, ppr_tile
              signx ppr_tmp1,#13
              shr ppr_tmp1,#10
              shl ppr_tmp1,#1  ' we need(?) PxxxCCC0
              altr ppr_pptr,#ppr_pixelbuffer
              movbyts ppr_tmp1, #%%0000
              altr ppr_pptr,ppr_pbuf_write
              movbyts ppr_tmp1, #%%0000

              setq #12
              rdlong ppr_tilebuffer+0, ppr_tileid
              setword ppr_tilebuffer+0,ppr_tilebuffer+4,#1 ' combine bitplanes
              setword ppr_tilebuffer+8,ppr_tilebuffer+12,#1 ' combine bitplanes

              'testb ppr_tile,#14 wz ' mirror bit
        if_nz rev ppr_tilebuffer+0
        if_nz movbyts ppr_tilebuffer+0,#%%0123
        if_nz rev ppr_tilebuffer+8
        if_nz movbyts ppr_tilebuffer+8,#%%0123

              mergeb ppr_tilebuffer+0
              mergeb ppr_tilebuffer+8
              rolword ppr_tilebuffer+1,ppr_tilebuffer+8,#1
              rolword ppr_tilebuffer+1,ppr_tilebuffer+0,#1
              setword ppr_tilebuffer+0,ppr_tilebuffer+8,#1
              splitw ppr_tilebuffer+0
              splitw ppr_tilebuffer+1
              movbyts ppr_tilebuffer+0,#%%3120
              movbyts ppr_tilebuffer+1,#%%3120
              splitw ppr_tilebuffer+0
              splitw ppr_tilebuffer+1
              movbyts ppr_tilebuffer+0,#%%3120
              movbyts ppr_tilebuffer+1,#%%3120
              splitb ppr_tilebuffer+0
              splitb ppr_tilebuffer+1

              wflong ppr_tilebuffer+0
        _ret_ wflong ppr_tilebuffer+1

ppr_draw_sprites
              '' For speed, do a similar dumb reorder-on-write of OAM to what NeoYume does
              '' is now 6 bytes
              '' 0: extra flags (SKIP on this!)
              '' 1: zero dummy byte
              '' 2: tile ID
              '' 3: attribute
              '' 4: X position
              '' 5: Y position


              mov ppr_bufferbase_spr,ppr_bufferbase
              add ppr_bufferbase_spr,##264*4
              mov ppr_sprclipright,ppr_bufferbase_spr
              add ppr_sprclipright,#256

              ' clear sprite buffer (priority buffer doesn't need clearing?)
              setq #63
              wrlong #0,ppr_bufferbase_spr

              rdfast ppr_bit31,##@oam
              
              ' Set sprite tile bases
              getbyte ppr_sprbase_low,ppr_spriteconf,#3 ' OBJSEL
              and ppr_sprbase_low,#3
              shl ppr_sprbase_low,#1
              getbyte ppr_sprbase_high,ppr_spriteconf,#3 ' OBJSEL
              shr ppr_sprbase_high,#3
              and ppr_sprbase_high,#3
              add ppr_sprbase_high,#1
              add ppr_sprbase_high,ppr_sprbase_low
              setq #%1111_000
              muxq ppr_sprbase_low,#@vram>>13
              muxq ppr_sprbase_high,#@vram>>13

              ' Set sprite sizes
              getbyte ppr_tmp1,ppr_spriteconf,#3 ' OBJSEL
              shr ppr_tmp1,#5
              alts ppr_tmp1,#ppr_sprsizetbl
              mov ppr_sprsize,0-0 wc
              getbyte ppr_smallflip,ppr_sprsize,#0
              getbyte ppr_bigflip,ppr_sprsize,#1
        if_c  mov ppr_smallflip,#$0F ' accurate flip behaviour for undocumented sprite sizes
        if_c  mov ppr_bigflip,#$1F   ' ^^
              getnib ppr_smallxchk,ppr_sprsize,#4
              shl ppr_smallxchk,#3
              subr ppr_smallxchk,#257
              getnib ppr_bigxchk,ppr_sprsize,#5
              shl ppr_bigxchk,#3
              subr ppr_bigxchk,#257

              '' sprite line check theoretically works like this:
              ''   current_scanline >= spriteY && current_scanline < (spriteY+height)
              '' reword to make both checks "not carry"
              ''   current_scanline >= spriteY && (spriteY+height-1) >= current_scanline
              '' since current_scanline and height can be constant...
              '' current_scanline >= spriteY && spriteY >= current_scanline-(height-1)

              mov ppr_curychk,ppr_curline
              sub ppr_curychk,#1 ' ??? maybe just do this 1 line early instead?

              ' handle Y wraparound by modifying bottom check condition
              ' when not overflowing, check Y >= top && Y <= bottom
              ' intead, when overflowing:   Y >= top || Y <= bottom
              getbyte ppr_smallychk,ppr_sprsize,#0
              subr ppr_smallychk,ppr_curychk wc
        if_c  add ppr_smallychk,#256
        if_nc  setnib .smally,#_nc,#7
        if_c setnib .smally,#_c,#7
              getbyte ppr_bigychk,ppr_sprsize,#1
              subr ppr_bigychk,ppr_curychk wc
        if_c  add ppr_bigychk,#256
        if_nc  setnib .bigy,#_nc,#7
        if_c setnib .bigy,#_c,#7

              testb ppr_mode,#9 wc ' OBJ interlace flag
              wrc ppr_sprinterlace

              neg ppr_spridx,#32
              mov ppr_sprchkleft,#128
              'debug(".collect_loop")

.collect_loop
              rflong ppr_tile ' attribute + tile + flags
              altd ppr_tile,#ppr_collect_skiptbl ' altd ignores high bits!
              skipf 0-0 ' skip on size and X8
              rfbyte ppr_tmp2 wz ' get low X (low X==0 always counts as on-screen!)
              rfbyte ppr_tmp3 ' get Y
              cmp ppr_curychk,ppr_tmp3 wc ' NC = top Y check pass
.smally if_nc cmp ppr_tmp3,ppr_smallychk wc ' NC = bottom Y check pass (SMALL ONLY)
.bigy   if_nc cmp ppr_tmp3,ppr_bigychk wc ' NC = bottom Y check pass (BIG ONLY)
 if_nc_and_nz cmp ppr_tmp2,ppr_smallxchk wc ' NC = edge clip pass (X8=1 and SMALL only)
 if_nc_and_nz cmp ppr_tmp2,ppr_bigxchk wc ' NC = edge clip pass (X8=1 and BIG only)
        if_c  djnz ppr_sprchkleft,#.collect_loop ' max. 20 cycles - 2560 in this loop total

        if_c  jmp #.collect_done ' loop end
              'debug(sdec(ppr_spridx,ppr_sprchkleft))
              '' Reel it in, reel it in, etc
              subr ppr_tmp3,ppr_curychk ' get Y inside sprite
              testb ppr_framecnt,#0 wc ' odd field flag
              rcl ppr_tmp3,ppr_sprinterlace ' shift field flag into Y position if obj interlace
              testb ppr_tile,#1 wz ' size
              testb ppr_tile,#31 wc ' flip flag
        if_10 xor ppr_tmp3,ppr_smallflip
        if_11 xor ppr_tmp3,ppr_bigflip
              testb ppr_tile,#0 wc ' X8
              rcl ppr_tmp3,#1
              setbyte ppr_tile,ppr_tmp3,#1
              setbyte ppr_tile,ppr_tmp2,#0
              altr ppr_spridx,ppr_sprbuf_write ' store into 32 sprite buffer, increment
              bitz ppr_tile,#31 ' replace flip flag with size flag
              djz ppr_sprchkleft,#.collect_done
              tjnz ppr_spridx,#.collect_loop ' 32 cycles to collect a sprite - 1024
.collect_done
              'debug(".collect_done")
              '' TODO we might end up here due to priority rotation?
              mov ppr_sprchkleft, #34 ' become line tile counter
              add ppr_spridx,#31 ' becomes positive buffer index
              'jmp #.draw_done ' DEBUG
              tjs ppr_spridx,#.draw_done
.sprite    
              alts ppr_spridx, ppr_sprbuf_read ' decrement
              mov ppr_tile,0-0 wc ' C = big
        if_c  getnib ppr_tileleft,ppr_sprsize,#5  ' actually tiles - 1, we do djnf
        if_nc getnib ppr_tileleft,ppr_sprsize,#4

              getnib ppr_tilex,ppr_tile,#4 ' sprite sheet X
              testb ppr_tile,#30 wz ' mirror flag
        if_z  add ppr_tilex,ppr_tileleft

              mov ptra,ppr_tile
              bitl ppr_tile,#8
              signx ptra,#8 wc ' PTRA has sprite X
              ' left clip logic
        if_c  neg ppr_tmp1,ptra
        if_c  shr ppr_tmp1,#3
        if_c  sub ppr_tileleft,ppr_tmp1
        if_c  tjs ppr_tileleft,#.sprite_clipped ' no tiles left
        if_c  sumz ppr_tilex,ppr_tmp1
        if_c  shl ppr_tmp1,#3
        if_c  add ptra,ppr_tmp1

              add ptra,ppr_bufferbase_spr ' buffer base
              mov ptrb,ptra
              add ptrb, #256+8 ' priority buffer offset

              testb ppr_tile,#24 wc
        if_c  mov ppr_tilebase,ppr_sprbase_high
        if_nc mov ppr_tilebase,ppr_sprbase_low
              
              getnib ppr_tmp1,ppr_tile,#3 ' Y position >> 3
              getnib ppr_tmp2,ppr_tile,#5 ' sprite sheet Y
              add ppr_tmp1,ppr_tmp2 ' sprite sheet Y in bottom 4 bits
              rolnib ppr_tilebase,ppr_tmp1,#0

              ' 54 cycles per sprite setup - 1728 cycles

.tile
              ' Tile address is something like
              ' %BBBY_YYYX_XXX0_yyy0
              ' B is base for sprite sheet (from OBJSEL and second sheet flag)
              ' Y is sprite sheet Y position
              ' X is sprite sheet X position
              ' y is bottom 3 bits of pixel Y position
              mov ppr_tileid,ppr_tilebase ' already should have VRAM base, sheet base and sheet Y in it
              rolnib ppr_tileid,ppr_tilex,#0
              shl ppr_tileid,#1
              rolnib ppr_tileid,ppr_tile,#2 ' (Y & 3) << 1

              rdfast ppr_bit31, ppr_tileid
              ' get palette (do down here to save 28 MOVs and fill RDFAST delay slot)
              getnib ppr_tilebuffer+6,ppr_tile,#6
              shl ppr_tilebuffer+6,#3
              and ppr_tilebuffer+6,#%0111_0000
              mov ppr_tilebuffer+7,ppr_tilebuffer+6
              ' get priority
              getbyte ppr_tilebuffer+2,ppr_tile,#3
              and ppr_tilebuffer+2,#%0011_0000
              mov ppr_tilebuffer+3,ppr_tilebuffer+2

              rflong ppr_tilebuffer+0
              rflong ppr_tilebuffer+1 ' dummy read
              rflong ppr_tilebuffer+1 ' dummy read
              rflong ppr_tilebuffer+1 ' dummy read
              rflong ppr_tilebuffer+4
              setword ppr_tilebuffer+0,ppr_tilebuffer+4,#1 ' combine bitplanes

        if_nz rev ppr_tilebuffer+0
        if_nz movbyts ppr_tilebuffer+0,#%%0123
              ' generate masks (transparent pixels high)
              getword ppr_tilebuffer+4,ppr_tilebuffer+0,#1
              or ppr_tilebuffer+4,ppr_tilebuffer+0
              not ppr_tilebuffer+4
              getbyte ppr_tmp3,ppr_tilebuffer+4,#1
              and ppr_tmp3,ppr_tilebuffer+4
              ' maskify!
              mergew ppr_tmp3 
              movbyts ppr_tilebuffer+2,ppr_tmp3
              movbyts ppr_tilebuffer+6,ppr_tmp3
              shr ppr_tmp3,#8
              movbyts ppr_tilebuffer+3,ppr_tmp3
              ' write priority
              setq #1
              wmlong ppr_tilebuffer+2,ptrb++
              ' (down here for slice alignment)
              movbyts ppr_tilebuffer+7,ppr_tmp3
              ' usual pixel conversion
              mergeb ppr_tilebuffer+0
              movbyts ppr_tilebuffer+0, #%%3120
              mergew ppr_tilebuffer+0
              movbyts ppr_tilebuffer+0, #%%3120
              splitw ppr_tilebuffer+0
              mov ppr_tilebuffer+1,ppr_tilebuffer+0
              shr ppr_tilebuffer+1,#4
              ' add attributes to non-masked pixels
              setq ppr_attrmask4
              muxq ppr_tilebuffer+0,ppr_tilebuffer+6
              muxq ppr_tilebuffer+1,ppr_tilebuffer+7
              ' write pixels
              setq #1
              wmlong ppr_tilebuffer+0,ptra++
              djz ppr_sprchkleft,#.draw_done ' line limit
.tile_next
              sumz ppr_tilex,#1 ' advance tile (Z is still mirror bit)
              cmp ptra,ppr_sprclipright wc ' is buffer + 256
        if_c  djnf ppr_tileleft,#.tile ' next tile unless clipping into right edge
              tjns ppr_spridx,#.sprite ' already decremented this earlier
              jmp #.draw_done
              ' 47 alu ops + 2 WMLONG+1u + 1 branch
              ' ~116 per tile - 3944 total
              ' Buffer spacing is 264 bytes. There should be 11 ops between the WMLONGs (12 including SETQ)
              ' total time for both WMLONG together should then be 10..18 cycles (excluding SETQ)

.sprite_clipped
              test ptra,#255 wz ' Check for weird X=-256 special case
        if_nz tjns ppr_spridx,#.sprite
        if_nz jmp #.draw_done
        
              add ppr_tileleft,#32 + 1 ' what got subtracted by clip logic + compensate for off-by-one
              sub ppr_sprchkleft,ppr_tileleft wcz ' count all tiles against limit
        if_00 tjns ppr_spridx,#.sprite
              jmp #.draw_done

.draw_done
              jmp #ppr_lineloop

ppr_pbuf_write long ppr_pixelbuffer + (1<<9)

ppr_ntread    long ppr_ntbuf + (1<<9)
ppr_sprbuf_write long ppr_sprbuf+32 + (1<<9)
ppr_sprbuf_read long ppr_sprbuf + (-1<<9)

ppr_attrmask2 long $FCFCFCFC
ppr_attrmask4 long $F0F0F0F0
ppr_bit31     long 1<<31

ppr_collect_skiptbl
              long %1110000 ' X8=0/SMALL
              long %1010000 ' X8=1/SMALL
              long %1101000 ' X8=0/BIG
              long %0101000 ' X8=1/BIG

ppr_sprsizetbl
              long $00_10_0F_07 ' 8x8/16x16
              long $00_30_1F_07 ' 8x8/32x32
              long $00_70_3F_07 ' 8x8/64x64
              long $00_31_1F_0F ' 16x16/32x32
              long $00_71_3F_0F ' 16x16/64x64
              long $00_73_3F_1F ' 32x32/64x64
              long $80_31_3F_1F ' 16x32/32x64 (buggy flip)
              long $80_31_1F_1F ' 16x32/32x32 (buggy flip)

ppr_mode      res 1
ppr_mathconfig res 1
ppr_spriteconf res 1

ppr_namebases res 1
ppr_tilebases res 1
ppr_scrollvals res 4

ppr_mosaicctr res 1

ppr_tilebuffer res 13

ppr_ntbuf      ' same 32 long buffer
ppr_ovlbuf
ppr_sprbuf     res 32
ppr_ovlend

                res 1 ' padding
ppr_pixelbuffer res 66

ppr_curline res 1
ppr_framecnt res 1 ' TODO
ppr_time    res 1

ppr_tmp1    res 1
ppr_tmp2      res 1
ppr_tmp3      res 1
ppr_tmp4      res 1

ppr_pptr      res 1
ppr_ntptr     res 1
ppr_spridx    res 1

ppr_curychk  res 1
ppr_m7hv ' alias
ppr_smallychk  res 1
ppr_m7a ' also loads b
ppr_bigychk  res 1
ppr_m7c ' also loads d
ppr_smallxchk  res 1
ppr_m7xy ' alias
ppr_bigxchk  res 1
ppr_m7x ' alias
ppr_sprsize  res 1
ppr_m7y ' alias
ppr_smallflip res 1
ppr_bigflip res 1
ppr_sprchkleft res 1
ppr_sprinterlace res 1
ppr_sprclipright res 1

ppr_bufferbase res 1
ppr_bufferbase_spr res 1

ppr_tile      res 1
ppr_tileid    res 1
ppr_tilex     res 1
ppr_tileline_offset res 1
ppr_tileleft  res 1

ppr_tileconv_func res 1
ppr_tilebase  res 1
ppr_sprbase_low  res 1
ppr_sprbase_high  res 1
ppr_4cbase    res 1

              fit 502

              org 512
ppr_lutcode

ppr_lineloop
if TIME_RENDER
              getct ppr_tmp1
              subr ppr_time,ppr_tmp1
              debug(sdec(ppr_time,ppr_tmp1,ppr_curline),dly(#100))
              getct ppr_time
end
              rdlong ppr_tmp1,#video_line_ctr
              cmp ppr_tmp1,ppr_curline wz
        if_z  jmp #ppr_lineloop
              mov ppr_curline,ppr_tmp1

              rdlong ppr_mode,#ppu_mode
              rdlong ppr_mathconfig,#ppu_mathconfig
              rdlong ppr_tilebases,#ppu_tilebase
              rdlong ppr_namebases,#ppu_namebase
              setq #3
              rdlong ppr_scrollvals,#ppu_bg1_scroll
              rdlong ppr_spriteconf,#ppu_spriteconf
              setq #3
              rdlong ppr_m7hv,#ppu_mode7hv

              testb ppr_curline,#0 wc
        if_c  loc pa,#layer_buffer
        if_nc loc pa,#layer_buffer+(264*6)
              mov ppr_bufferbase,pa

              mov ppr_4cbase,#0

              testb ppr_mode,#24 wz
        if_z  wrbyte #0,#ppu_mosaicreset
        if_nz cmp ppr_curline,#0 wz
        if_z  mov ppr_mosaicctr,#0
              getnib pa,ppr_mode,#5
        if_nz incmod ppr_mosaicctr,pa

              getnib ppr_tmp1,ppr_mode,#0
              and ppr_tmp1,#7

              jmprel ppr_tmp1
              jmp #ppr_do_mode0
              jmp #ppr_do_mode1
              jmp #ppr_do_mode2
              jmp #ppr_do_mode3
              jmp #ppr_do_mode4
              jmp #ppr_do_mode5
              jmp #ppr_do_mode6
              jmp #ppr_do_mode7

ppr_linefinish
              ' do some stuff in the middle of the scanline
              ' we can be sure the other cogs loaded their stuff by now

              ' copy palette into palette_ring
              loc ptra,#palette_current
              testb ppr_curline,#0 wc
        if_c  loc ptrb,#palette_ring
        if_nc loc ptrb,#palette_ring + 1024

              rep @.palcopy,#4
              setq #63
              rdlong ppr_pixelbuffer,ptra++
              setq #63
              wrlong ppr_pixelbuffer,ptrb++
.palcopy


              jmp #ppr_draw_sprites
              'jmp #ppr_lineloop



ppr_do_mode0
              callpa #0,#ppr_drawlayer_2bpp_normal
              mov ppr_4cbase,#32
              callpa #1,#ppr_drawlayer_2bpp_normal
              mov ppr_4cbase,#64
              callpa #2,#ppr_drawlayer_2bpp_normal
              mov ppr_4cbase,#96
              callpa #3,#ppr_drawlayer_2bpp_normal
              jmp #ppr_linefinish
ppr_do_mode1
              callpa #0,#ppr_drawlayer_4bpp_normal
              callpa #1,#ppr_drawlayer_4bpp_normal
              callpa #2,#ppr_drawlayer_2bpp_normal
              jmp #ppr_linefinish
ppr_do_mode2
              jmp #ppr_linefinish
ppr_do_mode3
              callpa #0,#ppr_drawlayer_8bpp_normal
              callpa #1,#ppr_drawlayer_4bpp_normal
              jmp #ppr_linefinish
ppr_do_mode4
              jmp #ppr_linefinish
ppr_do_mode5
              jmp #ppr_linefinish
ppr_do_mode6
              jmp #ppr_linefinish
ppr_do_mode7
              '' Mode 7 is special sauce
              
              ' load the overlay
              testb ppr_mathconfig,#31 wc
              testb ppr_mathconfig,#30 wz
        if_0x loc pa,#pprovl_mode7_wrapping
        if_10 loc pa,#pprovl_mode7_transparent
        if_11 loc pa,#pprovl_mode7_tile0

              setq #ppr_ovlend - ppr_ovlbuf - 1
              rdlong ppr_ovlbuf,pa

              ' do the setup
              mov ppr_curychk,ppr_curline
              testb ppr_mode,#16 wc ' MOSAIC BG1 check
        if_c  sub ppr_curychk,ppr_mosaicctr
              testb ppr_mathconfig,#25 wc ' Y flip flag
        if_c  subr ppr_curychk,#255



              
              call #ppr_ovlbuf

              jmp #ppr_linefinish


ppr_drawlayer_2bpp_normal
              mov ppr_tileconv_func,#ppr_tileconv_2bpp
              call #ppr_setuplayer_normal
              mov ppr_pptr,#0
              call #ppr_drawlayer_normal
              setq #65
        _ret_ wrlong ppr_pixelbuffer,ptra

ppr_drawlayer_4bpp_normal
              mov ppr_tileconv_func,#ppr_tileconv_4bpp
              call #ppr_setuplayer_normal
              wrfast ppr_bit31,ptra
              jmp #ppr_drawlayer_normal

ppr_drawlayer_8bpp_normal
              mov ppr_tileconv_func,#ppr_tileconv_8bpp
              call #ppr_setuplayer_normal
              mov ppr_pptr,#0
              wrfast ppr_bit31,ptra
              call #ppr_drawlayer_normal
              ' flush attributes to BG4's buffer
              add ptra,##264*3
              setq #65
        _ret_ wrlong ppr_pixelbuffer,ptra



ppr_setuplayer_normal
              altgb pa,#ppr_tilebases
              getnib ppr_tilebase
              shl ppr_tilebase,#13

              alts pa,#ppr_scrollvals
              mov ppr_tmp3,0-0


              altgb pa,#ppr_namebases
              getbyte pb

              alts pa,#4
              testb ppr_mode,#0-0 wz ' 16x16 flag
              wrz ppr_tmp4


              mov ptra,pa
              mul ptra,#264
              add ptra,ppr_bufferbase
              getword ppr_ntptr,ppr_tmp3,#0
              and ppr_ntptr,#7
              sub ptra,ppr_ntptr
              getword ppr_ntptr,ppr_tmp3,#0
        if_z  shr ppr_ntptr,#4
        if_nz shr ppr_ntptr,#3

              getword ppr_curychk,ppr_tmp3,#1
              add ppr_curychk,ppr_curline

              alts pa,#16
              testb ppr_mode,#0-0 wc
        if_c  sub ppr_curychk,ppr_mosaicctr

              mov ppr_tileline_offset,ppr_curychk
              and ppr_tileline_offset,#7
              shl ppr_tileline_offset,#1

              mov ppr_tmp1,ppr_curychk
        if_z  shr ppr_tmp1,#4
        if_nz shr ppr_tmp1,#3
              rczr pb wcz ' double tilemap flags C=V Z=H
              'modcz _set,_set wcz ' DEBUG
              testb ppr_tmp1,#5 andc ' in bottom nametable?
              and ppr_tmp1,#31

        if_x1 decod ppr_tmp2,#encod (32*32*2)
        if_x0 mov ppr_tmp2,#0
        if_11 add ppr_tmp1,#64
        if_10 add ppr_tmp1,#32

              shl ppr_tmp1,#6 ' * 32 words
              shl pb,#11 ' NT base address
              add pb,ppr_tmp1 ' NT line address

              testb ppr_ntptr,#5 andz ' in right nametable?
        if_z  add pb,ppr_tmp2
              setword pb,#@vram>>16,#1
              'debug("NT+0  ",uhex(pb))
              setq #15
              rdlong ppr_ntbuf+0,pb
              sumz pb,ppr_tmp2
              setword pb,#@vram>>16,#1
              'debug("NT+16 ",uhex(pb))
              setq #15
              rdlong ppr_ntbuf+16,pb

              and ppr_ntptr,#31
        _ret_ mov ppr_tileleft,#33

ppr_drawlayer_normal
              tjz ppr_tmp4,#ppr_drawlayer_8x8

ppr_drawlayer_16x16
              '' special case for starting on odd tiles
              testb ppr_tmp3,#3 wz
        if_z  skipf ##%11_000000000 ' skip call and DJZ
              ' 11 ALU + 4 branch for 2 tiles
.loop
              altgw ppr_ntptr,ppr_ntread ' autoincrement
              getword ppr_tile
              mov ppr_tileid,ppr_tile
              testb ppr_tile,#15 wc ' flip bit
              testb ppr_curychk,#3 wz ' in odd half-tile row?
    if_c_ne_z add ppr_tileid,#16
              mov ppr_tilex,ppr_tileid ' hope this isn't clobbered
              testb ppr_tile,#14 wz ' mirror bit
        if_z  add ppr_tileid,#1
              call ppr_tileconv_func
              djz ppr_tileleft,#.leave

              mov ppr_tileid,ppr_tilex
        if_nz add ppr_tileid,#1
              call ppr_tileconv_func
        _ret_ djnz ppr_tileleft,#.loop
.leave
              ret

ppr_drawlayer_8x8 '' 7 ALU + 2 branch per tile (+ 2 block reads prior)
              ' needs both nametables preloaded
              ' when starting in the second nametable, load that one first
.loop
              altgw ppr_ntptr,ppr_ntread ' autoincrement
              getword ppr_tile
              mov ppr_tileid,ppr_tile
              testb ppr_tile,#15 wc ' flip bit
              testb ppr_tile,#14 wz ' mirror bit
              call ppr_tileconv_func
        _ret_ djnz ppr_tileleft,#.loop


              fit 1024

DAT ' PPU Render overlays

'' SUPER DUPER ULTRA CRACKHEAD VERSION
'' first iteration is nonsense!
'' need to load one of 3 overlays depending on overflow mode

'' positions are naturally 7.3.8 %OOOO_OOOO_OOOO_OOTT_TTTT_TPPP_ssss_ssss
'' we use 5 padding bits         %OOOO_OOOO_OTTT_TTTT_PPPs_ssss_sssp_pppp
'' TODO: verify minimum number of overflow bits needed
'' (IIRC BSNES uses a full int for this without padding)

'' TODO: full init here (negligable cycles)

              org ppr_ovlbuf

pprovl_mode7_wrapping
              rep @.loop,#257
.loopload
              rdfast ppr_bit31,ppr_tmp1 ' REQUEST PREVIOUS PIXEL
              '' Advance X/Y
              add ppr_m7x,ppr_m7a
              add ppr_m7y,ppr_m7c

              ' make tile pointer
              getbyte ppr_tmp1,ppr_m7x,#2
              shl ppr_tmp1,#1
              getbyte ppr_tmp2,ppr_m7y,#2
              setbyte ppr_tmp1,ppr_tmp2,#1
              zerox ppr_tmp1,#14 ' clamp pointer to 32k (SKIP if other overflow handling)
              setword ppr_tmp1,#@vram>>16,#1 ' VRAM pointer

              rfbyte ppr_tmp2 ' CATCH PREVIOUS PIXEL
              rdfast ppr_bit31,ppr_tmp1 ' REQUEST TILE
        'if_nz mov ppr_tilebuffer1,#0 ' overflow -> transparency (SKIP THIS)
              altsb ppr_pptr,ppr_m7buf_write
              setbyte ppr_tmp2

              ' Check overflow for current pixel
              test ppr_m7x,ppr_m7over wz
        if_z  test ppr_m7y,ppr_m7over wz

              '' prep pixel pointer
              getnib ppr_tmp1,ppr_m7y,#3 ' get %PPPs
              shr ppr_tmp1,#1 ' discard %s
              rolnib ppr_tmp1,ppr_m7x,#3 ' shift in %PPPs
              or ppr_tile,ppr_m7pbase ' set lsb and VRAM pointer

              rfbyte ppr_tile ' CATCH TILE
        'if_nz mov ppr_tile,#0 ' overflow -> tile 0 (SKIP THIS)

              ' make pixel pointer
              shl ppr_tile,#7
              or ppr_tmp1,ppr_tile
.loop
              ret
              fit ppr_ovlend


pprovl_mode7_tile0
              rep @.loop,#257
.loopload
              rdfast ppr_bit31,ppr_tmp1 ' REQUEST PREVIOUS PIXEL
              '' Advance X/Y
              add ppr_m7x,ppr_m7a
              add ppr_m7y,ppr_m7c

              ' make tile pointer
              getbyte ppr_tmp1,ppr_m7x,#2
              shl ppr_tmp1,#1
              getbyte ppr_tmp2,ppr_m7y,#2
              setbyte ppr_tmp1,ppr_tmp2,#1
              'zerox ppr_tmp1,#14 ' clamp pointer to 32k (SKIP if other overflow handling)
              setword ppr_tmp1,#@vram>>16,#1 ' VRAM pointer

              rfbyte ppr_tmp2 ' CATCH PREVIOUS PIXEL
              rdfast ppr_bit31,ppr_tmp1 ' REQUEST TILE
        'if_nz mov ppr_tilebuffer1,#0 ' overflow -> transparency (SKIP THIS)
              altsb ppr_pptr,ppr_m7buf_write
              setbyte ppr_tmp2

              ' Check overflow for current pixel
              test ppr_m7x,ppr_m7over wz
        if_z  test ppr_m7y,ppr_m7over wz

              '' prep pixel pointer
              getnib ppr_tmp1,ppr_m7y,#3 ' get %PPPs
              shr ppr_tmp1,#1 ' discard %s
              rolnib ppr_tmp1,ppr_m7x,#3 ' shift in %PPPs
              or ppr_tile,ppr_m7pbase ' set lsb and VRAM pointer

              rfbyte ppr_tile ' CATCH TILE
        if_nz mov ppr_tile,#0 ' overflow -> tile 0 (SKIP THIS)

              ' make pixel pointer
              shl ppr_tile,#7
              or ppr_tmp1,ppr_tile
.loop
              ret
              fit ppr_ovlend


pprovl_mode7_transparent
              rep @.loop,#257
.loopload
              rdfast ppr_bit31,ppr_tmp1 ' REQUEST PREVIOUS PIXEL
              '' Advance X/Y
              add ppr_m7x,ppr_m7a
              add ppr_m7y,ppr_m7c

              ' make tile pointer
              getbyte ppr_tmp1,ppr_m7x,#2
              shl ppr_tmp1,#1
              getbyte ppr_tmp2,ppr_m7y,#2
              setbyte ppr_tmp1,ppr_tmp2,#1
              'zerox ppr_tmp1,#14 ' clamp pointer to 32k (SKIP if other overflow handling)
              setword ppr_tmp1,#@vram>>16,#1 ' VRAM pointer

              rfbyte ppr_tmp2 ' CATCH PREVIOUS PIXEL
              rdfast ppr_bit31,ppr_tmp1 ' REQUEST TILE
        if_nz mov ppr_tilebuffer1,#0 ' overflow -> transparency (SKIP THIS)
              altsb ppr_pptr,ppr_m7buf_write
              setbyte ppr_tmp2

              ' Check overflow for current pixel
              test ppr_m7x,ppr_m7over wz
        if_z  test ppr_m7y,ppr_m7over wz

              '' prep pixel pointer
              getnib ppr_tmp1,ppr_m7y,#3 ' get %PPPs
              shr ppr_tmp1,#1 ' discard %s
              rolnib ppr_tmp1,ppr_m7x,#3 ' shift in %PPPs
              or ppr_tile,ppr_m7pbase ' set lsb and VRAM pointer

              rfbyte ppr_tile ' CATCH TILE
        'if_nz mov ppr_tile,#0 ' overflow -> tile 0 (SKIP THIS)

              ' make pixel pointer
              shl ppr_tile,#7
              or ppr_tmp1,ppr_tile
.loop
              ret
              fit ppr_ovlend



CON ' layering constants

PMASKx_BACKDROP = %00000000000001
'' There are really two layering modes: one for modes 0/1, one for all the others
'' Low modes layer order:
''   
''            __3S12S12S34S34B
''            __H3HH2LL1HH0LLB
PMASKL_BG1_L = %00000100000000
PMASKL_BG1_H = %00100000000000
PMASKL_BG2_L = %00000010000000
PMASKL_BG2_H = %00010000000000
PMASKL_BG3_L = %00000000000100
PMASKL_BG3_H = %10000000100000 ' both possible positions set
PMASKL_BG4_L = %00000000000010
PMASKL_BG4_H = %00000000010000
PMASKx_SPR_0 = %00000000001000
PMASKx_SPR_1 = %00000001000000
PMASKx_SPR_2 = %00001000000000
PMASKx_SPR_3 = %01000000000000


'' High modes layer order (including BG3/4 remapping for hires modes):
''
''            __xS13S24S13S24B
''            __x3HH2HH1LL0LLB
PMASKH_BG1_L = %00000000100000
PMASKH_BG1_H = %00100000000000
PMASKH_BG2_L = %00000000000100
PMASKH_BG2_H = %00000100000000
PMASKH_BG3_L = %00000000010100
PMASKH_BG3_H = %00010000000000
PMASKH_BG4_L = %00000000000010
PMASKH_BG4_H = %00000010000000
'' (sprites stay the same)

PMASK_HIRES = ((PMASKH_BG3_L|PMASKH_BG3_H|PMASKH_BG4_L|PMASKH_BG4_H)<<16) | (PMASKH_BG1_L|PMASKH_BG1_H|PMASKH_BG2_L|PMASKH_BG2_H)

'' Skip constants for the compositor
'' Main layer chooser
PSKIP_MAIN_BACK = %11_0_11111_111111
PSKIP_MAIN_BG1  = %11_1_01111_011111
PSKIP_MAIN_BG1D = %00_1_01111_011111 ' direct color
PSKIP_MAIN_BG2  = %11_1_10111_101111
PSKIP_MAIN_BG3  = %11_1_11011_110111
PSKIP_MAIN_BG3H = %11_1_11011_011111 ' BG3 as BG1
PSKIP_MAIN_BG4  = %11_1_11101_111011
PSKIP_MAIN_BG4H = %11_1_11101_101111 ' BG4 as BG2
PSKIP_MAIN_SPR  = %11_1_11110_110100
'' Sub layer chooser
PSKIP_SUB_BACK  = %011111_10
PSKIP_SUB_BG1   = %101111_10
PSKIP_SUB_BG1D  = %101111_01 ' direct color
PSKIP_SUB_BG2   = %110111_10
PSKIP_SUB_BG3   = %111011_10
PSKIP_SUB_BG4   = %111101_10
PSKIP_SUB_SPR   = %111110_10
PSKIP_SUB_BG3H = PSKIP_SUB_BG3
PSKIP_SUB_BG4H = PSKIP_SUB_BG4
'' data masking 8bpp/non-8PP mode skip (goes into ppc_pskip)
PSKIP_8BPP     = %0_11_11_00_00 ' skip data check for BG3/BG4
PSKIP_NON_8BPP = %1_00_00_00_00 ' skip ppc_pppd load from BG4 data


DAT ' Compositing tables
              orgh
ppc_ptable01 ' priority table for modes 0 and 1
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_L|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_L|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_L|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKL_BG4_H|PMASKL_BG3_H|PMASKL_BG2_H|PMASKL_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)

ppc_ptable256 ' priority table for modes 2/5/6
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_L|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_L|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_L|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG4_H|PMASKH_BG3_H|PMASKH_BG2_H|PMASKH_BG1_H|PMASKx_SPR_3|PMASKx_BACKDROP)

ppc_ptable347 ' priority table for modes 3/4/7 (priority data for BG1 from BG4 - gets masked for mode7 (TODO))
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP) 
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP) 
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_L|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP) 
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP) 
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_L|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_0|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_1|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_2|PMASKx_BACKDROP)
long $10001*(PMASKH_BG1_H|PMASKH_BG2_H|PMASKx_SPR_3|PMASKx_BACKDROP)

ppc_skiptab01 ' Skip table for modes 0/1
long PSKIP_MAIN_BACK
long PSKIP_MAIN_BG4
long PSKIP_MAIN_BG3
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG4
long PSKIP_MAIN_BG3
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG2
long PSKIP_MAIN_BG1
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG2
long PSKIP_MAIN_BG1
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3
long PSKIP_SUB_BACK
long PSKIP_SUB_BG4
long PSKIP_SUB_BG3
long PSKIP_SUB_SPR
long PSKIP_SUB_BG4
long PSKIP_SUB_BG3
long PSKIP_SUB_SPR
long PSKIP_SUB_BG2
long PSKIP_SUB_BG1
long PSKIP_SUB_SPR
long PSKIP_SUB_BG2
long PSKIP_SUB_BG1
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3
long $10001*(PMASKL_BG1_L|PMASKL_BG1_H)
long $10001*(PMASKL_BG2_L|PMASKL_BG2_H)
long $10001*(PMASKL_BG3_L|PMASKL_BG3_H)
long $10001*(PMASKL_BG4_L|PMASKL_BG4_H)

ppc_skiptab234567  ' Skip table for modes 2/3/4/7
long PSKIP_MAIN_BACK
long PSKIP_MAIN_BG4H
long PSKIP_MAIN_BG2
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3H
long PSKIP_MAIN_BG1
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG4H
long PSKIP_MAIN_BG2
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3H
long PSKIP_MAIN_BG1
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3 ' ???
long PSKIP_SUB_BACK
long PSKIP_SUB_BG4H
long PSKIP_SUB_BG2
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3H
long PSKIP_SUB_BG1
long PSKIP_SUB_SPR
long PSKIP_SUB_BG4H
long PSKIP_SUB_BG2
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3H
long PSKIP_SUB_BG1
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3 ' ???
long $10001*(PMASKH_BG1_L|PMASKH_BG1_H)
long $10001*(PMASKH_BG2_L|PMASKH_BG2_H)
long $10001*(PMASKH_BG3_L|PMASKH_BG3_H)
long $10001*(PMASKH_BG4_L|PMASKH_BG4_H)

ppc_skiptab_dcolor ' Skip table for mode 3/4/7 direct color
long PSKIP_MAIN_BACK
long PSKIP_MAIN_BG4H
long PSKIP_MAIN_BG2
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3H
long PSKIP_MAIN_BG1D
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG4H
long PSKIP_MAIN_BG2
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3H
long PSKIP_MAIN_BG1D
long PSKIP_MAIN_SPR
long PSKIP_MAIN_BG3 ' ???
long PSKIP_SUB_BACK
long PSKIP_SUB_BG4H
long PSKIP_SUB_BG2
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3H
long PSKIP_SUB_BG1D
long PSKIP_SUB_SPR
long PSKIP_SUB_BG4H
long PSKIP_SUB_BG2
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3H
long PSKIP_SUB_BG1D
long PSKIP_SUB_SPR
long PSKIP_SUB_BG3 ' ???
long $10001*(PMASKH_BG1_L|PMASKH_BG1_H)
long $10001*(PMASKH_BG2_L|PMASKH_BG2_H)
long $10001*(PMASKH_BG3_L|PMASKH_BG3_H)
long $10001*(PMASKH_BG4_L|PMASKH_BG4_H)

DAT ' PPU Compositing

              orgh
ppc_init
              setq #ppc_rstart-1
              rdlong 0,##@ppc_cogcode

              '' LUT layout could be
              '' $000..$03F priority lookup (must live here or at the top)
              '' $040..$07F mosaic table
              '' $080..$0BF sprite buffer(?)
              '' $0C0..$1FF CODE
              setq2 #511 - 128
              rdlong ppc_lutcode-512,##@ppc_lutcode

              mov ppc_spr_pmask,##$10001*(PMASKx_SPR_0|PMASKx_SPR_1|PMASKx_SPR_2|PMASKx_SPR_3)
              decod ppc_col_pmask,#31

              ' debug!
              'setq #63
              wrlong ##$01010101,##layer_buffer+64
              wrlong ##$01010101,##layer_buffer+64 + 264*6

              'setq #63
              'wrlong ##$01010101,##layer_buffer
              'setq #63
              'wrlong ##$01010101,##layer_buffer+ 264*6

              jmp #ppc_lineloop

ppc_linesetup
              ' load registers
              rdlong ppc_mode,#ppu_mode
              rdlong ppc_through,#ppu_through
              rdlong ppc_winsel,#ppu_winsel
              rdlong ppc_winlog,#ppu_winlog
              rdlong ppc_win1_left,#ppu_winpos
              rdlong ppc_mathconfig,#ppu_mathconfig ' just need direct color flag from here

              ' convert video mode to bitmask
              mov ppc_tmp4,ppc_mode
              and ppc_tmp4,#7
              decod ppc_tmp4

              ' load mosaic table
              getnib ppc_tmp1,ppc_mode,#5 ' get mosaic size
              shr ppc_tmp1,#1 wc ' C = odd mosaic table entry
              loc pa,#mosaic_table
              mul ppc_tmp1,#256
        if_c  add pa,#2
              add pa,ppc_tmp1
              setq2 #63
              rdlong $040,pa
              ' set mosaic skip mask
              mov ppc_mosaicmask,ppc_mosaicon
              getnib ppc_tmp1,ppc_mode,#4 ' get mosaic layers
              skip ppc_tmp1
              bitnot ppc_mosaicmask,#(1+5*0) addbits 3
              bitnot ppc_mosaicmask,#(1+5*1) addbits 3
              bitnot ppc_mosaicmask,#(1+5*2) addbits 3
              bitnot ppc_mosaicmask,#(1+5*3) addbits 3

              ' convert through registers into layer nibbles
              mergeb ppc_through ' each nibble is %TSW_TS_TMW_TM

              ' Handle mode 0/1
              test ppc_tmp4,#%0000_0010 wc
              testb ppc_mode,#3 wz ' BG3 priority switch
    if_not_11 bmask ppc_layermask,#12 ' 13 lsbs set
        if_11 bmask ppc_layermask,#13 ' 14 lsbs set (original BG3_H is still active, but doesn't matter)
        if_c  setnib ppc_through,#0,#3 ' kill BG4
              loc pa,#ppc_ptable01
              mov ppc_sprpmask,#$3F
              mov ppc_bg1_tmask,#$0F
              mov ppc_bg2_tmask,#$0F
              mov ppc_bg3_tmask,#$03


              test ppc_tmp4,#%1111_1100 wc
        if_nc loc pb,#ppc_skiptab01
        if_c  loc pb,#ppc_skiptab234567

              ' Handle modes 2/5/6
              test ppc_tmp4,#%0110_0100 wc
        if_c  loc pa,#ppc_ptable256

              ' Handle modes 3/4/7
              test ppc_tmp4,#%1001_1000 wc
        if_c  loc pa,#ppc_ptable347
        if_c  mov ppc_bg1_tmask,#$FF
        if_nc mov ppc_pskip,#PSKIP_NON_8BPP
        if_nc mov ppc_bg1cmask,ppc_msbs
        if_c  mov ppc_pskip,#PSKIP_8BPP
        if_c  mov ppc_bg1cmask,#0
              testb ppc_mathconfig,#0 andc ' direct color
        if_c  loc pb,#ppc_skiptab_dcolor

        if_nc test ppc_tmp4,#%0000_0100 wc
        if_c  setbyte ppc_through,#0,#1 ' kill BG3 and BG4 for 2/3/4/7
              ' Modes 0/4 have 2bpp BG2
              test ppc_tmp4,#%0001_0001 wc
        if_c  mov ppc_bg2_tmask,#$03
              test ppc_tmp4,#%0000_0001 wc
        if_c  mov ppc_bg1_tmask,#$03

              rolword ppc_layermask,ppc_layermask,#0
              bith ppc_layermask,#31 ' need this to make color window work

              ' mode 5/6 adjust (bg3/4 are actually bg1/2 odd pixels)
              test ppc_tmp4,#%0110_0000 wc
        if_c  andn ppc_layermask,##PMASK_HIRES
        if_c  mov ppc_bg2_tmask,#$03
        if_c  mov ppc_bg3_tmask,#$0F
        if_c  setbyte ppc_winsel,ppc_winsel,#1
        if_c  setnib  ppc_winlog,ppc_winlog,#1
        if_c  setbyte ppc_through,ppc_through,#1
              ' mode 6
              test ppc_tmp4,#%0100_0000 wc
        if_c  setnib ppc_through,#0,#1 ' kill bg2
        if_c  setnib ppc_through,#0,#3 ' kill bg4

              ' read priority table
              setq2 #63
              rdlong $000,pa
              ' read skip tables and BG priority masks
              setq #(14+14+4)-1
              rdlong ppc_main_table,pb

              ' read layer data
              testb ppc_curline,#0 wc
        if_nc loc ptra,#layer_buffer
        if_c  loc ptra,#layer_buffer+6*(256+8)
              setq #63
              rdlong ppc_bg1buffer,ptra
              ' Actually, handle Mode7 oddities in here
              test ppc_tmp4,#%1000_0000 wc ' Mode 7 reads BG2 from BG1
        if_nc add ptra,#256+8
        if_c  mov ppc_sprpmask,#$33 ' mask out priority from BG3/BG4
        if_c  mov ppc_bg2_tmask,#$7F ' 7bpp weird EXTBG mask
              testb ppc_mode,#8+7 wz ' EXTBG flag
        if_10 setnib ppc_through,#0,#2 ' kill BG2 if m7 without extbg

              setq #63
              rdlong ppc_bg2buffer,ptra
              add ptra,#256+8
        if_c  add ptra,#256+8

              setq #63
              rdlong ppc_bg3buffer,ptra
              add ptra,#256+8

              setq #63
              rdlong ppc_bg4buffer,ptra
              add ptra,#256+8

              setq2 #63
              rdlong $080,ptra
              add ptra,#256+8

              setq #63
              rdlong ppc_sprpbuffer,ptra

              movbyts ppc_sprpmask,#%%0000
              setbyte ppc_bg1_tmask+3,ppc_bg1_tmask+0,#3
              setbyte ppc_bg1_tmask+2,ppc_bg1_tmask+0,#2
              setbyte ppc_bg1_tmask+1,ppc_bg1_tmask+0,#1
              setbyte ppc_bg2_tmask+3,ppc_bg2_tmask+0,#3
              setbyte ppc_bg2_tmask+2,ppc_bg2_tmask+0,#2
              setbyte ppc_bg2_tmask+1,ppc_bg2_tmask+0,#1
              setbyte ppc_bg3_tmask+3,ppc_bg3_tmask+0,#3
              setbyte ppc_bg3_tmask+2,ppc_bg3_tmask+0,#2
              setbyte ppc_bg3_tmask+1,ppc_bg3_tmask+0,#1

              mov ppc_winmasks+0,ppc_layermask
              mov ppc_winmasks+1,ppc_layermask
              mov ppc_winmasks+2,ppc_layermask
              mov ppc_winmasks+3,ppc_layermask

              'debug(ubin_long(ppc_layermask))
              'debug(uhex_reg_array(#ppc_bg1_pmask,#6))

              ' unpack window regs
              getbyte ppc_win2_right,ppc_win1_left,#3
              getbyte ppc_win2_left ,ppc_win1_left,#2
              getbyte ppc_win1_right,ppc_win1_left,#1
              getbyte ppc_win1_left ,ppc_win1_left,#0

              cmp ppc_win1_right,ppc_win1_left wc
        if_c  mov ppc_win1_left,#256 ' invalid window 1
              add ppc_win1_right,#1
              cmp ppc_win2_right,ppc_win2_left wc
        if_c  mov ppc_win2_left,#256 ' invalid window 2
              add ppc_win2_right,#1

              'debug(udec(ppc_win1_right,ppc_win1_left,ppc_win2_left,ppc_win2_right))

              mov ppc_winpos,#0
              mov ppc_winstat,#0

              testb ppc_curline,#0 wc
      if_c    loc pa,#composite_buffer
      if_nc   loc pa,#composite_buffer+512*2

              mov ppc_bgptr,#0
              mov ptra,#$040
              mov ptrb,#$080
              setd ppc_sprpptr,#ppc_sprpbuffer

                            '' window states init, (destroy ppc_winsel, ppc_winlog, ppc_through)
              setnib ppc_through,#%0011,#5 ' set TM/TMW for color "layer" so we can control mask MSB
        _ret_ sets ppc_tmp4,#ppc_bg1_pmask


              org 0
ppc_cogcode

ppc_lineloop
if TIME_COMPOSITE
              getct ppc_tmp1
              subr ppc_time,ppc_tmp1
              debug(sdec(ppc_time,ppc_tmp1,ppc_curline),dly(#100))
              getct ppc_time
end
              rdlong ppc_tmp1,#video_line_ctr
              cmp ppc_tmp1,ppc_curline wz
        if_z  jmp #ppc_lineloop
              mov ppc_curline,ppc_tmp1
              call #ppc_linesetup

              '' Prepare window masks

              'mov ppc_bg1buffer+0,#6 ' DEBUG
              rep @.winitloop,#6 ' 4 BGs + sprites + color
'.winitloop_ohno
              ' get mask
              alti ppc_tmp4,#%000_000_111
              mov ppc_tmp2,0-0
              getword ppc_tmp3,ppc_tmp2,#1 ' sub mask (low half)
              setword ppc_tmp2,#0,#0 ' main mask (high half)
              ' get logic
              rczr ppc_winlog wcz ' window logic (2 bits per layer)
              rczl ppc_winsel ' roll into window enable/invert flags (4 bits per layer)
              mov ppc_tmp1,ppc_winsel
              and ppc_tmp1,#63
              shr ppc_winsel,#6 ' discard guff
              'debug(udec(ppc_tmp1))
              altgn ppc_tmp1,#ppc_winlog_table
              getnib ppc_tmp1
              rolnib ppc_tmp1,ppc_tmp1,#0
              rczr ppc_through wcz ' C = TMW, Z = TM
    if_not_11 muxz ppc_tmp1,#%11110000 ' clear bits if TM=0, set bits if TM=1 && TMW=0
              rczr ppc_through wcz ' C = TSW, Z = TS
    if_not_11 muxz ppc_tmp1,#%00001111
              ' apply mask
              skip ppc_tmp1
              andn ppc_winmasks+0,ppc_tmp3 ' disable for sub when outside both windows
              andn ppc_winmasks+1,ppc_tmp3 ' disable for sub when inside window 1
              andn ppc_winmasks+2,ppc_tmp3 ' disable for sub when inside window 2
              andn ppc_winmasks+3,ppc_tmp3 ' disable for sub when inside both windows
              andn ppc_winmasks+0,ppc_tmp2 ' disable for main when outside both windows
              andn ppc_winmasks+1,ppc_tmp2 ' disable for main when inside window 1
              andn ppc_winmasks+2,ppc_tmp2 ' disable for main when inside window 2
              andn ppc_winmasks+3,ppc_tmp2 ' disable for main when inside both windows
              'debug(udec(ppc_bg1buffer+0),uhex_long(ppc_tmp1,ppc_tmp2,ppc_tmp3))
              'djnz ppc_bg1buffer+0,#.winitloop_ohno
.winitloop

              'getct ppc_tmp1
              'sub ppc_tmp1,ppc_time
              'debug("After setup ",udec(ppc_tmp1,ppc_winpos))
              'debug(uhex_reg_array(#ppc_winmasks,#4))
              'debug(uhex_reg_array(#ppc_bg3buffer,#5))
              'debug(uhex_reg_array(#ppc_bg4buffer,#5))
              'debug(ubin_long(ppc_mosaicmask,ppc_2bpp_tmask+0))

              wrfast #0,pa ' start FIFO
              jmp #ppc_winchange

ppc_winlog_table long $ffffffff, $aaaa5555, $ffffffff, $aaaa5555, $33333333, $96b26971, $cccccccc, $69e896d4

ppc_comp_entrypoints long ppc_pixel0,ppc_pixel1,ppc_pixel2,ppc_pixel3

' pixel value masks
ppc_2bpp_tmask  long $00_00_00_03,$00_00_03_00,$00_03_00_00,$03_00_00_00
ppc_4bpp_tmask  long $00_00_00_0F,$00_00_0F_00,$00_0F_00_00,$0F_00_00_00
'ppc_7bpp_tmask  long $00_00_00_7F,$00_00_7F_00,$00_7F_00_00,$7F_00_00_00
'ppc_8bpp_tmask  long $00_00_00_FF,$00_00_FF_00,$00_FF_00_00,$FF_00_00_00

ppc_msbs      long $80_80_80_80

ppc_n1        long $FF_FF_FF_FF
ppc_n256      long $FF_FF_FF_00

' these need to get color window flag set into them
ppc_srcid_bg      long $30_20_10_00 ' srcid for bgs
ppc_srcid_sprbd   long $60_40_5000  ' srcid for non-mathable sprites, mathable sprites and data for backdrop
ppc_sprbd_winmask long $80_80_8000

' BG data mask registers (mode-related)
ppc_bg1_tmask  long 0[4]
ppc_bg2_tmask  long 0[4]
ppc_bg3_tmask  long 0[4]

ppc_bgptr long 0
ppc_sprptr long ppc_spr << 19
ppc_sprpptr long ppc_sprp << 19
ppc_bg4buf_increment long ppc_bg4buffer + (1<<9)

ppc_mosaicon  long %00110_00110_00110_00110

ppc_rstart

'
ppc_mainsrc   res 1
ppc_subsrc    res 1
ppc_pppd      res 1

' pixel data registers
'ppc_backdrop  res 1 ' always zero
ppc_bg1       res 1
ppc_bg2       res 1
ppc_bg3       res 1
ppc_bg4       res 1
ppc_spr       res 1 ' MSBs always set
ppc_sprp      res 1 ' priority bits for sprites

' mode-related SKIPs
ppc_pskip      res 1

ppc_bg1cmask   res 1
ppc_sprpmask   res 1

ppc_main_table res 14
ppc_sub_table  res 14
' priority mask register array. BG entries load in with the skip table
ppc_bg1_pmask  res 1
ppc_bg2_pmask  res 1
ppc_bg3_pmask  res 1
ppc_bg4_pmask  res 1
ppc_spr_pmask  res 1
ppc_col_pmask  res 1 ' fake mask to control color window, should be 1<<31


ppc_layermask res 1
ppc_winmasks res 4

ppc_tmp1      res 1
ppc_tmp2      res 1
ppc_tmp3      res 1
ppc_tmp4      res 1
ppc_pbits     res 1
ppc_datout    res 1

ppc_time      res 1
ppc_curline   res 1

ppc_mode      res 1
ppc_through   res 1 ' TM/TMW/TS/TSW
ppc_winsel    res 1
ppc_winlog    res 1
ppc_mathconfig res 1

ppc_mosaicmask res 1

ppc_winremain res 1
ppc_winstat  res 1
ppc_winpos   res 1
ppc_win1_left res 1
ppc_win1_right res 1
ppc_win2_left res 1
ppc_win2_right res 1

ppc_bg1buffer res 64
ppc_bg2buffer res 64
ppc_bg3buffer res 64
ppc_bg4buffer res 64
'ppc_sprbuffer res 64
ppc_sprpbuffer res 64

              fit 502

              org $2C0
ppc_lutcode

ppc_pixel0
              rdlut ppc_tmp4,ptra++ wc ' mosaic table: MOVBYTS data + carryover flag
        if_nc setq ppc_n1   ' replace all pixels
        if_c  setq ppc_n256 ' keep lowest byte  (last post-mosaic pixel in last quad)
              skipf ppc_mosaicmask
              alts ppc_bgptr,#ppc_bg1buffer
              mov ppc_bg1,0-0  ' BG1 mosaic OFF
              movbyts ppc_bg1,#%%0123  ' ^
              muxq ppc_bg1,0-0 ' BG1 mosaic ON
              movbyts ppc_bg1,ppc_tmp4 ' ^

              alts ppc_bgptr,#ppc_bg2buffer
              mov ppc_bg2,0-0  ' BG2 mosaic OFF
              movbyts ppc_bg2,#%%0123  ' ^
              muxq ppc_bg2,0-0 ' BG2 mosaic ON
              movbyts ppc_bg2,ppc_tmp4 ' ^

              alts ppc_bgptr,#ppc_bg3buffer
              mov ppc_bg3,0-0  ' BG3 mosaic OFF
              movbyts ppc_bg3,#%%0123  ' ^
              muxq ppc_bg3,0-0 ' BG3 mosaic ON
              movbyts ppc_bg3,ppc_tmp4 ' ^

              alts ppc_bgptr,ppc_bg4buf_increment ' increment bgptr
              mov ppc_bg4,0-0  ' BG4 mosaic OFF
              movbyts ppc_bg4,#%%0123  ' ^
              muxq ppc_bg4,0-0 ' BG4 mosaic ON
              movbyts ppc_bg4,ppc_tmp4 ' ^

              ' sprites can not be mosaic'd
              rdlut ppc_spr,ptrb++
              alti ppc_sprpptr,#%100_111_000 ' etc
              movbyts ppc_sprp,#%%0123
              ' 41!
              ' but all buffers are now reverse-endian!!!
              ' except ppc_spr, but oh it's fine



               
              ' priority bit gathering madness, but madder
              ' sprp starts out with %xxSS_xxxx (from OAM)
              setq ppc_msbs
              muxq ppc_sprp,ppc_bg2 ' %2xSS_xxxx
              rol ppc_sprp,#1
              muxq ppc_sprp,ppc_bg1 ' %1SSx_xxx2
              ror ppc_sprp,#2
              muxq ppc_sprp,ppc_bg3 ' %321S_Sxxx
              ror ppc_sprp,#1
              muxq ppc_sprp,ppc_bg4 ' %4321_SSxx
              ror ppc_sprp,#2
              and ppc_sprp,ppc_sprpmask ' should now have %0043_21SS

              andn ppc_bg1,ppc_bg1cmask
              andn ppc_bg2,ppc_msbs
              andn ppc_bg3,ppc_msbs
              andn ppc_bg4,ppc_msbs
              or ppc_spr,ppc_msbs
              '' 41 + 15

              '' pixel 0

              '' there's effectively 14-ish priority levels that somehow map to layers
              '' we can actually process two of these at once
              getbyte ppc_tmp1,ppc_sprp,#3
              rdlut ppc_pbits,ppc_tmp1 ' load all active priority levels according to layer P bits
              and ppc_pbits,ppc_layermask ' mask with active layers (BG3 priority switch also happens here?)
              ' mask all layers with transparent pixels
              test ppc_spr,ppc_4bpp_tmask+0 wz ' sprite buffer is not reverse
        if_z  andn ppc_pbits,ppc_spr_pmask

              skipf ppc_pskip

              test ppc_bg1,ppc_bg1_tmask+3 wz
        if_z  andn ppc_pbits,ppc_bg1_pmask

              test ppc_bg2,ppc_bg2_tmask+3 wz
        if_z  andn ppc_pbits,ppc_bg2_pmask

              test ppc_bg3,ppc_bg3_tmask+3 wz
        if_z  andn ppc_pbits,ppc_bg3_pmask

              test ppc_bg4,ppc_2bpp_tmask+3 wz ' BG4 is always 2bpp
        if_z  andn ppc_pbits,ppc_bg4_pmask
              ' 29 cyc, 21 for 8bpp  (can skip BG3 and BG4)

              getnib ppc_pppd,ppc_bg4,#2*3 ' get %PPP0 when in 8bpp mode only (should this be in BG4 slot?)
              testb ppc_spr,#6+8*0 wc ' non-mathable sprite flag
              encod ppc_mainsrc,ppc_pbits
              rol ppc_pbits,#16
              encod ppc_subsrc,ppc_pbits
              ' 29 + 8, 21 + 10 for 8bpp

              '' Get main color
              altd ppc_mainsrc,#ppc_main_table-16
              skipf 0-0
        if_nc rolbyte ppc_datout,ppc_srcid_sprbd,#3 ' non-mathable sprite
        if_c  rolbyte ppc_datout,ppc_srcid_sprbd,#2 ' mathable sprite
              rolbyte ppc_datout,ppc_srcid_bg,#3
              rolbyte ppc_datout,ppc_srcid_bg,#2
              rolbyte ppc_datout,ppc_srcid_bg,#1
              rolbyte ppc_datout,ppc_srcid_bg,#0

              rolbyte ppc_datout,ppc_spr,#0 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#3
              rolbyte ppc_datout,ppc_bg3,#3
              rolbyte ppc_datout,ppc_bg2,#3
              rolbyte ppc_datout,ppc_bg1,#3

              rolword ppc_datout,ppc_srcid_sprbd,#0 ' backdrop

              setnib  ppc_datout,ppc_pppd,#2 ' direct color on
              bith    ppc_datout,#8 ' direct color on
              ' 10 cyc (14 for 8bpp)

              '' Get sub color
              altd ppc_subsrc,#ppc_sub_table-16
              skipf 0-0
              rolbyte ppc_datout,#0,#0   ' direct color off
              rolbyte ppc_datout,#$81,#0 ' direct color on

              rolbyte ppc_datout,ppc_spr,#0 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#3
              rolbyte ppc_datout,ppc_bg3,#3
              rolbyte ppc_datout,ppc_bg2,#3
              rolbyte ppc_datout,ppc_bg1,#3
              rolbyte ppc_datout,#0,#0   ' backdrop
              ' 8 cyc (10 for 8bpp)     

              wflong ppc_datout
              djz ppc_winremain,#ppc_winchange ' when current window region runs out!

              ' 29+8+10+8+4 or 21+10+14+10+4
              ' both 59 cyc, how nice

ppc_pixel1
              '' pixel 1

              '' there's effectively 14-ish priority levels that somehow map to layers
              '' we can actually process two of these at once
              getbyte ppc_tmp1,ppc_sprp,#2
              rdlut ppc_pbits,ppc_tmp1 ' load all active priority levels according to layer P bits
              and ppc_pbits,ppc_layermask ' mask with active layers (BG3 priority switch also happens here?)
              ' mask all layers with transparent pixels
              test ppc_spr,ppc_4bpp_tmask+1 wz ' sprite buffer is not reverse
        if_z  andn ppc_pbits,ppc_spr_pmask

              skipf ppc_pskip

              test ppc_bg1,ppc_bg1_tmask+2 wz
        if_z  andn ppc_pbits,ppc_bg1_pmask

              test ppc_bg2,ppc_bg2_tmask+2 wz
        if_z  andn ppc_pbits,ppc_bg2_pmask

              test ppc_bg3,ppc_bg3_tmask+2 wz
        if_z  andn ppc_pbits,ppc_bg3_pmask

              test ppc_bg4,ppc_2bpp_tmask+2 wz ' BG4 is always 2bpp
        if_z  andn ppc_pbits,ppc_bg4_pmask
              ' 29 cyc, 21 for 8bpp  (can skip BG3 and BG4)

              getnib ppc_pppd,ppc_bg4,#2*2 ' get %PPP0 when in 8bpp mode only (should this be in BG4 slot?)
              
              testb ppc_spr,#6+8*1 wc ' non-mathable sprite flag
              encod ppc_mainsrc,ppc_pbits
              rol ppc_pbits,#16
              encod ppc_subsrc,ppc_pbits
              ' 29 + 8, 21 + 10 for 8bpp

              '' Get main color
              altd ppc_mainsrc,#ppc_main_table-16
              skipf 0-0
        if_nc rolbyte ppc_datout,ppc_srcid_sprbd,#3 ' non-mathable sprite
        if_c  rolbyte ppc_datout,ppc_srcid_sprbd,#2 ' mathable sprite
              rolbyte ppc_datout,ppc_srcid_bg,#3
              rolbyte ppc_datout,ppc_srcid_bg,#2
              rolbyte ppc_datout,ppc_srcid_bg,#1
              rolbyte ppc_datout,ppc_srcid_bg,#0

              rolbyte ppc_datout,ppc_spr,#1 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#2
              rolbyte ppc_datout,ppc_bg3,#2
              rolbyte ppc_datout,ppc_bg2,#2
              rolbyte ppc_datout,ppc_bg1,#2

              rolword ppc_datout,ppc_srcid_sprbd,#0 ' backdrop

              setnib  ppc_datout,ppc_pppd,#2 ' direct color on
              bith    ppc_datout,#8 ' direct color on
              ' 10 cyc (14 for 8bpp)

              '' Get sub color
              altd ppc_subsrc,#ppc_sub_table-16
              skipf 0-0
              rolbyte ppc_datout,#0,#0   ' direct color off
              rolbyte ppc_datout,#$81,#0 ' direct color on

              rolbyte ppc_datout,ppc_spr,#1 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#2
              rolbyte ppc_datout,ppc_bg3,#2
              rolbyte ppc_datout,ppc_bg2,#2
              rolbyte ppc_datout,ppc_bg1,#2
              rolbyte ppc_datout,#0,#0   ' backdrop
              ' 8 cyc (10 for 8bpp)     

              wflong ppc_datout
              djz ppc_winremain,#ppc_winchange ' when current window region runs out!
ppc_pixel2
              '' pixel 2

              '' there's effectively 14-ish priority levels that somehow map to layers
              '' we can actually process two of these at once
              getbyte ppc_tmp1,ppc_sprp,#1
              rdlut ppc_pbits,ppc_tmp1 ' load all active priority levels according to layer P bits
              and ppc_pbits,ppc_layermask ' mask with active layers (BG3 priority switch also happens here?)
              ' mask all layers with transparent pixels
              test ppc_spr,ppc_4bpp_tmask+2 wz ' sprite buffer is not reverse
        if_z  andn ppc_pbits,ppc_spr_pmask

              skipf ppc_pskip

              test ppc_bg1,ppc_bg1_tmask+1 wz
        if_z  andn ppc_pbits,ppc_bg1_pmask

              test ppc_bg2,ppc_bg2_tmask+1 wz
        if_z  andn ppc_pbits,ppc_bg2_pmask

              test ppc_bg3,ppc_bg3_tmask+1 wz
        if_z  andn ppc_pbits,ppc_bg3_pmask

              test ppc_bg4,ppc_2bpp_tmask+1 wz ' BG4 is always 2bpp
        if_z  andn ppc_pbits,ppc_bg4_pmask
              ' 29 cyc, 21 for 8bpp  (can skip BG3 and BG4)

              getnib ppc_pppd,ppc_bg4,#2*1 ' get %PPP0 when in 8bpp mode only (should this be in BG4 slot?)
              
              testb ppc_spr,#6+8*2 wc ' non-mathable sprite flag
              encod ppc_mainsrc,ppc_pbits
              rol ppc_pbits,#16
              encod ppc_subsrc,ppc_pbits
              ' 29 + 8, 21 + 10 for 8bpp

              '' Get main color
              altd ppc_mainsrc,#ppc_main_table-16
              skipf 0-0
        if_nc rolbyte ppc_datout,ppc_srcid_sprbd,#3 ' non-mathable sprite
        if_c  rolbyte ppc_datout,ppc_srcid_sprbd,#2 ' mathable sprite
              rolbyte ppc_datout,ppc_srcid_bg,#3
              rolbyte ppc_datout,ppc_srcid_bg,#2
              rolbyte ppc_datout,ppc_srcid_bg,#1
              rolbyte ppc_datout,ppc_srcid_bg,#0

              rolbyte ppc_datout,ppc_spr,#2 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#1
              rolbyte ppc_datout,ppc_bg3,#1
              rolbyte ppc_datout,ppc_bg2,#1
              rolbyte ppc_datout,ppc_bg1,#1

              rolword ppc_datout,ppc_srcid_sprbd,#0 ' backdrop

              setnib  ppc_datout,ppc_pppd,#2 ' direct color on
              bith    ppc_datout,#8 ' direct color on
              ' 10 cyc (14 for 8bpp)

              '' Get sub color
              altd ppc_subsrc,#ppc_sub_table-16
              skipf 0-0
              rolbyte ppc_datout,#0,#0   ' direct color off
              rolbyte ppc_datout,#$81,#0 ' direct color on

              rolbyte ppc_datout,ppc_spr,#2 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#1
              rolbyte ppc_datout,ppc_bg3,#1
              rolbyte ppc_datout,ppc_bg2,#1
              rolbyte ppc_datout,ppc_bg1,#1
              rolbyte ppc_datout,#0,#0   ' backdrop
              ' 8 cyc (10 for 8bpp)     

              wflong ppc_datout
              djz ppc_winremain,#ppc_winchange ' when current window region runs out!

ppc_pixel3
              '' pixel 3

              '' there's effectively 14-ish priority levels that somehow map to layers
              '' we can actually process two of these at once
              getbyte ppc_tmp1,ppc_sprp,#0
              rdlut ppc_pbits,ppc_tmp1 ' load all active priority levels according to layer P bits
              and ppc_pbits,ppc_layermask ' mask with active layers (BG3 priority switch also happens here?)
              ' mask all layers with transparent pixels
              test ppc_spr,ppc_4bpp_tmask+3 wz ' sprite buffer is not reverse
        if_z  andn ppc_pbits,ppc_spr_pmask

              skipf ppc_pskip

              test ppc_bg1,ppc_bg1_tmask+0 wz
        if_z  andn ppc_pbits,ppc_bg1_pmask

              test ppc_bg2,ppc_bg2_tmask+0 wz
        if_z  andn ppc_pbits,ppc_bg2_pmask

              test ppc_bg3,ppc_bg3_tmask+0 wz
        if_z  andn ppc_pbits,ppc_bg3_pmask

              test ppc_bg4,ppc_2bpp_tmask+0 wz ' BG4 is always 2bpp
        if_z  andn ppc_pbits,ppc_bg4_pmask
              ' 29 cyc, 21 for 8bpp  (can skip BG3 and BG4)

              getnib ppc_pppd,ppc_bg4,#2*0 ' get %PPP0 when in 8bpp mode only (should this be in BG4 slot?)
              
              testb ppc_spr,#6+8*3 wc ' non-mathable sprite flag
              encod ppc_mainsrc,ppc_pbits
              rol ppc_pbits,#16
              encod ppc_subsrc,ppc_pbits
              ' 29 + 8, 21 + 10 for 8bpp

              '' Get main color
              altd ppc_mainsrc,#ppc_main_table-16
              skipf 0-0
        if_nc rolbyte ppc_datout,ppc_srcid_sprbd,#3 ' non-mathable sprite
        if_c  rolbyte ppc_datout,ppc_srcid_sprbd,#2 ' mathable sprite
              rolbyte ppc_datout,ppc_srcid_bg,#3
              rolbyte ppc_datout,ppc_srcid_bg,#2
              rolbyte ppc_datout,ppc_srcid_bg,#1
              rolbyte ppc_datout,ppc_srcid_bg,#0

              rolbyte ppc_datout,ppc_spr,#3 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#0
              rolbyte ppc_datout,ppc_bg3,#0
              rolbyte ppc_datout,ppc_bg2,#0
              rolbyte ppc_datout,ppc_bg1,#0

              rolword ppc_datout,ppc_srcid_sprbd,#0 ' backdrop

              setnib  ppc_datout,ppc_pppd,#2 ' direct color on
              bith    ppc_datout,#8 ' direct color on
              ' 10 cyc (14 for 8bpp)

              '' Get sub color
              altd ppc_subsrc,#ppc_sub_table-16
              skipf 0-0
              rolbyte ppc_datout,#0,#0   ' direct color off
              rolbyte ppc_datout,#$81,#0 ' direct color on

              rolbyte ppc_datout,ppc_spr,#3 ' sprite buffer is not reverse
              rolbyte ppc_datout,ppc_bg4,#0
              rolbyte ppc_datout,ppc_bg3,#0
              rolbyte ppc_datout,ppc_bg2,#0
              rolbyte ppc_datout,ppc_bg1,#0
              rolbyte ppc_datout,#0,#0   ' backdrop
              ' 8 cyc (10 for 8bpp)     

              wflong ppc_datout

              djnz ppc_winremain,#ppc_pixel0
              cmp ppc_winpos,#256 wc
        if_ae jmp #ppc_lineloop ' scanline done
ppc_winchange
              ' load layer mask / color window for next window region
              alts ppc_winstat,#ppc_winmasks
              mov ppc_layermask,0-0 wc ' Mask MSB has color window flag
              muxc ppc_srcid_bg,ppc_msbs
              muxc ppc_srcid_sprbd,ppc_sprbd_winmask
              ' update window state machine
              cmp ppc_win2_left,ppc_win1_left wc ' C = W2 comes first (could detect Z here, but that makes it more complex)
        if_c  skipf #%1111_1
              skipf #%1111_0000
              mov ppc_winremain,ppc_win1_left
              mov ppc_win1_left,ppc_win1_right
              mov ppc_win1_right,#256
              xor ppc_winstat,#1
              mov ppc_winremain,ppc_win2_left
              mov ppc_win2_left,ppc_win2_right
              mov ppc_win2_right,#256
              xor ppc_winstat,#2

              sub ppc_winremain,ppc_winpos wz

              'debug(udec(ppc_winpos,ppc_winremain,ppc_winstat,ppc_win1_right,ppc_win1_left,ppc_win2_left,ppc_win2_right))
        if_z  jmp #ppc_winchange ' zero-length region

              ' old winpos needs to select next entry point
              mov ppc_tmp1,ppc_winpos
              and ppc_tmp1,#%11

              'debug(udec(ppc_mainsrc,ppc_subsrc),uhex_long(ppc_datout),ubin_long(ppc_pbits))
              'debug(uhex_long(ppc_bg4),ubin_long(ppc_layermask))
           
              'debug(ubin_long(ppc_main_table+0,ppc_sub_table+0))
              'debug(udec(ppc_winpos,ppc_winremain),uhex_long(ppc_srcid_sprbd),ubin_long(ppc_layermask))

              add ppc_winpos,ppc_winremain

              altd ppc_tmp1,#ppc_comp_entrypoints
              jmp 0-0

              fit 1024

DAT ' PPU Color Math

              org

              ' TAKING STOCK:
              ' priority circuit generates 512 pixels per line
              ' even are "sub", odd pixels are "main" (and use a different set of mask registers)
              ' color math runs on every pixel, but in lowres modes only main/odd pixels are visible
              ' color window and inhibit states only update on main/odd pixels
              '  - pixel 0 state may thus be undefined (BSNES sets everything as if previous pixels were all transparent)
              ' color window can, in any in/out combination
              '  - black out current color (CGWSEL[8..7])
              '  - inhibit color math (CGWSEL[6..5])
              ' color math is also inhibited based on main/odd pixel's layer (CDADSUB[5..0])
              ' color math is either with previous pixel or fixed color (CGWSEL[1]).
              ' when mathing with previous color and THE PREVIOUS EVEN PIXEL (either x-1 or x-2) was backdrop, pixels are
              '  instead mathed with the fixed color (really, BSNES?)
              ' half math flag is additionally inhibited (only update on odd pixel!):
              '  - when window is blacking out current color
              '  - when CGWSEL[1] is set and prev. color is replaced with fixed color (see above)
              ' at the very end, pixels are multiplied with INIDISP[3..0] (on real PPUs, this is an analog effect)

              ' our priority compositor outputs 32 bits per pixel pair in curious format
              ' we need to always output 512 truecolor pixels to the video driver, all effects applied


              ' odd/even are more natural to loop than even/odd
              ' will need 1 dummy iteration?

              ' due to need of inserting REP compensation NOPs
              ' a separate loop is used depending on CGADSUB[7] (add/sub mode)

              ' low LUT is reloaded with palette on each line
              ' high LUT always holds direct color lookup

              ' need following registers:
              ' $2130: CGWSEL
              ' $2131: CGADSUB
              ' $2100: INIDISP
              ' $2133: SETINI (hires flag)
              ' $2105: BGMODE (hires flag)
              ' current fixed color
ppm_entry
              setpix #%010_010 ' both blend factors PIV
              ' set unused table positions to prevent freak accidents
              mov ppm_skip_table+7,ppm_skip_blank
              mov ppm_skip_table+15,ppm_skip_blank
              setq2 #255
              rdlong 256,##dcolor_table

ppm_lineloop
if TIME_CMATH
              getct ppm_tmp1
              subr ppm_time,ppm_tmp1
              debug(sdec(ppm_time,ppm_tmp1,ppm_curline),dly(#100))
              getct ppm_time
end
              rdlong ppm_tmp1,#video_line_ctr
              cmp ppm_tmp1,ppm_curline wz
        if_z  jmp #ppm_lineloop

              mov ppm_curline,ppm_tmp1
              rczr ppm_tmp1 wcz

        if_nz loc pa,#palette_ring
        if_z  loc pa,#palette_ring+1024
              setq2 #255
              rdlong 0,pa ' load palette

        if_z  loc ptra,#scanout_buffer
        if_nz loc ptra,#scanout_buffer+512*4
              rdlong ppm_config,#ppu_mathconfig ' CGWSEL in byte 0, CGADSUB in byte 1, INIDISP in byte 2
              rdlong ppm_mode,#ppu_mode ' BGMODE in byte 0, SETINI in byte 1
              rdlong ppm_fixedcol,#ppu_fixedcolor

              ' start count of init cycles here
              setbyte ppm_fixedcol,#1,#0 ' always set a bit so we can force NZ
        if_nz rdfast ppm_bit31,ppm_cbuf_even
        if_z  rdfast ppm_bit31,ppm_cbuf_odd

              ' CGWSEL[1] set: use subscreen, if backdrop use fixed and inhibit halving
              ' CGWSEL[1] clear: use fixed color, always halve
              testb ppm_config,#1 wc
              muxnc ppm_fc0,ppm_fcmodmask
              muxnc ppm_fc1,ppm_fcmodmask
              muxnc ppm_fc2,ppm_fcmodmask
              muxnc ppm_fc3,ppm_fcmodmask

              ' global brightness and f-blank
              ' 32.times.map{((_1<<3)*((15*281)>>5)*2+255)>>8}
              testb ppm_config,#23 wc
              getnib ppm_tmp1,ppm_config,#4
        if_nc mul ppm_tmp1,#281
              shr ppm_tmp1,#5
              setpiv ppm_tmp1

              ' Is hires mode?
              test ppm_mode,#%100 wc ' C set if mode >= 4
        if_c  test ppm_mode,#%011 wc ' C set for mode 5 and 6
              testb ppm_mode,#3+8 orc ' pseudo hires flag
        if_c  mov ppm_tmp2,ppm_skip_hires
        if_nc mov ppm_tmp2,ppm_skip_lores
        if_c  neg ppm_wrptr,#1
        if_nc neg ppm_wrptr,#2
              ' intialize into skip masks
              mov ppm_skip_outside,ppm_tmp2
              mov ppm_skip_outside_math,ppm_tmp2
              mov ppm_skip_inside,ppm_tmp2
              mov ppm_skip_inside_math,ppm_tmp2

              testb ppm_config,#15 wc ' C = subtract
              testb ppm_config,#14 wz ' Z = half flag
              ' only MATH and MATH+BLANK are different between ADD/SUB modes
 if_nz_and_c  mov ppm_tmp2,ppm_skip_math_sub
 if_nz_and_nc mov ppm_tmp2,ppm_skip_math_add
        if_z  mov ppm_tmp2,ppm_skip_math_half
        if_c  mov ppm_tmp3,ppm_skip_blank ' sub from blanked pixel is same as just blank
        if_nc mov ppm_tmp3,ppm_skip_math_blank_add
        if_c  mov ppm_loopfunc,#ppm_subloop
        if_nc mov ppm_loopfunc,#ppm_addloop

              testb ppm_config,#6 wc ' outside blank flag
              testb ppm_config,#4 wz ' outside math inhibit flag
        if_0x or ppm_skip_outside,ppm_skip_normal
        if_1x or ppm_skip_outside,ppm_skip_blank
        if_x1 mov ppm_skip_outside_math,ppm_skip_outside
        if_00 or ppm_skip_outside_math,ppm_tmp2
        if_10 or ppm_skip_outside_math,ppm_tmp3

              testb ppm_config,#7 wc ' inside blank flag
              testb ppm_config,#5 wz ' inside math inhibit flag
        if_0x or ppm_skip_inside,ppm_skip_normal
        if_1x or ppm_skip_inside,ppm_skip_blank
        if_x1 mov ppm_skip_inside_math,ppm_skip_inside
        if_00 or ppm_skip_inside_math,ppm_tmp2
        if_10 or ppm_skip_inside_math,ppm_tmp3

              getbyte ppm_tmp1,ppm_config,#1
              mov ppm_tmp2,#0
              mov ppm_skip_table+6,ppm_skip_outside ' for masked sprite source
              mov ppm_skip_table+14,ppm_skip_inside ' ^^
              ' 51 op
              
              rep #7,#6
              shr ppm_tmp1,#1 wc ' layer's math enable flag
        if_c  skipf #%100_100_0 ' TODO: does SKIPF work when skipping the last instruction?
        if_nc skipf #%010_010
              altd ppm_tmp2,#ppm_skip_table
              mov 0-0,ppm_skip_outside_math
              mov 0-0,ppm_skip_outside
              altd ppm_tmp2,ppm_wrskip8_inc
              mov 0-0,ppm_skip_inside_math
              mov 0-0,ppm_skip_inside
              ' REP LOOP END, 7 OPS
              ' 7*6+1 = 43
              ' 51+43 ops = 188 cycles

              'debug(ubin_reg_array(#ppm_skip_table,#16))

              ' do dummy odd pixel and first real even pixel
              ' in hires mode we are at pxbuffer-1, in lores at pxbuffer-2
              mov ppm_odddat,ppm_dummydat
              modz _set wz
              alts ppm_loopfunc,#2 ' skip over REP and RFWORD
              call #\0 ' 78+8 = 86 cycles
              add ppm_wrptr,#128
              ' 1 hires, 0 lores
              call ppm_loopfunc ' one loop call is 5130 = 80*64+10 cycles
              ' 129 hires, 128 lores
              setq #127
              wrlong ppm_pxbuffer,ptra++ ' 3+7+128 = 138 cycles worst case
              mov ppm_pxbuffer+0,ppm_pxbuffer+128 ' move extra pixel for hires

              call ppm_loopfunc
              setq #127
              wrlong ppm_pxbuffer,ptra++
              mov ppm_pxbuffer+0,ppm_pxbuffer+128 ' move extra pixel for hires

              call ppm_loopfunc
              setq #127
              wrlong ppm_pxbuffer,ptra++
              mov ppm_pxbuffer+0,ppm_pxbuffer+128 ' move extra pixel for hires


              'debug(uhex_long(ppm_odddat,ppm_evendat))

              call ppm_loopfunc
              setq #127
              wrlong ppm_pxbuffer,ptra++

              'setq2 #255 ' DEBUG
              'wrlong 0,ptra++   ' DEBUG

              ' 271 cycles palette load
              ' 188+ spent in setup
              ' 10 ALU -> 20 cycles
              ' 1 dummy -> 86 cycles
              ' 4 loops -> 20520 cycles
              ' 4 writes -> 548 cycles
              ' 271+200+20+86+20520+548 = 21757 cycles
              ' ~179 left for additional overhead (21824 total)

              ' phew, done.
              jmp #ppm_lineloop
              

ppm_addloop
              rep #29,#64 ' always 29 ops regardless of skip

              ' odd:  %WSSS_PPPD_IIII_IIII
              ' D is direct color flag
              ' PPP is direct color "palette"
              ' SSS is source ID
              ' W is color window state
              rfword ppm_odddat
              rdlut ppm_oddcol,ppm_odddat
              getnib ppm_src,ppm_odddat,#3
              getnib ppm_pppd,ppm_odddat,#2
              alts ppm_pppd,#ppm_dcolor_odd_tbl ' even somewheres are zero
              or ppm_oddcol,0-0
              altd ppm_src,#ppm_skip_table
              skipf 0-0
              ' 17 cyc
ppm_fc0 if_z  mov ppm_evencol,ppm_fixedcol ' self-modify condition and WZ bit
              ' we overwrite evencol here so oddcol is valid for next color math
              ' a : NO MATH
              ' b : NO MATH + BLANK
              ' c : MATH
              ' d : MATH + BLANK
              ' e : MATH + HALF                                         a b c d e
        if_nz shr ppm_evencol,#1 ' ADD + HALF                                   x
        if_nz shr ppm_oddcol,#1  ' ADD + HALF                                 x x
              addpix ppm_evencol,ppm_oddcol ' skip if window blanking       x   x
        if_nz shl ppm_oddcol,#1  ' ADD + HALF                                 x x
              mov ppm_evencol,ppm_oddcol ' SKIP unless math skipped     x        
              mov ppm_evencol,#0 ' SKIP unless (no math AND blanking)     x      
              nop ' REP compensator                                     x x x x  
              nop ' REP compensator                                     x x x x  
              nop ' REP compensator                                     x x x 

              and ppm_evencol,ppm_cmask ' always
              ' 17 + 17 cyc

              altr ppm_wrptr,ppm_pxwrite ' auto increment ALTR
              mixpix ppm_evencol,ppm_evencol ' PIV set to INIDISP-derived value
              altr ppm_wrptr,ppm_pxwrite     ' LOWRES only
              mixpix ppm_evencol,ppm_evencol ' LOWRES only
              ' 17 + 17 + 9 (assuming hires)

              ' even: %Dxxx_xxxD_IIII_IIII
              ' yes, two direct color flags
              ' (we already have a PPPx)
              rfword ppm_evendat wc
              rdlut ppm_evencol,ppm_evendat
        if_c  alts ppm_pppd,#ppm_dcolor_always_tbl ' in this table ignore LSB
        if_c  or ppm_evencol,0-0
              ' 17 + 17 + 9 + 9

ppm_fc1 if_z  mov ppm_oddcol,ppm_fixedcol ' self-modify condition
              ' we overwrite ppm_oddcol here so evencol is valid for next color math
              ' a : NO MATH
              ' b : NO MATH + BLANK
              ' c : MATH
              ' d : MATH + BLANK
              ' e : MATH + HALF                                         a b c d e
        if_nz shr ppm_oddcol,#1 ' ADD + HALF                                    x
        if_nz shr ppm_evencol,#1  ' ADD + HALF                                x x
              addpix ppm_oddcol,ppm_evencol ' skip if window blanking       x   x
        if_nz shl ppm_evencol,#1  ' ADD + HALF                                x x
              mov ppm_oddcol,ppm_evencol ' SKIP unless math skipped     x        
              mov ppm_oddcol,#0 ' SKIP unless (no math AND blanking)      x      
              nop ' REP compensator                                     x x x x  
              nop ' REP compensator                                     x x x x  
              nop ' REP compensator                                     x x x      

              and ppm_oddcol,ppm_cmask
              ' 17 + 17 + 9 + 9 + 17
              altr ppm_wrptr,ppm_pxwrite ' HIGHRES only
              mixpix ppm_oddcol,ppm_oddcol ' HIGHRES only

              test ppm_evendat,#$FF wz ' backdrop check
              ' 17 + 17 + 9 + 9 + 17 + 11
        _ret_ sub ppm_wrptr,#128


ppm_subloop
              rep #29,#64
              ' odd:  %WSSS_PPPD_IIII_IIII
              ' D is direct color flag
              ' PPP is direct color "palette"
              ' SSS is source ID
              ' W is color window state
              rfword ppm_odddat
              ' work odd pixel and load SKIP pattern
              rdlut ppm_oddcol,ppm_odddat
              getnib ppm_src,ppm_odddat,#3
              getnib ppm_pppd,ppm_odddat,#2
              alts ppm_pppd,#ppm_dcolor_odd_tbl ' even somewheres are zero
              or ppm_oddcol,0-0
              altd ppm_src,#ppm_skip_table
              skipf 0-0
              ' 17
ppm_fc2 if_z  mov ppm_evencol,ppm_fixedcol ' self-modify condition and WZ bit
              ' we overwrite evencol here so oddcol is valid for next color math
              ' a : NO MATH
              ' b : NO MATH + BLANK
              ' c : MATH
              ' d : MATH + BLANK (same as blank?)
              ' e : MATH + HALF                                         a b c d e  
              not ppm_tmp1, ppm_oddcol ' SUB                                x   x
              addpix ppm_evencol,ppm_tmp1 ' skip if window blanking         x   x
              not ppm_evencol    ' SUB                                      x   x
        if_nz shr ppm_evencol,#1 ' SUB + HALF                                   x
              mov ppm_evencol,ppm_oddcol ' SKIP unless math skipped     x        
              mov ppm_evencol,#0 ' SKIP unless (no math AND blanking)     x   x  
              nop ' REP compensator                                     x x x x  
              nop ' REP compensator                                     x x   x  
              nop ' REP compensator                                     x x   x   

              and ppm_evencol,ppm_cmask
              ' 17 + 17

              altr ppm_wrptr,ppm_pxwrite ' auto increment ALTR
              mixpix ppm_evencol,ppm_evencol ' PIV set to INIDISP-derived value
              altr ppm_wrptr,ppm_pxwrite     ' LOWRES only
              mixpix ppm_evencol,ppm_evencol ' LOWRES only
              ' 17 + 17 + 9 (assuming hires)

              ' even: %Dxxx_xxxD_IIII_IIII
              ' yes, two direct color flags
              ' (we already have a PPPx)
              rfword ppm_evendat wc
              rdlut ppm_evencol,ppm_evendat
        if_c  alts ppm_pppd,#ppm_dcolor_always_tbl ' in this table ignore LSB
        if_c  or ppm_evencol,0-0
              ' 17 + 17 + 9 + 9

ppm_fc3 if_z  mov ppm_oddcol,ppm_fixedcol ' self-modify condition
              ' we overwrite ppm_oddcol here so evencol is valid for next color math
              ' a : NO MATH
              ' b : NO MATH + BLANK
              ' c : MATH
              ' d : MATH + BLANK
              ' e : MATH + HALF                                         a b c d e  
              not ppm_tmp1,ppm_evencol ' SUB                                x   x
              addpix ppm_oddcol,ppm_tmp1 ' skip if window blanking          x   x
              not ppm_oddcol    ' SUB                                       x   x
        if_nz shr ppm_oddcol,#1 ' SUB + HALF                                    x
              mov ppm_oddcol,ppm_evencol ' SKIP unless math skipped     x        
              mov ppm_oddcol,#0 ' SKIP unless (no math AND blanking)      x   x  
              nop ' REP compensator                                     x x x x  
              nop ' REP compensator                                     x x   x  
              nop ' REP compensator                                     x x   x   

              and ppm_oddcol,ppm_cmask
              ' 17 + 17 + 9 + 9 + 17
              altr ppm_wrptr,ppm_pxwrite ' HIGHRES
              mixpix ppm_oddcol,ppm_oddcol ' HIGHRES

              test ppm_evendat,#$FF wz ' backdrop check
              ' 17 + 17 + 9 + 9 + 17 + 11
        _ret_ sub ppm_wrptr,#128



ppm_fcmodmask   long %0101_0000000_010_000000000_000000000 ' if OR'd set if_always and WZ, if ANDN'd, set if_z

ppm_wrskip8_inc long ppm_skip_table+8 + 1<<9

ppm_pxwrite     long ppm_pxbuffer + 1<<9
ppm_dummydat    long $5_0_00 ' backdrop+outside pixel

ppm_skip_hires          long %00_0_000000000_0_0000_1100_0_000000000_0
ppm_skip_lores          long %11_0_000000000_0_0000_0000_0_000000000_0

ppm_skip_normal         long %00_0_000101111_0_0000_0000_0_000101111_0
ppm_skip_blank          long %00_0_000011111_0_0000_0000_0_000011111_0
ppm_skip_math_add       long %00_0_000111011_0_0000_0000_0_000111011_0
ppm_skip_math_sub       long %00_0_110111000_0_0000_0000_0_110111000_0
ppm_skip_math_blank_add long %00_0_100110101_0_0000_0000_0_100110101_0
                        ' sub from blanked pixel is same as just blank
ppm_skip_math_half      long %00_0_111110000_0_0000_0000_0_111110000_0

ppm_cbuf_even           long @composite_buffer
ppm_cbuf_odd            long @composite_buffer+512*2

ppm_512           long 512
ppm_2048          long 2048

ppm_dcolor_always_tbl
                  long $00_00_00_00[2]
                  long $10_00_00_00[2]
                  long $00_10_00_00[2]
                  long $10_10_00_00[2]
                  long $00_00_20_00[2]
                  long $10_00_20_00[2]
                  long $00_10_20_00[2]
                  long $10_10_20_00[2]
ppm_dcolor_odd_tbl
                  long 0, $00_00_00_00
                  long 0, $10_00_00_00
                  long 0, $00_10_00_00
                  long 0, $10_10_00_00
                  long 0, $00_00_20_00
                  long 0, $10_00_20_00
                  long 0, $00_10_20_00
                  long 0, $10_10_20_00



ppm_cmask long $F8F8F800

ppm_bit31 long negx

ppm_skip_table    res 7
                  res 1 ' unused!
                  res 7
                  res 1 ' unused!

                  res 2 ' space for dummy pickles
ppm_pxbuffer      res 128 
                  res 1

ppm_evendat res 1
ppm_odddat res 1
ppm_evencol res 1
ppm_oddcol res 1

ppm_src  res 1
ppm_pppd  res 1
ppm_wrptr res 1

ppm_skip_outside      res 1
ppm_skip_outside_math res 1
ppm_skip_inside       res 1
ppm_skip_inside_math  res 1

ppm_tmp1  res 1
ppm_tmp2  res 1
ppm_tmp3  res 1

ppm_time res 1
ppm_curline res 1

ppm_loopfunc res 1
ppm_config  res 1 ' CGWSEL in byte 0, CGADSUB in byte 1, INIDISP in byte 2
ppm_mode    res 1 ' BGMODE in byte 0, SETINI in byte 1
ppm_fixedcol res 1

                    fit 496

CON ' S-DSP constants

DSP_SAMPLE_RATE = 32_000

DAC_SCALE = $FF00
DAC_CENTER = DAC_SCALE/2
DAC_SCAS = DAC_SCALE/4


DSP_CHANNEL_SIZE = DSP_RWLONGS+DSP_RDLONGS
DSP_RWLONGS = 8+5
DSP_RDLONGS = 3

{{
              ' read/write
dsp_sbuf      res 8 ' decode buffer for current channel
dsp_brrbase   res 1 ' current BRR header pointer
dsp_gausspos  res 1 ' inter-sample position
dsp_envlvl    res 1 ' envelope level
dsp_output    res 1 ' output level
dsp_envstat   res 1 ' envelope state machine

              ' read only
dsp_pitch     res 1 ' pitch
dsp_cvol      res 1 ' channel left/right volume in byte 1/3 (others zero)
dsp_src_adsr_gain res 1 ' SRCN,ADSR and GAIN registers
}}

#0,ENV_ATTACK,ENV_DECAY,ENV_SUSTAIN,ENV_RELEASE

CON ' SPC700 constants

SP_AMOP = 1<<10

SP_AMODE_A_IMM  =SP_AMOP |  0<<28 ' A,#imm
SP_AMODE_A_DP   =SP_AMOP |  1<<28 ' A,dp
SP_AMODE_A_DPX  =SP_AMOP |  2<<28 ' A,dp+X
SP_AMODE_A_XI   =SP_AMOP |  3<<28 ' A,(X)
SP_AMODE_A_ABS  =SP_AMOP |  4<<28 ' A,!a
SP_AMODE_A_ABSX =SP_AMOP |  5<<28 ' A,!a+X
SP_AMODE_A_ABSY =SP_AMOP |  6<<28 ' A,!a+Y
SP_AMODE_A_DPXI =SP_AMOP |  7<<28 ' A,[dp+X]
SP_AMODE_A_DPIY =SP_AMOP |  8<<28 ' A,[dp]+Y
SP_AMODE_XI_YI  =SP_AMOP |  9<<28 ' (X),(Y)
SP_AMODE_DP_DP  =SP_AMOP | 10<<28 ' dd,ds
SP_AMODE_DP_IMM =SP_AMOP | 11<<28 ' dp,#imm
' These don't set up a destination
SP_AMODE_U_IMM  =SP_AMOP | 12<<28 ' ?,#imm
SP_AMODE_U_DP   =SP_AMOP | 13<<28 ' ?,dp
SP_AMODE_U_DPX  =SP_AMOP | 14<<28 ' ?,dp+X
SP_AMODE_U_ABS  =SP_AMOP | 15<<28 ' ?,!a

'' NVPB_HIZC
SP_CARRY_BIT = 0
SP_ZERO_BIT  = 1
SP_IRQ_BIT   = 2
SP_HALF_BIT  = 3
SP_BREAK_BIT = 4
SP_PAGE_BIT  = 5
SP_OVER_BIT  = 6
SP_NEG_BIT   = 7


DAT ' SPCcog cog code
              orgh
sp_cogblob
              org 0
sp_nextop
              jse1 #dsp_dosample
              tjs sp_cycles,#sp_nextop
              'tjs sp_cycles,#dsp_dosample ' For debugging
              'nop
              'nop

              'debug("---  NVPBHIZC")
              'debug("PSW: ",ubin_byte_(sp_psw)," PC: ",uhex_word_(sp_pc), " SP: ",uhex_byte_(sp_sp),sdec(sp_cycles))
              'debug("X: ",uhex_byte_(sp_x)," Y: ",uhex_byte_(sp_y)," A: ",uhex_byte_(sp_a))
              'debug(dly(#50))
              call #sp_readcode
              'mov pa,sp_pc
              'decmod pa,sp_FFFFh
              'debug("PC: ",uhex_word_(pa)," OP: ",uhex_byte_(sp_memv)," A: ",uhex_byte_(sp_a)," X: ",uhex_byte_(sp_x)," Y: ",uhex_byte_(sp_y)," SP: ",uhex_byte_(sp_sp))
              mov sp_opcode,sp_memv
              'debug(uhex_byte(sp_opcode))
              rdlut sp_opimpl,sp_opcode
              'debug(uhex_long(sp_opimpl))
              push #sp_nextop
              bitl  sp_opimpl,#10 wcz
        if_nc execf sp_opimpl
              getnib pa,sp_opimpl,#7
              altd pa,#sp_amode_tbl
              skipf 0-0
              setnib sp_opimpl,#0,#7
              ' All the complex addressing modes are handled here
              ' Code concerning source operands first
              call #\sp_readcode16              ' absoulte read
              call #\sp_readcode                ' zp address / immediate read
              mov sp_ea,sp_memv                 ' for all modes where we just read an address
              mov sp_ea,#0                      ' for (X) and (Y) mode
              add sp_ea,sp_x                    ' for (X), !a+X, d+X and [d+x] modes
              setbyte sp_ea,sp_dpage,#1         ' for all direct page modes

              call #\sp_read16                  ' for all indirect modes
              mov sp_ea,sp_memv                 ' ^^
              add sp_ea,sp_y                    ' for (Y),!a+Y and [d]+Y modes

              zerox sp_ea,#15                   ' for all memory modes that may wrap around
              mov sp_srcea,sp_ea                ' for all memory modes
              call #\sp_read8                   ' for all memory modes

              mov sp_optmp1,sp_memv             ' all modes
              ' Get destination now
              mov sp_memv,sp_a                  ' A register
              mov sp_writef,#sp_writeA          ' ^

              call #\sp_readcode                ' for direct page dest.
              mov sp_ea,sp_memv                 ' ^
              mov sp_ea,sp_x                    ' for (X) mode
              setbyte sp_ea,sp_dpage,#1         ' for direct page dest.
              call #\sp_read8                   ' for memory destination modes
              mov sp_writef,#sp_write8          ' for memory destination modes

              sub sp_cycles,#1                  ' extra internal cycle
              execf sp_opimpl

sp_amode_tbl
              long %01_111111_00_0_111_111_111101_0 ' A,#imm
              long %01_111111_00_0_001_111_011001_0 ' A,dp
              long %01_111111_00_0_001_111_001001_0 ' A,dp+X
              long %00_111111_00_0_001_111_000111_0 ' A,(X)
              long %01_111111_00_0_001_111_111010_0 ' A,!a
              long %00_111111_00_0_000_111_101010_0 ' A,!a+X
              long %00_111111_00_0_000_011_111010_0 ' A,!a+Y
              long %00_111111_00_0_001_100_001001_0 ' A,[dp+X]
              long %00_111111_00_0_000_000_011001_0 ' A,[dp]+Y
              long %00_000011_11_0_001_011_010111_0 ' (X),(Y)
              long %01_000100_11_0_001_111_011001_0 ' dd,ds
              long %01_000100_11_0_001_111_111101_0 ' dp,#imm
              long %01_111111_11_0_111_111_111101_0 ' ?,#imm
              long %01_111111_11_0_001_111_011001_0 ' ?,dp
              long %00_111111_11_0_001_111_001001_0 ' ?,dp+X
              long %01_111111_11_0_001_111_111010_0 ' ?,!a

sp_flagbranchtbl byte SP_NEG_BIT,SP_OVER_BIT,SP_CARRY_BIT,SP_ZERO_BIT


dsp_dosample
              ' Output last sample to DAC, then compute next one
              mov pa,dsp_daccenter
              scas dsp_lsample,dsp_dacscas
              add pa,0-0
              mov pb,dsp_daccenter
              scas dsp_rsample,dsp_dacscas
              add pb,0-0
              wypin pa,dsp_lpin
              wypin pb,dsp_rpin
dsp_run_ptch  jmp #\dsp_run


sp_pushpc
              mov .temp,sp_memv
              getbyte sp_memv,sp_pc,#1
              mov sp_ea,sp_sp
              decmod sp_sp,#$FF
              setbyte sp_ea,#1,#1
              call #sp_write8
              getbyte sp_memv,sp_pc,#0
              setbyte sp_ea,sp_sp,#0
              decmod sp_sp,#$FF
              call #sp_write8
        _ret_ mov sp_memv,.temp
.temp         long 0


sp_div        sub sp_cycles,#11
              getnib pa,sp_y,#0
              getnib pb,sp_x,#0
              cmp pa,pb wc
              bitnc sp_psw,#SP_HALF_BIT
              rolbyte sp_y,sp_a,#0
              shl sp_x,#9
              rep @.divlp,#9
              ' Funny division loop
              bitl sp_y,#16 addbits 15 wcz
              rcl sp_y,#1
              cmp sp_y,sp_x wc ' C clear if Y>=X
        if_nc xor sp_y,#1
        if_c_eq_z sub sp_y,sp_x ' Runs if LSB is now set
.divlp
              shr sp_x,#9
              getbyte sp_a,sp_y,#0
              shr sp_y,#9 wc
              bitc sp_psw,#SP_OVER_BIT
              and sp_y,#255
              and sp_a,#255 wz
              bitz sp_psw,#SP_ZERO_BIT
              test sp_a,#128 wc
        _ret_ bitc sp_psw,#SP_NEG_BIT


sp_mul        sub sp_cycles,#8
              mul sp_y,sp_a
              getbyte sp_a,sp_y,#0
              shr sp_y,#8 wz
              bitz sp_psw,#SP_ZERO_BIT
              testb sp_y,#7 wc
        _ret_ bitc sp_psw,#SP_NEG_BIT


sp_daa        sub sp_cycles,#2
              testb sp_opcode,#0 wz ' Set Z for DAA, clear for DAS

              cmpr sp_a,#$99 wc
              testb  sp_psw,#SP_CARRY_BIT orc ' DAA
              testbn sp_psw,#SP_CARRY_BIT orc ' DAS
        if_c  sumnz sp_a,#$60
        if_c  bitz sp_psw,#SP_CARRY_BIT

              getnib pa,sp_a,#0
              cmpr pa,#$09 wc
              testb  sp_psw,#SP_HALF_BIT orc ' DAA
              testbn sp_psw,#SP_HALF_BIT orc ' DAS
        if_c  sumnz sp_a,#$06

              and sp_a,#255 wz
              bitz sp_psw,#SP_ZERO_BIT
              testb sp_a,#7 wc
        _ret_ bitc  sp_psw,#SP_NEG_BIT


sp_readcode16
              call #sp_readcode
sp_readcode16_rest
              sets .patch,sp_memv
              call #sp_readcode
.patch  _ret_ rolbyte sp_memv,#0-0,#0


sp_read_dpaddr
              call #sp_readcode
              mov sp_ea,sp_memv
       _ret_  setbyte sp_ea,sp_dpage,#1

sp_read_dp8
              call #sp_read_dpaddr
              jmp #sp_read8
sp_read_dp16
              call #sp_read_dpaddr
              ' drop through
sp_read16
              'debug("in sp_read16 ",uhex_word(sp_ea))
              call #sp_read8
sp_read16_rest
              sets .patch,sp_memv
              incmod sp_ea,sp_FFFFh
              call #sp_read8
.patch  _ret_ rolbyte sp_memv,#0-0,#0



sp_readcode
              mov sp_ea,sp_pc
              incmod sp_pc,sp_FFFFh
              ' Fall through
sp_read8
              sub sp_cycles,#1
              cmp  sp_ea,#$F0 wc
        if_nc cmpr sp_ea,#$FF wc
        if_nc jmp #.ioread
              getword sp_memv,sp_ea,#0 ' make double sure we don't read OOB
              cmp sp_ea,sp_romstart wc
        if_ae add sp_memv,sp_firmbase
        if_b  add sp_memv,sp_rambase
              rdbyte sp_memv,sp_memv
              'debug("got read ",uhex_word(sp_ea),uhex_byte(sp_memv))
              ret wcz
.ioread
              pop pa wcz
              push pa
              mov ptra,sp_statbase
              getnib pa,sp_ea,#0
              jmprel pa
        _ret_ mov sp_memv,#0                    ' Register $F0: Undocumented/test
        _ret_ mov sp_memv,#0                    ' Register $F1: Control (not readable)
        _ret_ mov sp_memv,dsp_addr              ' Register $F2: DSP port address
              jmp #dsp_read                     ' Register $F3: DSP I/O
        _ret_ rdbyte sp_memv,ptra[0]            ' Register $F4: Input port 0
        _ret_ rdbyte sp_memv,ptra[1]            ' Register $F5: Input port 1
        _ret_ rdbyte sp_memv,ptra[2]            ' Register $F6: Input port 2
        _ret_ rdbyte sp_memv,ptra[3]            ' Register $F7: Input port 3
sp_f8   _ret_ mov sp_memv,#0                    ' Register $F8: Memory (technically I/O)
sp_f9   _ret_ mov sp_memv,#0                    ' Register $F9: Memory (technically I/O)
        _ret_ mov sp_memv,#0                    ' Register $FA: Timer 0 (not readable)
        _ret_ mov sp_memv,#0                    ' Register $FB: Timer 1 (not readable)
        _ret_ mov sp_memv,#0                    ' Register $FC: Timer 2 (not readable)
              nop                               ' Register $FD: Counter 0
              nop                               ' Register $FE: Counter 1
                                                ' Register $FF: Counter 2
              ' Common handler for the timer regs (read+clear)
              alts pa,#sp_ctr0-$D
              mov sp_memv,0-0
              altd pa,#sp_ctr0-$D
        _ret_ mov 0-0,#0


dsp_read
              getnib pb,dsp_addr,#0
              cmp pb,#$A wc
        if_ae jmp #.global
              ' per voice registers
              add ptra,#8+(DSP_RWLONGS*4) ' advance past ports & rwlogs
              getnib pa,dsp_addr,#1
              bitl pa,#3
              mul pa,#DSP_CHANNEL_SIZE*4
              add ptra,pa
              pop pa wcz
              push pa
              jmprel pb
        _ret_ rdbyte sp_memv,ptra[5] ' $x0: Left Volume
        _ret_ rdbyte sp_memv,ptra[7] ' $x1: Right Volume
        _ret_ rdbyte sp_memv,ptra[0] ' $x2: Pitch low
        _ret_ rdbyte sp_memv,ptra[1] ' $x3: Pitch high
        _ret_ rdbyte sp_memv,ptra[8] ' $x4: SRCN
        _ret_ rdbyte sp_memv,ptra[9] ' $x5: ADSR low
        _ret_ rdbyte sp_memv,ptra[10]' $x6: ADSR high
        _ret_ rdbyte sp_memv,ptra[11]' $x7: GAIN
              jmp #.envx             ' $x8: ENVX (read-only)
                                     ' $x9: OUTX (read-only)
              rdlong sp_memv,ptra[-2]
              sar sp_memv,#7
        _ret_ and sp_memv,#255
.envx
              rdlong sp_memv,ptra[-3]
              shr sp_memv,#4
        _ret_ and sp_memv,#255

.global
              cmp pb,#$E wcz
        if_a  jmp #.firread
        'if_e drvh #39 ' Set LED if unused location read
        if_e  ret wcz
              cmp pb,#$C wcz
        'if_b drvh #39 ' Set LED if unused location read
        if_b  ret wcz
              getnib pa,dsp_addr,#1
              bitnz pa,#3
              alts pa,#.gcall
              call #\0
              cmp pa,#$4 wc
              cmp pa,#$8 wz
    if_c_or_z shr sp_memv,#7 ' shift down MVOL/EVOL/EFB values
              and sp_memv,#255
              ret wcz
.gcall
        _ret_ getword sp_memv,dsp_mvol,#0        ' $0C: MVOL left
        _ret_ getword sp_memv,dsp_mvol,#1        ' $1C: MVOL right
        _ret_ getword sp_memv,dsp_evol,#0        ' $2C: EVOL left
        _ret_ getword sp_memv,dsp_evol,#1        ' $3C: EVOL right
        _ret_ mov sp_memv,dsp_kon_read           ' $4C: KON
        _ret_ mov sp_memv,dsp_koff               ' $5C: KOFF
        _ret_ mov sp_memv,dsp_flg                ' $6C: FLG
        _ret_ mov sp_memv,dsp_endx               ' $7C: ENDX
        _ret_ mov sp_memv,dsp_efb                ' $0D: EFB (Echo feedback)
        _ret_ mov sp_memv,#0                     ' $1D: ???
        _ret_ getbyte sp_memv,dsp_pmon_non_eon,#0' $2D: PMON
        _ret_ getbyte sp_memv,dsp_pmon_non_eon,#1' $3D: NON
        _ret_ getbyte sp_memv,dsp_pmon_non_eon,#2' $4D: RON
        _ret_ getbyte sp_memv,dsp_dir_esa_edl,#0 ' $5D: DIR
        _ret_ getbyte sp_memv,dsp_dir_esa_edl,#1 ' $6D: ESA
        _ret_ getbyte sp_memv,dsp_dir_esa_edl,#2 ' $7D: EDL

.firread
              getnib pa,dsp_addr,#1
              bitl pa,#3
              alts pa,#dsp_efir
              getbyte sp_memv,0-0,#1
              ret wcz


sp_brkjp      bitl sp_psw,#SP_IRQ_BIT
              bith sp_psw,#SP_BREAK_BIT
              mov sp_ea,##$FFDE
              call #\sp_read16
        _ret_ mov sp_pc,sp_memv

sp_writeA
        _ret_ getbyte sp_a,sp_memv,#0

sp_write16
              'debug("in sp_write16 ",uhex_word(sp_ea))
              getbyte pa,sp_memv,#1
              sets .patch,pa
              call #sp_write8
              incmod sp_ea,sp_FFFFh
.patch        mov sp_memv,#0
              ' Fall through

sp_write8
              sub sp_cycles,#1
              'debug("mem write ",uhex_word(sp_ea),uhex_byte(sp_memv))
              getword pa,sp_ea,#0 ' make double sure we don't write OOB
              add pa,sp_rambase
              wrbyte sp_memv,pa
              cmp  sp_ea,#$F0 wc
        if_nc cmpr sp_ea,#$FF wc
        if_c  ret wcz
.iowrite
              'debug("io write ",uhex_byte(sp_ea),uhex_byte(sp_memv))
              'debug("lmao")
              zerox sp_memv,#7 ' limit to 8 bit here
              pop pa wcz
              push pa
              mov ptra,sp_statbase
              getnib pa,sp_ea,#0
              jmprel pa
              jmp #.debugwrite                  ' Register $F0: Undocumented/test
              jmp #.ctrlwrite                   ' Register $F1: Control
        _ret_ mov dsp_addr,sp_memv              ' Register $F2: DSP port address
              jmp #dsp_write                    ' Register $F3: DSP I/O
        _ret_ wrbyte sp_memv,ptra[4]            ' Register $F4: Output port 0
        _ret_ wrbyte sp_memv,ptra[5]            ' Register $F5: Output port 1
        _ret_ wrbyte sp_memv,ptra[6]            ' Register $F6: Output port 2
        _ret_ wrbyte sp_memv,ptra[7]            ' Register $F7: Output port 3
        _ret_ sets sp_f8,sp_memv                ' Register $F8: Memory (technically I/O)
        _ret_ sets sp_f9,sp_memv                ' Register $F9: Memory (technically I/O)
        _ret_ mov sp_tfreq0,sp_memv             ' Register $FA: Timer 0
        _ret_ mov sp_tfreq1,sp_memv             ' Register $FB: Timer 1
        _ret_ mov sp_tfreq2,sp_memv             ' Register $FC: Timer 2
              ret                               ' Register $FD: Counter 0 (not writeable)
              ret                               ' Register $FE: Counter 1 (not writeable)
              ret                               ' Register $FF: Counter 2 (not writeable)

.debugwrite
              debug("Debug write: ",uhex_byte_(sp_memv))
              'debug(`spd `(sp_memv))
              ret wcz
.ctrlwrite
              ' timers reset on start
              mov pa,sp_memv
              andn pa,sp_tstat
              getnib sp_tstat,sp_memv,#0
              testb pa,#0 wc
        if_c  mov sp_tval0,#0
        if_c  mov sp_ctr0,#0
              testb pa,#1 wc
        if_c  mov sp_tval1,#0
        if_c  mov sp_ctr1,#0
              testb pa,#2 wc
        if_c  mov sp_tval2,#0
        if_c  mov sp_ctr2,#0
              ' input port clearing
              testb sp_memv,#4 wc
        if_c  wrword #0,ptra[0]
              testb sp_memv,#5 wc
        if_c  wrword #0,ptra[1]
              ' enable firmware if bit 7
              testb sp_memv,#7 wc
              negnc sp_romstart,sp_firmaddr
              ret wcz


dsp_write
              testb dsp_addr,#7 wc
        if_c  ret wcz
              'debug("DSP write ",uhex_byte(dsp_addr,sp_memv))
              getnib pb,dsp_addr,#0
              cmp pb,#$A wc
        if_ae jmp #.global
              ' per voice registers
              add ptra,#8+(DSP_RWLONGS*4) ' advance past ports & rwlongs
              getnib pa,dsp_addr,#1
              mul pa,#DSP_CHANNEL_SIZE*4
              add ptra,pa
              pop pa wcz
              push pa
              jmprel pb
        _ret_ wrbyte sp_memv,ptra[5] ' $x0: Left Volume
        _ret_ wrbyte sp_memv,ptra[7] ' $x1: Right Volume
        _ret_ wrbyte sp_memv,ptra[0] ' $x2: Pitch low
        _ret_ wrbyte sp_memv,ptra[1] ' $x3: Pitch high
        _ret_ wrbyte sp_memv,ptra[8] ' $x4: SRCN
        _ret_ wrbyte sp_memv,ptra[9] ' $x5: ADSR low
        _ret_ wrbyte sp_memv,ptra[10]' $x6: ADSR high
        _ret_ wrbyte sp_memv,ptra[11]' $x7: GAIN
              ret                    ' $x8: ENVX (read-only)
              ret                    ' $x9: OUTX (read-only)

.global
              cmp pb,#$E wcz
        if_a  jmp #.firwrite
        if_e  ret wcz
              cmp pb,#$C wcz
        if_b  ret wcz
              getnib pa,dsp_addr,#1
              bitnz pa,#3
              cmp pa,#$4 wc
              cmp pa,#$8 wz
    if_c_or_z shl sp_memv,#7 ' shift up and signx MVOL/EVOL/EFB values
    if_c_or_z signx sp_memv,#14
              pop pb wcz
              push pb
              jmprel pa
        _ret_ setword dsp_mvol,sp_memv,#0        ' $0C: MVOL left
        _ret_ setword dsp_mvol,sp_memv,#1        ' $1C: MVOL right
        _ret_ setword dsp_evol,sp_memv,#0        ' $2C: EVOL left
        _ret_ setword dsp_evol,sp_memv,#1        ' $3C: EVOL right
              jmp #.kon                          ' $4C: KON
        _ret_ mov dsp_koff,sp_memv               ' $5C: KOFF
        _ret_ mov dsp_flg,sp_memv                ' $6C: FLG
        _ret_ mov dsp_endx,#0                    ' $7C: ENDX (always clear)
        _ret_ mov dsp_efb,sp_memv                ' $0D: EFB (Echo feedback)
              ret                                ' $1D: ???
        _ret_ setbyte dsp_pmon_non_eon,sp_memv,#0' $2D: PMON
        _ret_ setbyte dsp_pmon_non_eon,sp_memv,#1' $3D: NON
        _ret_ setbyte dsp_pmon_non_eon,sp_memv,#2' $4D: RON
        _ret_ setbyte dsp_dir_esa_edl,sp_memv,#0 ' $5D: DIR
        _ret_ setbyte dsp_dir_esa_edl,sp_memv,#1 ' $6D: ESA
        _ret_ setbyte dsp_dir_esa_edl,sp_memv,#2 ' $7D: EDL

.kon
              mov dsp_kon_latch,sp_memv
        _ret_ mov dsp_kon_read,sp_memv

.firwrite
              getnib pa,dsp_addr,#1
              altr pa,#dsp_efir
              shl sp_memv,#8
              ret wcz




sp_400h       long $400
dsp_maxenv    ' alias
sp_7FFh       long $7FF
sp_FFFFh      long $FFFF
sp_10000h     long $10000
sp_18000h     long $18000
sp_31ab16     long 31 addbits 16

dsp_min       long $FFFF_8000
dsp_max       long $0000_7FFF
dsp_maxpitch  long $0000_3FFF
dsp_gainbend  long $601

'sp_alti_incs8 long %000_000_110__000_000_111 ' ALTI mode for 8reg wrapped S subs+increment
'sp_alti_incd8 long %000_110_000__000_111_000 ' ALTI mode for 8reg wrapped D subs+increment
'sp_alti_incr8 long %110_000_000__111_000_000 ' ALTI mode for 8reg wrapped R subs+increment


dsp_daccenter long DAC_CENTER
dsp_dacscas   long DAC_SCAS

sp_cycles     long -1
sp_pc         long 0
sp_sp         long 0
sp_psw        long 0
sp_a          long 0
sp_x          long 0
sp_y          long 0

sp_dpage      long 0 ' 0 or 1, based on D bit in PSW
sp_romstart   long $FFC0 ' negative value or sp_firmaddr based on ROM enablement
sp_firmaddr   long $FFC0

dsp_addr      long 0

sp_tstat      long 0
sp_tdiv       long 0
sp_tfreq0     long 0
sp_tfreq1     long 0
sp_tfreq2     long 0
sp_tval0      long 0
sp_tval1      long 0
sp_tval2      long 0
sp_ctr0       long 0
sp_ctr1       long 0
sp_ctr2       long 0

dsp_lsample   long 0
dsp_rsample   long 0

sp_rambase    long @audio_ram ' patched by start
sp_firmbase   long @spc_firmware - $FFC0 ' patched by start
sp_statbase   long @apu_status ' patched by start
dsp_lpin      long AUDIO_LEFT ' patched by start
dsp_rpin      long AUDIO_RIGHT ' patched by start

dsp_rateremap byte
' To facilitate faster timer checks
' Timer long looks like this:
'  31   27   23   19   15   11   7    4
' %0555_5555_5d33_3333_333d_1111_1111_111d
byte   31, 11, 21
byte   30, 10, 20
byte   29,  9, 19
byte   28,  8, 18
byte   27,  7, 17
byte   26,  6, 16
byte   25,  5, 15
byte   24,  4, 14
byte   23,  3, 13
byte   22,  2, 12
byte        1
byte        0

dsp_brrpred_tbl long ' BRR predictor coefficents (sometimes wrongly referred to as "filters")
long $0000_0000
long $1E00_0000
long $3D00_E200
long $3980_E600

              '' TODO: make sure initial values for these are ok
dsp_ct1       long 0 ' undivded rate counter
dsp_ct3       long 348 ' rate counter divided by 3
dsp_ct5       long 148 ' rate counter divided by 5
dsp_div3      long 1
dsp_div5      long 4
dsp_xct       long 0 ' extra sample counter for debugging

dsp_noise     long $4000
dsp_eoff      long 0
dsp_ewrap     long 4
dsp_dir_esa_edl long 0 'DIR, ESA and EDL register values
dsp_pmon_non_eon long 0 ' PMON, NON and EON register values
dsp_flg       long %001_00000
dsp_efb       long 0
dsp_mvol      long 0 ' master volume (left/right)
dsp_evol      long 0 ' echo volume (left/right)
dsp_endx      long 0
dsp_kon_latch long 0
dsp_kon_read  long 0
dsp_koff      long 0

dsp_ehist     long 0[8] ' echo history buffer
dsp_efir      long 0[8] ' echo buffer FIR filter coefficents

dsp_chan      'alias
sp_ea         res 1
dsp_tmp1      'alias
sp_memv       res 1
dsp_tmp2      'alias
sp_opcode     res 1
dsp_tmp3      'alias
sp_opimpl     res 1
dsp_tmp4      'alias
sp_optmp1     res 1
dsp_tmp5      'alias
sp_srcea      res 1
dsp_tmp6      ' alias
sp_writef     res 1

dsp_tmp7      res 1

dsp_rates     res 1

dsp_lecho     res 1
dsp_recho     res 1
dsp_modout    res 1



              fit $1E0
              org $1E0
              ' Channel data starts here
              ' read/write
dsp_sbuf      res 8 ' decode buffer for current channel
dsp_brrbase   res 1 ' current BRR header pointer
dsp_gausspos  res 1 ' inter-sample position
dsp_envlvl    res 1 ' envelope level
dsp_output    res 1 ' output level
dsp_envstat   res 1 ' envelope state machine

              ' read only
dsp_pitch     res 1 ' pitch
dsp_cvol      res 1 ' channel left/right volume in byte 1/3 (others zero)
dsp_src_adsr_gain res 1 ' SRCN,ADSR0,ADSR1 and GAIN registers

              fit 502

DAT ' SPCcog LUT code
              orgh
sp_lutblob
              org 512
long    sp_nop                                                                  ' 00: NOP
long    sp_tcall+%000_001_0000_0<<10                                            ' 01: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 02: SET1 dp.0
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 03: BBS dp.0
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_DP                    ' 04: OR A,dp
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_ABS                   ' 05: OR A,!a
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_XI                    ' 06: OR A,(X)
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_DPXI                  ' 07: OR A,[d+X]
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_IMM                   ' 08: OR A,#imm
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_DP_DP                   ' 09: OR dd,ds
long    sp_bitop+  %0_1011_1000_000000<<10                                      ' 0A: OR1 C,m.b
long    sp_shiftm+ %0_00000_0011_10<<10      +SP_AMODE_U_DP                     ' 0B: ASL dp
long    sp_shiftm+ %0_00000_0011_10<<10      +SP_AMODE_U_ABS                    ' 0C: ASL !a
long    sp_push+%00111_0000<<10                                                 ' 0D: PUSH PSW
long    sp_tsetclr+%0_10_000000<<10          +SP_AMODE_U_ABS                    ' 0E: TSET1 !a
long    sp_brk+%00111_00001_00<<10                                              ' 0F: BRK

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' 10: BPL
long    sp_tcall+%000_001_0000_0<<10                                            ' 11: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 12: CLR1 dp.0
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 13: BBC dp.0
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_DPX                   ' 14: OR A,dp+X
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_ABSX                  ' 15: OR A,!a+X
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_ABSY                  ' 16: OR A,!a+Y
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_A_DPIY                  ' 17: OR A,[dp]+Y
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_DP_IMM                  ' 18: OR dp,#imm
long    sp_ora+%0_0001_111111_1111_111110<<10 +SP_AMODE_XI_YI                   ' 19: OR (X),(Y)
long    sp_incdecw+    %01_0010_1101_11111_00<<10                               ' 1A: DECW dp
long    sp_shiftm+ %0_00000_0011_10<<10      +SP_AMODE_U_DPX                    ' 1B: ASL dp+X
long    sp_shifta+%01_00000_0011_10_00<<10                                      ' 1C: ASL A
long    sp_incdecr+  %0111_0001_0111_11010<<10                                  ' 1D: DEC X
long    sp_cmpx+%10<<10                  +SP_AMODE_U_ABS                        ' 1E: CMP X,!a
long    sp_jmp+%010_000_1111_10<<10                                             ' 1F: JMP [!a+X]

long    sp_setflags1+%0101110<<10                                               ' 20: CLRP
long    sp_tcall+%000_001_0000_0<<10                                            ' 21: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 22: SET1 dp.1
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 23: BBS dp.1
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_DP                      ' 24: AND A,dp
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_ABS                     ' 25: AND A,!a
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_XI                      ' 26: AND A,(X)
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_DPXI                    ' 27: AND A,[d+X]
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_IMM                     ' 28: AND A,#imm
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_DP_DP                     ' 29: AND dd,ds
long    sp_bitop+  %0_1011_0100_000000<<10                                      ' 2A: OR1 C,/m.b
long    sp_rollm + %0_00000_0011_0<<10       +SP_AMODE_U_DP                     ' 2B: ROL dp
long    sp_rollm + %0_00000_0011_0<<10       +SP_AMODE_U_ABS                    ' 2C: ROL !a
long    sp_push+%01110_0000<<10                                                 ' 2D: PUSH A
long    sp_cbne+   %0000_0010_0_0<<10 +SP_AMODE_U_DP                            ' 2E: CBNE dp
long    sp_bra +   %0000_10<<10                                                 ' 2F: BRA

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' 30: BMI
long    sp_tcall+%000_001_0000_0<<10                                            ' 31: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 32: CLR1 dp.1
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 33: BBC dp.1
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_DPX                     ' 34: AND A,dp+X
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_ABSX                    ' 35: AND A,!a+X
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_ABSY                    ' 36: AND A,!a+Y
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_A_DPIY                    ' 37: AND A,[dp]+Y
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_DP_IMM                    ' 38: AND dp,#imm
long    sp_and+%0_0001_111111_1111_1110<<10 +SP_AMODE_XI_YI                     ' 39: AND (X),(Y)
long    sp_incdecw+    %01_0010_1110_11111_00<<10                               ' 3A: INCW dp
long    sp_rollm + %0_00000_0011_0<<10       +SP_AMODE_U_DPX                    ' 3B: ROL dp+X
long    sp_shifta+%01_00000_0011_01_00<<10                                      ' 3C: ROL A
long    sp_incdecr+  %0111_0001_1011_11010<<10                                  ' 3D: INC X
long    sp_cmpx+%10<<10                  +SP_AMODE_U_DP                         ' 3E: CMP X,dp
long    sp_jmp +%000_111_1111_00<<10                                            ' 3F: CALL !a

long    sp_setflags1+%0011110<<10                                               ' 40: SETP
long    sp_tcall+%000_001_0000_0<<10                                            ' 41: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 42: SET1 dp.2
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 43: BBS dp.2
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_DP                     ' 44: EOR A,dp
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_ABS                    ' 45: EOR A,!a
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_XI                     ' 46: EOR A,(X)
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_DPXI                   ' 47: EOR A,[d+X]
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_IMM                    ' 48: EOR A,#imm
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_DP_DP                    ' 49: EOR dd,ds
long    sp_bitop+  %0_1101_1001_000000<<10                                      ' 4A: AND1 C,m.b
long    sp_shiftm+ %0_00000_1100_10<<10      +SP_AMODE_U_DP                     ' 4B: LSR dp
long    sp_shiftm+ %0_00000_1100_10<<10      +SP_AMODE_U_ABS                    ' 4C: LSR !a
long    sp_push+%01101_0000<<10                                                 ' 4D: PUSH X
long    sp_tsetclr+%0_01_000000<<10          +SP_AMODE_U_ABS                    ' 4E: TCLR1 !a
long    sp_pcall+%001_111_0111_010<<10                                          ' 4F: PCALL

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' 50: BVC
long    sp_tcall+%000_001_0000_0<<10                                            ' 51: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 52: CLR1 dp.2
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 53: BBC dp.2
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_DPX                    ' 54: EOR A,dp+X
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_ABSX                   ' 55: EOR A,!a+X
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_ABSY                   ' 56: EOR A,!a+Y
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_A_DPIY                   ' 57: EOR A,[dp]+Y
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_DP_IMM                   ' 58: EOR dp,#imm
long    sp_eor+%0_0001_111111_1111_11110<<10 +SP_AMODE_XI_YI                    ' 59: EOR (X),(Y)
long    sp_wop+  %0_0000_111100_00000_100_00<<10                                ' 5A: CMPW YA,dp
long    sp_shiftm+ %0_00000_1100_10<<10      +SP_AMODE_U_DPX                    ' 5B: LSR dp+X
long    sp_shifta+%01_00000_1100_10_00<<10                                      ' 5C: LSR A
long    sp_mova+%01_000_101_11110<<10                                           ' 5D: MOV X,A
long    sp_cmpy+%0<<10                   +SP_AMODE_U_ABS                        ' 5E: CMP Y,!a
long    sp_jmp+%011_111_1111_10<<10                                             ' 5F: JMP !a

long    sp_setflags1+%010<<10                                                   ' 60: CLRC
long    sp_tcall+%000_001_0000_0<<10                                            ' 61: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 62: SET1 dp.3
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 63: BBS dp.3
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_DP                       ' 64: CMP A,dp
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_ABS                      ' 65: CMP A,!a
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_XI                       ' 66: CMP A,(X)
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_DPXI                     ' 67: CMP A,[d+X]
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_IMM                      ' 68: CMP A,#imm
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_DP_DP                      ' 69: CMP dd,ds
long    sp_bitop+  %0_1101_0101_000000<<10                                      ' 6A: AND1 C,/m.b
long    sp_rollm + %0_00000_1100_0<<10       +SP_AMODE_U_DP                     ' 6B: ROR dp
long    sp_rollm + %0_00000_1100_0<<10       +SP_AMODE_U_ABS                    ' 6C: ROR !a
long    sp_push+%01011_0000<<10                                                 ' 6D: PUSH Y
long    sp_dbnz_dp+%0000_0011_0_1_000<<10 +SP_AMODE_U_DP                        ' 6E: DBNZ dp
long    sp_return                                                               ' 6F: RET

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' 70: BVS
long    sp_tcall+%000_001_0000_0<<10                                            ' 71: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 72: CLR1 dp.3
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 73: BBC dp.3
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_DPX                      ' 74: CMP A,dp+X
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_ABSX                     ' 75: CMP A,!a+X
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_ABSY                     ' 76: CMP A,!a+Y
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_A_DPIY                     ' 77: CMP A,[dp]+Y
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_DP_IMM                     ' 78: CMP dp,#imm
long    sp_sbc+%1_0000_111100_1101_010<<10 +SP_AMODE_XI_YI                      ' 79: CMP (X),(Y)
long    sp_wop+%0001_0000_000000_00001_100_00<<10                               ' 7A: ADDW YA,dp
long    sp_rollm + %0_00000_1100_0<<10       +SP_AMODE_U_DPX                    ' 7B: ROR dp+X
long    sp_shifta+%01_00000_1100_01_00<<10                                      ' 7C: ROR A
long    sp_movx+ %0_000_101_10<<10                                              ' 7D: MOV A,X
long    sp_cmpy+%0<<10                   +SP_AMODE_U_DP                         ' 7E: CMP Y,dp
long    sp_pop + %111_1000_11111_11000<<10                                      ' 7F: RETI

long    sp_setflags1+%00<<10                                                    ' 80: SETC
long    sp_tcall+%000_001_0000_0<<10                                            ' 81: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 82: SET1 dp.4
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 83: BBS dp.4
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_DP                        ' 84: ADC A,dp
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_ABS                       ' 85: ADC A,!a
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_XI                        ' 86: ADC A,(X)
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_DPXI                      ' 87: ADC A,[d+X]
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_IMM                       ' 88: ADC A,#imm
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_DP_DP                       ' 89: ADC dd,ds
long    sp_bitop+  %0_0111_1000_000000<<10                                      ' 8A: EOR1 C,m.b
long    sp_incdecm+     %0_0001_0111_0<<10+SP_AMODE_U_DP                        ' 8B: DEC dp
long    sp_incdecm+     %0_0001_0111_0<<10+SP_AMODE_U_ABS                       ' 8C: DEC !a
long    sp_mov + %011_000_111_1110<<10   +SP_AMODE_A_IMM                        ' 8D: MOV Y,#imm
long    sp_pop +     %0000_11111_01000<<10                                      ' 8E: POP PSW
long    sp_mov +%0111_111_111_1110<<10   +SP_AMODE_DP_IMM                       ' 8F: MOV dp,#imm

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' 90: BCC
long    sp_tcall+%000_001_0000_0<<10                                            ' 91: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' 92: CLR1 dp.4
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' 93: BBC dp.4
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_DPX                       ' 94: ADC A,dp+X
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_ABSX                      ' 95: ADC A,!a+X
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_ABSY                      ' 96: ADC A,!a+Y
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_A_DPIY                      ' 97: ADC A,[dp]+Y
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_DP_IMM                      ' 98: ADC dp,#imm
long    sp_adc+%0_0000_000000_0000_10<<10 +SP_AMODE_XI_YI                       ' 99: ADC (X),(Y)
long    sp_wop+%0001_0000_000000_00000_100_00<<10                               ' 9A: SUBW YA,dp
long    sp_incdecm+     %0_0001_0111_0<<10+SP_AMODE_U_DPX                       ' 9B: DEC dp+X
long    sp_incdecr+   %011_0001_0111_11100<<10                                  ' 9C: DEC A
long    sp_movsp+%01_000_101_111110<<10                                         ' 9D: MOV X,SP
long    sp_div                                                                  ' 9E: DIV
long    sp_xcn                                                                  ' 9F: XCN A

long    sp_setflags2+%000<<10                                                   ' A0: EI
long    sp_tcall+%000_001_0000_0<<10                                            ' A1: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' A2: SET1 dp.5
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' A3: BBS dp.5
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_DP                       ' A4: SBC A,dp
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_ABS                      ' A5: SBC A,!a
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_XI                       ' A6: SBC A,(X)
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_DPXI                     ' A7: SBC A,[d+X]
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_IMM                      ' A8: SBC A,#imm
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_DP_DP                      ' A9: SBC dd,ds
long    sp_bitop+  %0_1110_1011_000000<<10                                      ' AA: MOV1 C,m.b
long    sp_incdecm+     %0_0001_1011_0<<10+SP_AMODE_U_DP                        ' AB: INC dp
long    sp_incdecm+     %0_0001_1011_0<<10+SP_AMODE_U_ABS                       ' AC: INC !a
long    sp_cmpy+%0<<10                   +SP_AMODE_U_IMM                        ' AD: CMP Y,#imm
long    sp_pop +   %0_1110_11111_01000<<10                                      ' AE: POP A
long    sp_mxi+  %0111_111_010_111101_1100<<10                                  ' AF: MOV (X+),A

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' B0: BCS
long    sp_tcall+%000_001_0000_0<<10                                            ' B1: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' B2: CLR1 dp.5
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' B3: BBC dp.5
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_DPX                      ' B4: SBC A,dp+X
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_ABSX                     ' B5: SBC A,!a+X
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_ABSY                     ' B6: SBC A,!a+Y
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_A_DPIY                     ' B7: SBC A,[dp]+Y
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_DP_IMM                     ' B8: SBC dp,#imm
long    sp_sbc+%0_0000_000000_0000_100<<10 +SP_AMODE_XI_YI                      ' B9: SBC (X),(Y)
long    sp_wop+%0001_0000_111111_11111_111_10<<10                               ' BA: MOVW YA,dp
long    sp_incdecm+     %0_0001_1011_0<<10+SP_AMODE_U_DPX                       ' BB: INC dp+X
long    sp_incdecr+   %011_0001_1011_11100<<10                                  ' BC: INC A
long    sp_movx+%01111_111_101_10<<10                                           ' BD: MOV SP,X
long    sp_daa+%0000_00100_00010_00<<10                                         ' BE: DAS
long    sp_mxi+     %0_111_010_111111_0000<<10                                  ' BF: MOV A,(X+)

long    sp_setflags2+%010<<10                                                   ' C0: DI
long    sp_tcall+%000_001_0000_0<<10                                            ' C1: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' C2: SET1 dp.6
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' C3: BBS dp.6
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_DP                         ' C4: MOV dp,A
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_ABS                        ' C5: MOV !a,A
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_XI                         ' C6: MOV (X),A
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_DPXI                       ' C7: MOV [d+X],A
long    sp_cmpx+%10<<10                  +SP_AMODE_U_IMM                        ' C8: CMP X,#imm
long    sp_rmov+ %0111_111_111_100<<10   +SP_AMODE_U_ABS                        ' C9: MOV !a,X
long    sp_bitop+%001_1111_1100_000000<<10                                      ' CA: MOV1 m.b,C
long    sp_rmov+ %0111_111_111_010<<10   +SP_AMODE_U_DP                         ' CB: MOV dp,Y
long    sp_rmov+ %0111_111_111_010<<10   +SP_AMODE_U_ABS                        ' CC: MOV !a,Y
long    sp_mov +  %01_000_111_1110<<10   +SP_AMODE_A_IMM                        ' CD: MOV X,#imm
long    sp_pop +  %01_1110_11111_01000<<10                                      ' CE: POP X
long    sp_mul                                                                  ' CF: MUL

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' D0: BNE
long    sp_tcall+%000_001_0000_0<<10                                            ' D1: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' D2: CLR1 dp.6
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' D3: BBC dp.6
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_DPX                        ' D4: MOV dp+X,A
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_ABSX                       ' D5: MOV !a+X,A
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_ABSY                       ' D6: MOV !a+Y,A
long    sp_rmov+ %0111_111_111_110<<10   +SP_AMODE_A_DPIY                       ' D7: MOV [dp]+Y,A
long    sp_rmov+ %0111_111_111_100<<10   +SP_AMODE_U_DP                         ' D8: MOV dp,X
long    sp_mdpy+ %0111_111_101_101111_1001000<<10                               ' D9: MOV dp+Y,X
long    sp_movw1+%000_110<<10                                                   ' DA: MOVW dp,YA
long    sp_rmov+ %0111_111_111_010<<10   +SP_AMODE_U_DPX                        ' DB: MOV dp+X,Y
long    sp_incdecr+ %01111_0001_0111_10110<<10                                  ' DC: DEC Y
long    sp_movy+    %0_000_101_0<<10                                            ' DD: MOV A,Y
long    sp_cbne+   %0000_0010_0_0<<10 +SP_AMODE_U_DPX                           ' DE: CBNE dp+X
long    sp_daa+%0000_01000_00100_00<<10                                         ' DF: DAA

long    sp_setflags1+%0110<<10                                                  ' E0: SETC
long    sp_tcall+%000_001_0000_0<<10                                            ' E1: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' E2: SET1 dp.7
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' E3: BBS dp.7
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_U_DP                         ' E4: MOV A,dp
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_U_ABS                        ' E5: MOV A,!a
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_A_XI                         ' E6: MOV A,(X)
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_A_DPXI                       ' E7: MOV A,[dp+X]
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_A_IMM                        ' E8: MOV A,#imm
long    sp_mov +  %01_000_111_1110<<10   +SP_AMODE_U_ABS                        ' E9: MOV X,!a
long    sp_bitop+%001_1110_0111_000000<<10                                      ' EA: NOT1 m.b
long    sp_mov + %011_000_111_1110<<10   +SP_AMODE_U_DP                         ' EB: MOV Y,dp
long    sp_mov + %011_000_111_1110<<10   +SP_AMODE_U_ABS                        ' EC: MOV Y,!a
long    sp_setflags2+%0110<<10                                                  ' ED: NOTC
long    sp_pop + %011_1110_11111_01000<<10                                      ' EE: POP Y
long    sp_stop                                                                 ' EF: SLEEP

long    sp_branch+ %0000_0011_1_1_1111_000_111_0<<10                            ' F0: BEQ
long    sp_tcall+%000_001_0000_0<<10                                            ' F1: TCALL
long    sp_dpbitop+                        %00_10_0<<10                         ' F2: CLR1 dp.7
long    sp_dpbitop+%0000_0010_1_1_1111_111_011_10_0<<10                         ' F3: BBC dp.7
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_U_DPX                        ' F4: MOV A,dp+X
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_A_ABSX                       ' F5: MOV A,!a+X
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_A_ABSY                       ' F6: MOV A,!a+Y
long    sp_mov +   %0_000_111_1110<<10   +SP_AMODE_A_DPIY                       ' F7: MOV A,[d]+Y
long    sp_mov +  %01_000_111_1110<<10   +SP_AMODE_U_DP                         ' F8: MOV X,dp
long    sp_mdpy+  %01_000_111_111111_0001000<<10                                ' F9: MOV X,dp+Y
long    sp_dpmov                                                                ' FA: MOV dd,ds
long    sp_mov + %011_000_111_1110<<10   +SP_AMODE_U_DPX                        ' FB: MOV Y,dp+X
long    sp_incdecr+ %01111_0001_1011_10110<<10                                  ' FC: INC Y
long    sp_mova+ %011_000_101_11110<<10                                         ' FD: MOV Y,A
long    sp_dbnz_y+ %0000_0010_0_1_1110<<10                                      ' FE: DBNZ Y
long    sp_stop                                                                 ' FF: STOP


sp_movw1      call #\sp_read_dp8 ' dummy read for MOVW dp,YA
sp_wop        call #\sp_read_dp16 ' slight inaccuracy - 16 bit op at $FF should wrap around, this doesn't
              getword sp_optmp1,sp_memv,#0 ' make double sure this is 16 bit

              mov sp_memv,sp_a
              setbyte sp_memv,sp_y,#1
              jmp #sp_write16 ' for MOVW dp,YA

              bitnot sp_optmp1,sp_31ab16 ' invert operand for SUBW (sets bit 31)
              mov pa,sp_optmp1 wc ' set carry for SUBW, clear for ADDW
              xor pa,sp_memv
              addx sp_memv,sp_optmp1
              xor pa,sp_memv

              test sp_memv,sp_10000h wc
              bitc sp_psw,#SP_CARRY_BIT
              test pa,sp_18000h wc
              bitc sp_psw,#SP_OVER_BIT
              testb pa,#12 wc
              bitc sp_psw,#SP_HALF_BIT

              and sp_memv,sp_FFFFh wz
              bitz sp_psw,#SP_ZERO_BIT
              testb sp_memv,#15 wc
              bitc sp_psw,#SP_NEG_BIT

              ret
              sub sp_cycles,#1 ' Dummy cycle
              getbyte sp_a,sp_memv,#0
        _ret_ getbyte sp_y,sp_memv,#1


sp_bitop      call #\sp_readcode16
              mov sp_optmp1,sp_memv
              shr sp_optmp1,#13
              mov sp_ea,sp_memv
              zerox sp_ea,#12
              call #\sp_read8

              sub sp_cycles,#1 ' Dummy cycle
              testb sp_psw,#SP_CARRY_BIT wc
              testb sp_memv,sp_optmp1 wz
              testbn sp_memv,sp_optmp1 wz

              modc _z wc
              modc _z_and_c wc
              modc _z_or_c wc
              modc _z_ne_c wc

        _ret_ bitc sp_psw,#SP_CARRY_BIT
              bitc sp_memv,sp_optmp1
              jmp #\sp_write8


sp_tsetclr    sub sp_cycles,#1
              mov pa,sp_a
              sub pa,sp_memv wz
              testb pa,#7 wc
              bitz sp_psw,#SP_ZERO_BIT
              bitc sp_psw,#SP_NEG_BIT

              or sp_memv,sp_a    ' TSET1
              andn sp_memv,sp_a  ' TCLR1

              jmp #\sp_write8


sp_shifta     mov sp_memv,sp_a
              sub sp_cycles,#1

sp_shiftm     modc _clr wc
sp_rollm      testb sp_psw,#SP_CARRY_BIT wc

              bitc sp_memv,#8 ' right
              shr sp_memv,#1 wc ' right
              rcl sp_memv,#1  ' left
              bitl sp_memv,#8 wcz 'left

              bitc sp_psw,#SP_CARRY_BIT
              and sp_memv,#255 wz
              bitz sp_psw,#SP_ZERO_BIT
              testb sp_memv,#7 wc
              bitc sp_psw,#SP_NEG_BIT

              jmp #\sp_write8
        _ret_ mov sp_a,sp_memv


sp_incdecw    call #\sp_read_dp16' slight inaccuracy - 16 bit op at $FF should wrap around, this doesn't
              decmod sp_ea,sp_FFFFh

sp_incdecr    sub sp_cycles,#1
              mov sp_memv,sp_a
              mov sp_memv,sp_x
              mov sp_memv,sp_y
sp_incdecm    mov sp_ea,sp_srcea

              incmod sp_memv,sp_FFFFh wz
              decmod sp_memv,sp_FFFFh wz
              incmod sp_memv,#$FF wz
              decmod sp_memv,#$FF wz

              testb sp_memv,#15 wc
              testb sp_memv,#7 wc
              bitz sp_psw,#SP_ZERO_BIT
              bitc sp_psw,#SP_NEG_BIT

              jmp #sp_write8
              jmp #sp_write16
        _ret_ mov sp_a,sp_memv
        _ret_ mov sp_x,sp_memv
        _ret_ mov sp_y,sp_memv


sp_setflags1  sub sp_cycles,#1
        _ret_ bith sp_psw,#SP_CARRY_BIT ' SETC
        _ret_ bitl sp_psw,#SP_CARRY_BIT ' CLRC
        _ret_ andn sp_psw,#(1<<SP_OVER_BIT)|(1<<SP_HALF_BIT) ' CLRV
              mov sp_dpage,#0 wz ' CLRP
              mov sp_dpage,#1 wz ' SETP
        _ret_ bitnz sp_psw,#SP_PAGE_BIT ' CLRP/SETP

sp_setflags2  sub sp_cycles,#2
        _ret_ bith sp_psw,#SP_IRQ_BIT ' EI
        _ret_ bitl sp_psw,#SP_IRQ_BIT ' DI
        _ret_ bitnot sp_psw,#SP_CARRY_BIT ' NOTC


sp_brk        call #\sp_pushpc
              push #sp_brkjp

sp_pop        incmod sp_sp,#$FF
sp_push       mov sp_ea,sp_sp
              setbyte sp_ea,#1,#1
              decmod sp_sp,#$FF
              sub sp_cycles,#2

              mov sp_memv,sp_a
              mov sp_memv,sp_x
              mov sp_memv,sp_y
              mov sp_memv,sp_psw
              jmp #\sp_write8

              call #\sp_read8
              mov sp_psw,sp_memv
              testb sp_psw,#SP_PAGE_BIT wc
        _ret_ wrc sp_dpage

        _ret_ mov sp_a,sp_memv
        _ret_ mov sp_x,sp_memv
        _ret_ mov sp_y,sp_memv

              wrc sp_dpage
              ' Can fall through for RETI
sp_return     sub sp_cycles,#2
              incmod sp_sp,#$FF
              mov sp_ea,sp_sp
              setbyte sp_ea,#1,#1
              call #\sp_read8
              setbyte sp_pc,sp_memv,#0
              incmod sp_sp,#$FF
              setbyte sp_ea,sp_sp,#0
              call #\sp_read8
        _ret_ setbyte sp_pc,sp_memv,#1



sp_dpbitop
              call #\sp_read_dp8

              shr sp_opcode,#5 wc ' SET1/CLR1/BBS/BBC
sp_branch     shr sp_opcode,#6 wc ' Flag branches

              bitnc sp_memv,sp_opcode ' SET1/CLR1
              jmp #\sp_write8         ' SET1/CLR1
              testb sp_memv,sp_opcode xorc ' BBS/BBC

              altgb sp_opcode,#sp_flagbranchtbl ' Flag branches
              getbyte pa            ' Flag branches
              testbn sp_psw,pa xorc ' Flag branches

sp_dbnz_y     decmod sp_y,#$FF wz ' DBNZ Y
sp_dbnz_dp    mov sp_memv,sp_optmp1 ' DBNZ dp
              decmod sp_memv,#$FF wz ' DBNZ dp
              call #\sp_write8 ' DBNZ dp

sp_cbne       cmp sp_a,sp_optmp1 wz

              modc _nz wc ' all DBNZ/CBNE

              sub sp_cycles,#1  ' BBS/BBC/CBNE
              sub sp_cycles,#2  ' DBNZ Y
sp_bra        call #\sp_readcode
        if_nc ret

              sub sp_cycles,#2
              signx sp_memv,#7
              'debug(sdec(sp_memv))
              add sp_pc,sp_memv
        _ret_ zerox sp_pc,#15



sp_pcall      call #\sp_readcode   ' PCALL
sp_jmp        call #\sp_readcode16 ' All but PCALL or TCALL
sp_tcall      call #\sp_pushpc     ' All calls

              getnib sp_memv,sp_opcode,#1 ' TCALL
              shl sp_memv,#1            ' TCALL
              subr sp_memv,#$DE         ' TCALL
              setbyte sp_memv,#$FF,#1   ' TCALL/PCALL

              add sp_memv,sp_x  ' JMP [!a+X]
              getword sp_ea,sp_memv,#0 ' indirect
              call #\sp_read16  ' indirect

              sub sp_cycles,#1
              sub sp_cycles,#2
        _ret_ mov sp_pc,sp_memv



              ' MOV-related funnies
sp_mdpy       call #\sp_readcode  ' Elusive dp+Y mode
              mov sp_ea,sp_memv
              add sp_ea,sp_y
sp_mxi        mov sp_ea,sp_x      ' for (X+) mode
              setbyte sp_ea,sp_dpage,#1
              call #\sp_read8
              mov sp_memv,sp_memv wz

sp_movsp      mov sp_memv,sp_sp wz
sp_mova       mov sp_memv,sp_a wz
sp_mov        mov sp_memv,sp_optmp1 wz
sp_rmov       mov sp_ea,sp_srcea       ' For moving from D to S. Lunacy.
sp_movx       mov sp_memv,sp_x wz
sp_movy       mov sp_memv,sp_y wz

              incmod sp_x,#$FF ' for (X+) mode
              sub sp_cycles,#1 ' Extra cycle
              sub sp_cycles,#2 ' Double xtra cycle

              testb sp_memv,#7 wc
              bitc sp_psw,#SP_NEG_BIT
              bitz sp_psw,#SP_ZERO_BIT

        _ret_ getbyte sp_a,sp_memv,#0
        _ret_ getbyte sp_x,sp_memv,#0
        _ret_ getbyte sp_y,sp_memv,#0
              jmp #\sp_write8
        _ret_ getbyte sp_sp,sp_memv,#0


sp_dpmov    ' Can't use amode because there's not supposed to be a dummy read
            call #\sp_read_dp8
            mov sp_optmp1,sp_memv
            call #\sp_read_dpaddr
            mov sp_memv,sp_optmp1
            jmp #\sp_write8


sp_cmpx       mov sp_memv,sp_x
sp_cmpy       mov sp_memv,sp_y
              skipf ##%011_1_0000_111100_1101_010111

        ' All the funny ALU ops
sp_ora        or  sp_memv,sp_optmp1 wz
sp_eor        xor sp_memv,sp_optmp1 wz
sp_and        and sp_memv,sp_optmp1 wz
sp_sbc        xor sp_optmp1,#$FF       ' Believe it or not, that is how subtract works on 6502-like CPUs
sp_adc        testb sp_psw,#SP_CARRY_BIT wc
              modc _set wc ' for CMP

              mov pa,sp_memv
              addx sp_memv,sp_optmp1
              xor pa,sp_memv
              xor pa,sp_optmp1

              test sp_memv,#$100 wc
              bitc sp_psw,#SP_CARRY_BIT
              test pa,#$180 wc
              bitc sp_psw,#SP_OVER_BIT
              test pa,#$010 wc
              bitc sp_psw,#SP_HALF_BIT

              and sp_memv,#$FF wz
              bitz sp_psw,#SP_ZERO_BIT
              test sp_memv,#$80 wc
              bitc sp_psw,#SP_NEG_BIT

              jmp sp_writef
              ' for CMP
              cmp sp_writef,#sp_write8 wz
        if_z  sub sp_cycles,#1
              ret



sp_xcn
              sub sp_cycles,#4
              rolnib sp_a,sp_a,#1
              and sp_a,#255 wz
              testb sp_a,#7 wc
              bitz sp_psw,#SP_ZERO_BIT
        _ret_ bitc sp_psw,#SP_NEG_BIT

sp_stop
              'debug("Halted! ",uhex_word(sp_pc),dly(#1000))
              decmod sp_pc,sp_FFFFh
sp_nop
        _ret_ sub sp_cycles,#1


              fit 1024


DAT ' S-DSP emulation
              orgh
dsp_run
              '' Give cycles to CPU
              add sp_cycles,#32 wc
        'if_nc drvh #39 ' Set LED if DSP is called before CPU exhausted cycle budget
              fles sp_cycles,#32*3
              '' Update SPC timers
              incmod sp_tdiv,#3 wc ' 8kHz master divider for T0/T1
              testb sp_tstat,#0 wz
        if_11 incmod sp_tval0,#255
              cmp    sp_tval0,sp_tfreq0 wz
        if_11 mov    sp_tval0,#0
        if_11 incmod sp_ctr0,#15
              testb sp_tstat,#1 wz
        if_11 incmod sp_tval1,#255
              cmp    sp_tval1,sp_tfreq1 wz
        if_11 mov    sp_tval1,#0
        if_11 incmod sp_ctr1,#15
              ' Timer 2 runs at 64kHz, so do two steps
              'testb
              testb sp_tstat,#2 wc
        if_1x incmod sp_tval2,#255
              cmp    sp_tval2,sp_tfreq2 wz
        if_11 mov    sp_tval2,#0
        if_11 incmod sp_ctr2,#15
        if_1x incmod sp_tval2,#255
              cmp    sp_tval2,sp_tfreq2 wz
        if_11 mov    sp_tval2,#0
        if_11 incmod sp_ctr2,#15

              'debug(`dspv update 0)

              mov ptra,sp_statbase
              'debug("Canary alive!")
              add ptra,#8


              '' Update DSP timers
              ' 1/5n part
              mov dsp_rates,dsp_ct5
              incmod dsp_div5,#4 wc
        if_c  incmod dsp_ct5,#$0FF
              andn dsp_rates,dsp_ct5
              rcl dsp_rates,#1
              ' 1/3n part
              shl dsp_rates,#9
              or dsp_rates,dsp_ct3
              incmod dsp_div3,#2 wc
        if_c  incmod dsp_ct3,#$1FF
              andn dsp_rates,dsp_ct3
              rcl dsp_rates,#1
              ' 1/1n part
              shl dsp_rates,#11
              or dsp_rates,dsp_ct1
              incmod dsp_ct1,sp_7FFh
              andn dsp_rates,dsp_ct1
              modc _set wc
              rcl dsp_rates,#1


              '' Update noise generator
              mov pa,dsp_flg
              and pa,#31
              altgb pa,#dsp_rateremap
              getbyte pa
              testb dsp_rates,pa wz
              test dsp_noise,#6 wc
        if_z  shr dsp_noise,#1
              bitl dsp_noise,#0
        if_z  bitc dsp_noise,#15
              signx dsp_noise,#15

              ''
              mov dsp_lsample,#0
              mov dsp_rsample,#0
              mov dsp_lecho,#0
              mov dsp_recho,#0
              mov dsp_modout,#0

              andn dsp_endx,dsp_kon_latch ' clear ENDX for key-on channels


              mov dsp_chan,#0
dsp_chloop    '' Channel loop
              ' Get channel data from hub
              setq #DSP_RWLONGS+DSP_RDLONGS-1
              rdlong dsp_sbuf,ptra

              'debug(`dspv 'what the shit' 13)

              '' Handle Key-off
              testb dsp_koff,dsp_chan wc
        if_c  mov dsp_envstat,#ENV_RELEASE

              '' Pitch modulation
              zerox dsp_pitch,#13
              'sar dsp_modout,#1
              testb dsp_pmon_non_eon,dsp_chan wc
        if_c scas dsp_modout,dsp_pitch
        if_c add dsp_pitch,0-0
              fges dsp_pitch,#0
              fles dsp_pitch,dsp_maxpitch
              '' Handle some stuff related to Key-On
              bitl dsp_kon_latch,dsp_chan wcz
        if_z  mov dsp_gausspos,#0 ' Reset phase on key-on
        if_z  mov dsp_envlvl,#0
        if_z  mov dsp_envstat,#ENV_ATTACK
        if_z  mov dsp_sbuf+4,#0
        if_z  mov dsp_sbuf+5,#0
        if_z  mov dsp_sbuf+6,#0
        if_z  mov dsp_sbuf+7,#0
              '' Figure out reload address
              getbyte ptrb,dsp_dir_esa_edl,#0
              getbyte pa,dsp_src_adsr_gain,#0
              shl ptrb,#6
              add ptrb,pa
              shl ptrb,#2
              zerox ptrb,#15
              add ptrb,sp_rambase
        if_z  rdword dsp_brrbase,ptrb ' if key-on, read start ptr
              '' Phase accumulate
              testb dsp_gausspos,#14 wc
        if_nz add dsp_gausspos,dsp_pitch
              testb dsp_gausspos,#14 xorc
        if_00 jmp #.no_brrdecode

              '' Decode 4 BRR samples
              ' Get header
              mov pa,dsp_brrbase
              add pa,sp_rambase
              rdbyte dsp_tmp4,pa
              ' Handle end of sample
              testbn dsp_tmp4,#1 wc ' Loop flag
              testb dsp_tmp4,#0 andc ' End flag?
              testb dsp_flg,#7 orc ' Reset?
        if_c  mov dsp_envstat,#ENV_RELEASE
        if_c  mov dsp_envlvl,#0
              ' figure out BRR offset and buffer target using top nibble of phase
              mov pa,dsp_gausspos
              shr pa,#12+2 ' reduce to four-sample granularity
              and pa,#3    ' 16 samples in a block
        if_nz incmod pa,#3 ' need to load the next one (except when key-on)
              mov dsp_tmp3,pa
              shl pa,#1     ' 4 samples -> 2 bytes
              add pa,#1     ' skip header
              add pa,dsp_brrbase
              add pa,sp_rambase ' Note: no provisions made for trying to read a sample across the memory wraparound
              rdword dsp_tmp1,pa ' got the data
              ' Figure out parameters from header
              getnib pa,dsp_tmp4,#0
              shr pa,#2
              alts pa,#dsp_brrpred_tbl
              mov dsp_tmp6,0-0
              getword dsp_tmp5,dsp_tmp6,#1 ' tmp5/tmp6 are first/second prediction coefficient
              getnib pb,dsp_tmp4,#1 ' scale (invalid values are not treated correctly)
              subr pb,#28+1
              ' Move buffer
              mov dsp_sbuf+0,dsp_sbuf+4
              mov dsp_sbuf+1,dsp_sbuf+5
              mov dsp_sbuf+2,dsp_sbuf+6
              mov dsp_sbuf+3,dsp_sbuf+7

              ' First sample
              getnib dsp_sbuf+4,dsp_tmp1,#1
              shl dsp_sbuf+4,#28
              sar dsp_sbuf+4,pb
              scas dsp_sbuf+3,dsp_tmp5 ' s[t-1]
              add dsp_sbuf+4,0-0
              scas dsp_sbuf+2,dsp_tmp6 ' s[t-2]
              add dsp_sbuf+4,0-0
              fges dsp_sbuf+4,dsp_min
              fles dsp_sbuf+4,dsp_max
              shl dsp_sbuf+4,#1
              ' Second sample
              getnib dsp_sbuf+5,dsp_tmp1,#0
              shl dsp_sbuf+5,#28
              sar dsp_sbuf+5,pb
              scas dsp_sbuf+4,dsp_tmp5 ' s[t-1]
              add dsp_sbuf+5,0-0
              scas dsp_sbuf+3,dsp_tmp6 ' s[t-2]
              add dsp_sbuf+5,0-0
              fges dsp_sbuf+5,dsp_min
              fles dsp_sbuf+5,dsp_max
              shl dsp_sbuf+5,#1
              ' Third sample
              getnib dsp_sbuf+6,dsp_tmp1,#3
              shl dsp_sbuf+6,#28
              sar dsp_sbuf+6,pb
              scas dsp_sbuf+5,dsp_tmp5 ' s[t-1]
              add dsp_sbuf+6,0-0
              scas dsp_sbuf+4,dsp_tmp6 ' s[t-2]
              add dsp_sbuf+6,0-0
              fges dsp_sbuf+6,dsp_min
              fles dsp_sbuf+6,dsp_max
              shl dsp_sbuf+6,#1
              ' Fourth sample
              getnib dsp_sbuf+7,dsp_tmp1,#2
              shl dsp_sbuf+7,#28
              sar dsp_sbuf+7,pb
              scas dsp_sbuf+6,dsp_tmp5 ' s[t-1]
              add dsp_sbuf+7,0-0
              scas dsp_sbuf+5,dsp_tmp6 ' s[t-2]
              add dsp_sbuf+7,0-0
              fges dsp_sbuf+7,dsp_min
              fles dsp_sbuf+7,dsp_max
              shl dsp_sbuf+7,#1

              ' Note: decoded samples are clamped to 16 bits, _then doubled_
              '       but need to be truncated to 16 bits afterwards? (hardware bug?)
              '       Truncation happens autmagically when using MULS/SCAS.

              ' advance BRR pointer if we're done with this block
              cmp dsp_tmp3,#3 wz
        if_x1 add dsp_brrbase,#9
              zerox dsp_brrbase,#15
              testb dsp_tmp4,#0 andz ' End flag?
        if_x1 bith dsp_endx,dsp_chan
        if_x1 rdword dsp_brrbase,ptrb[1] ' read loop pointer

.no_brrdecode


              '' Gaussian interpolation
              ' Get coefficents
              getnib ptrb,dsp_gausspos,#2
              rolnib ptrb,dsp_gausspos,#1
              shl ptrb,#2
dsp_gt_patch1 rdlong dsp_tmp2,ptrb[##dsp_gausstbl] ' "reverse"
              bitnot ptrb,#2 addbits 7
dsp_gt_patch2 rdlong dsp_tmp1,ptrb[##dsp_gausstbl] ' "forward"

              getnib pb,dsp_gausspos,#3
              and pb,#3
              ' Do the thing
              alts pb,#dsp_sbuf+0
              scas dsp_tmp1,0-0
              mov dsp_output,0-0

              getword pa,dsp_tmp1,#1
              alts pb,#dsp_sbuf+1
              scas pa,0-0
              add dsp_output,0-0

              getword pa,dsp_tmp2,#1
              alts pb,#dsp_sbuf+2
              scas pa,0-0
              add dsp_output,0-0
              signx dsp_output,#15 ' first three overflow

              alts pb,#dsp_sbuf+3
              scas dsp_tmp2,0-0
              add dsp_output,0-0
              ' saturate last add
              fges dsp_output,dsp_min
              fles dsp_output,dsp_max


              getbyte pa,dsp_pmon_non_eon,#1
              testb pa,dsp_chan wc ' Noise on?
        if_c  mov dsp_output,dsp_noise

              '' Envelope generator
              mov dsp_tmp1,dsp_envlvl
              mov dsp_tmp2,#31 ' default rate (for release/static-GAIN)

              cmp dsp_envstat,#ENV_RELEASE wc
        if_ae sub dsp_tmp1,#8
        if_ae jmp #.envelope_done


              testb dsp_src_adsr_gain,#7+8 wc ' ADSR enabled?
        if_nc jmp #.gainmode

              getbyte dsp_tmp3,dsp_src_adsr_gain,#2 ' Second ADSR register supplies sustain level
              cmp dsp_envstat,#ENV_DECAY wcz
        if_1x getnib  dsp_tmp2,dsp_src_adsr_gain,#2 ' Attack/decay rate
        if_01 getnib  dsp_tmp2,dsp_src_adsr_gain,#3 ' decay rate
              addx dsp_tmp2,dsp_tmp2 ' when attack, rate = rate*2+1 (carry); when decay rate = rate*2 + 16 (implied from ADSR enable bit)
        if_00 getbyte dsp_tmp2,dsp_src_adsr_gain,#2 ' Sustain rate
              cmp dsp_tmp2,#31 wz
        if_10 add dsp_tmp1,#32
        if_0x sub dsp_tmp1,#1
        if_0x scas dsp_tmp1,#$40
    if_not_10 sumnc dsp_tmp1,sp_400h
              jmp #.envelope_done

.gainmode     ' Use GAIN register
              getbyte dsp_tmp3,dsp_src_adsr_gain,#3 ' GAIN register supplies sustain level (HW bug?)
              testb dsp_src_adsr_gain,#7+24 wc
        if_nc getbyte dsp_tmp1,dsp_src_adsr_gain,#3
        if_nc shl dsp_tmp1,#4
        if_nc jmp #.envelope_done
              getbyte dsp_tmp2,dsp_src_adsr_gain,#3
              testb dsp_src_adsr_gain,#6+24 wc
              testb dsp_src_adsr_gain,#5+24 wz
        if_01 sub dsp_tmp1,#1
        if_01 scas dsp_tmp1,#$40
              sumnc dsp_tmp1,#32
        if_11 cmp dsp_gainbend,dsp_tmp1 wc
        if_11 sub dsp_tmp1,#24


.envelope_done
              shr dsp_tmp3,#5
              getbyte pa,dsp_tmp1,#1
              cmp dsp_tmp3,pa wz
        if_z  cmp dsp_envstat,#ENV_DECAY wz
        if_z  mov dsp_envstat,#ENV_SUSTAIN

              cmp dsp_envstat,#ENV_ATTACK wz
              fges dsp_tmp1,#0 wc
        if_nc fles dsp_tmp1,dsp_maxenv wc
        if_11 mov dsp_envstat,#ENV_DECAY

              and dsp_tmp2,#31
              altgb dsp_tmp2,#dsp_rateremap
              getbyte dsp_tmp2
              testb dsp_rates,dsp_tmp2 wc
        if_c  mov dsp_envlvl,dsp_tmp1


              '' Output!
              muls dsp_output,dsp_envlvl
              sar dsp_output,#11+1
              mov dsp_modout,dsp_output
              'cmp dsp_chan,#3 wz '' DEBUG
        'if_nz mov dsp_output,#0 '' DEBUG
              ' Mix into output
              getword dsp_tmp2,dsp_cvol,#1 ' right volume (left is in lowword of dsp_cvol)
              getbyte pa,dsp_pmon_non_eon,#2
              testb pa,dsp_chan wc ' Echo on?
              scas dsp_output,dsp_cvol
              add dsp_lsample,0-0
              fges dsp_lsample,dsp_min
              fles dsp_lsample,dsp_max
        if_c  scas dsp_output,dsp_cvol
        if_c  add dsp_lecho,0-0
              fges dsp_lecho,dsp_min
              fles dsp_lecho,dsp_max
              scas dsp_output,dsp_tmp2
              add dsp_rsample,0-0
              fges dsp_rsample,dsp_min
              fles dsp_rsample,dsp_max
        if_c  scas dsp_output,dsp_tmp2
        if_c  add dsp_recho,0-0
              fges dsp_recho,dsp_min
              fles dsp_recho,dsp_max


              'debug(`dspv '`uhex_word_(dsp_pitch) `(dsp_envstat) `uhex_word_(dsp_envlvl) `uhex_word_(dsp_brrbase) `uhex_word_(dsp_gausspos) `uhex_long_(dsp_cvol) `uhex_word_(dsp_output)' 13)

              setq #DSP_RWLONGS-1
              wrlong dsp_sbuf,ptra
              add ptra,#DSP_CHANNEL_SIZE*4
              incmod dsp_chan,#7 wc
        if_nc jmp #dsp_chloop
''
''
              'debug(`dspv '`ubin_byte_(dsp_endx) `uhex_byte_(sp_tfreq0) `uhex_byte_(sp_tval0) `uhex_byte_(sp_ctr0)')


              '' Update echo
              ' Advance echo history
              mov dsp_ehist+0,dsp_ehist+1
              mov dsp_ehist+1,dsp_ehist+2
              mov dsp_ehist+2,dsp_ehist+3
              mov dsp_ehist+3,dsp_ehist+4
              mov dsp_ehist+4,dsp_ehist+5
              mov dsp_ehist+5,dsp_ehist+6
              mov dsp_ehist+6,dsp_ehist+7
              ' Read echo data into history
              getbyte ptrb,dsp_dir_esa_edl,#1
              shl ptrb,#8
              add ptrb,dsp_eoff
              zerox ptrb,#15
              add ptrb,sp_rambase
              rdlong dsp_ehist+7,ptrb
              testb dsp_ehist+7,#15 wc
              bitc dsp_ehist+7,#16
              sar dsp_ehist+7,#1
              ' Advance pointer
              add dsp_eoff,#4
              zerox dsp_eoff,#15
              cmp dsp_eoff,dsp_ewrap wz
              ' Reset pointer if end reached
        if_z  mov dsp_eoff,#0
        if_z  getnib dsp_ewrap,dsp_dir_esa_edl,#4
        if_z  shl dsp_ewrap,#11
        if_z  fge dsp_ewrap,#4
              ' run FIR filter
              scas dsp_efir+0,dsp_ehist+0
              mov dsp_tmp1,0-0
              getword pa,dsp_ehist+0,#1
              scas dsp_efir+0,pa
              mov dsp_tmp2,0-0

              scas dsp_efir+1,dsp_ehist+1
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+1,#1
              scas dsp_efir+1,pa
              add dsp_tmp2,0-0

              scas dsp_efir+2,dsp_ehist+2
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+2,#1
              scas dsp_efir+2,pa
              add dsp_tmp2,0-0

              scas dsp_efir+3,dsp_ehist+3
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+3,#1
              scas dsp_efir+3,pa
              add dsp_tmp2,0-0

              scas dsp_efir+4,dsp_ehist+4
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+4,#1
              scas dsp_efir+4,pa
              add dsp_tmp2,0-0

              scas dsp_efir+5,dsp_ehist+5
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+5,#1
              scas dsp_efir+5,pa
              add dsp_tmp2,0-0

              scas dsp_efir+6,dsp_ehist+6
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+6,#1
              scas dsp_efir+6,pa
              add dsp_tmp2,0-0
              ' let taps 0..6 overflow
              signx dsp_tmp1,#15
              signx dsp_tmp2,#15

              scas dsp_efir+7,dsp_ehist+7
              add dsp_tmp1,0-0
              getword pa,dsp_ehist+7,#1
              scas dsp_efir+7,pa
              add dsp_tmp2,0-0
              ' saturate last add
              fges dsp_tmp1,dsp_min
              fges dsp_tmp2,dsp_min
              fles dsp_tmp1,dsp_max
              fles dsp_tmp2,dsp_max


              ' Echo feedback
              scas dsp_tmp1,dsp_efb
              add dsp_lecho,0-0
              scas dsp_tmp2,dsp_efb
              add dsp_recho,0-0
              fges dsp_lecho,dsp_min
              fges dsp_recho,dsp_min
              fles dsp_lecho,dsp_max
              fles dsp_recho,dsp_max
              ' Master volume
              muls dsp_lsample,dsp_mvol
              sar dsp_lsample,#14
              getword pa,dsp_mvol,#1
              muls dsp_rsample,pa
              sar dsp_rsample,#14
              ' Echo volume
              scas dsp_tmp1,dsp_evol
              add dsp_lsample,0-0
              getword pa,dsp_evol,#1
              scas dsp_tmp2,pa
              add dsp_rsample,0-0
              ' saturate output
              fges dsp_lsample,dsp_min
              fges dsp_rsample,dsp_min
              fles dsp_lsample,dsp_max
              fles dsp_rsample,dsp_max

              '' write echo data
              rolword dsp_recho,dsp_lecho,#0
              bitl dsp_recho,#0
              bitl dsp_recho,#16
              testbn dsp_flg,#5 wc ' Echo write enabled?
        if_c  wrlong dsp_recho,ptrb ' ptrb is still pointing to echo buffer


              'debug(`dspv ' `uhex_word_(dsp_lsample)')

              testb dsp_flg,#6 wc ' Mute?
        if_c  mov dsp_lsample,#0
        if_c  mov dsp_rsample,#0


              add dsp_xct,#1
              testb dsp_xct,#14 wc
              'drvc #38 ' Hearbeat LED

              jmp #\sp_nextop


DAT ' SPCcog init code
              orgh
sp_init



              loc ptrb,#sp_cogblob
              'debug(uhex_long(ptrb))
              setq #502-1
              rdlong 0,ptrb
              loc ptrb,#sp_lutblob
              setq2 #511
              rdlong 0,ptrb

              'drvl #38 addpins 1 ' init LEDs

              {
              loc pa,#dsp_run
              add dsp_run_ptch,pa
              '' TODO: move patching to spin and make sure we only do it once
              loc pa,#dsp_gausstbl
              loc ptrb,#dsp_gt_patch1
              call #sp_patch_augptr
              loc pa,#dsp_gausstbl
              loc ptrb,#dsp_gt_patch2
              call #sp_patch_augptr  }

              'debug(uhex_long(ptra,sp_rambase))
              bitl ptra,#31 wcz
        if_nc getword sp_pc,ptra,#0 ' Boot directly
              {
        if_nc jmp #.no_spcload

              '' Load SPC dump
              add ptra,#$25 ' jump past guff
              rdword sp_pc,ptra[0]
              rdbyte sp_a,ptra[2]
              rdbyte sp_x,ptra[3]
              rdbyte sp_y,ptra[4]
              rdbyte sp_psw,ptra[5]
              testb sp_psw,#SP_PAGE_BIT wc
              wrc sp_dpage
              rdbyte sp_sp,ptra[6]
              add ptra,#$100-$25 ' Jump past tags
              ' Copy memory
              'debug("before loading ram ",uhex_long(ptra))
              mov ptrb,sp_rambase
              cmp ptra,ptrb wz
        if_z  add ptra,##$10000
        if_z  jmp #.memcpy_loop
              rep @.memcpy_loop,##$10000/(8*4)
              setq #8-1
              rdlong dsp_sbuf,ptra++
              setq #8-1
              wrlong dsp_sbuf,ptrb++
.memcpy_loop
              mov dsp_addr,#0
              mov ptrb,ptra
              'debug("before loading dsp ",uhex_long(ptrb))
              'debug(uhex_byte_array(ptrb,#128))
.dspset_loop
              'debug(uhex_byte(dsp_addr),uhex_long(ptrb))
              rdbyte sp_memv,ptrb++
              mov ptra,sp_statbase ' dsp write needs this
              call #dsp_write
              incmod dsp_addr,#127 wc
        if_nc jmp #.dspset_loop

              ' Init echo wrap point
              getnib dsp_ewrap,dsp_dir_esa_edl,#4
              shl dsp_ewrap,#11
              fge dsp_ewrap,#4

              ' Clear echo buffer, seems to be the right thing to do (or not?)
              testbn dsp_flg,#5 wc ' definitely only clear if echo is actually enabled
              getbyte pa,dsp_dir_esa_edl,#1
              shl pa,#8
              mov pb,dsp_ewrap
              shr pb,#2
              rep @.eclr_loop,pb
              add pa,sp_rambase
        if_c  wrlong #0,pa
              sub pa,sp_rambase
              add pa,#4
              zerox pa,#15
.eclr_loop




              sub ptrb,##$10000+$80-$F0 ' move to MMIO area
              'debug("before loading MMIO ",uhex_long(ptrb))
              rdbyte pa,ptrb[1] ' $F1: control
              getnib sp_tstat,pa,#0
              testb pa,#7 wc
              negnc sp_romstart,sp_firmaddr
              rdbyte dsp_addr,ptrb[2] ' $F2: DSP address
              rdlong pa,ptrb[4/4] ' $F4..$F7: input ports
              wrlong pa,sp_statbase
              rdbyte pa,ptrb[8]
              sets sp_f8,pa
              rdbyte pa,ptrb[9]
              sets sp_f9,pa
              rdbyte sp_tfreq0,ptrb[10]
              rdbyte sp_tfreq1,ptrb[11]
              rdbyte sp_tfreq2,ptrb[12]
              rdbyte sp_ctr0,ptrb[13]
              and sp_ctr0,#15
              rdbyte sp_ctr1,ptrb[14]
              and sp_ctr1,#15
              rdbyte sp_ctr2,ptrb[15]
              and sp_ctr2,#15

              'debug(uhex_word(sp_pc),uhex_byte(sp_a,sp_x,sp_y))
              'debug("SPC init done")

.no_spcload
              }
              ' setup pins (MEGA TODO FOR TIMING)
              wrpin ##P_DAC_75R_2V|P_OE|P_DAC_DITHER_RND,dsp_lpin
              wrpin ##P_DAC_75R_2V|P_OE|P_DAC_DITHER_RND,dsp_rpin
              wxpin ##_CLKFREQ/DSP_SAMPLE_RATE,dsp_lpin
              wxpin ##_CLKFREQ/DSP_SAMPLE_RATE,dsp_rpin
              wypin dsp_daccenter,dsp_lpin
              wypin dsp_daccenter,dsp_rpin
              drvl dsp_lpin
              drvl dsp_rpin
              ' Setup event on left pin ready
              mov pa,#%001_000000
              add pa,dsp_lpin
              setse1 pa

              jmp #\sp_nextop '' GO!

DAT ' SPC700 firmware ROM
              orgh
spc_firmware
byte        $CD, $EF, $BD, $E8, $00, $C6, $1D, $D0, $FC, $8F, $AA, $F4, $8F, $BB, $F5, $78
byte        $CC, $F4, $D0, $FB, $2F, $19, $EB, $F4, $D0, $FC, $7E, $F4, $D0, $0B, $E4, $F5
byte        $CB, $F4, $D7, $00, $FC, $D0, $F3, $AB, $01, $10, $EF, $7E, $F4, $10, $EB, $BA
byte        $F6, $DA, $00, $BA, $F4, $C4, $F4, $DD, $5D, $D0, $DB, $1F, $00, $00, $C0, $FF

DAT ' S-DSP Gaussian table
              orgh
dsp_gausstbl  file "DSPGAUSS.DAT"

apu_status
apu_inport      long 0
apu_outport     long 0
apu_chanstat    long 0[8*DSP_CHANNEL_SIZE]


DAT ' stuff
              orgh
mosaic_table        file "MOSAIC.DAT" ' weirdly sized


romdata_cache byte 0[32]


              orgh $0_C000

palette_current     long 0[256]
                    long 0[2] ' a slice offset of two speeds up copy loop
palette_ring        long 0[256*2]
dcolor_table        file "DCOLOR.DAT"
                    long 0[6] ' make slices whole again

scanout_buffer      long $FF00FF00[OUTBUFFER_WIDTH*2]

composite_buffer    word 0[512*2]

                    byte 0[8] ' pre-padding
layer_buffer        byte 0[12*(256+8)]

oam                 byte 0[128*6]

              orgh $1_0000
vram          byte 0[$1_0000]
work_ram      orgh $2_0000
              'file "6502_functional_test.bin"
              'file "65C02_extended_opcodes_test.bin"
              'file "6502_decimal_test.bin"
              byte 0[$1_0000]
              byte 0[$1_0000]
              orgh $4_0000
audio_ram     byte 0[$1_0000]



              orgh UPPER_LOAD
              file "misoyume_upper.binary"